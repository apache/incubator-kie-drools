<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="../" xmlns="http://docbook.org/ns/docbook" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:ns="http://docbook.org/ns/docbook">

    <title>A Little Theory</title>

    <section>
      <title>Methods versus Rules</title>

      <para>People often confuse methods and rules, and new rule users regular
      ask, "How do I call a rule?" After the last section, you are now
      feeling like a rule expert and the answer to that is obvious, but let's
      summarize the differences nonetheless.</para>

      <programlisting>public void helloWorld(Person person) {
    if ( person.getName().equals( "Chuck" ) ) {
        System.out.println( "Hello Chuck" );
    }
}</programlisting>

      <itemizedlist>
        <listitem>
          <para>Methods are called directly.</para>
        </listitem>

        <listitem>
          <para>Specific instances are passed.</para>
        </listitem>

        <listitem>
          <para>One call results in a single execution.</para>
        </listitem>
      </itemizedlist>

      <programlisting>rule "Hello World"
    when
        Person( name == "Chuck" )
    then
        System.out.println( "Hello Chuck" );
        end</programlisting>

      <itemizedlist>
        <listitem>
          <para>Rules execute by matching against any data as long it is
          inserted into the engine.</para>
        </listitem>

        <listitem>
          <para>Rules can never be called directly.</para>
        </listitem>

        <listitem>
          <para>Specific instances cannot be passed to a rule.</para>
        </listitem>

        <listitem>
          <para>Depending on the matches, a rule may fire once or several
          times, or not at all.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Cross Products</title>

      <para>Earlier the term "cross product" was mentioned, which is the
      result of a join. Imagine for a moment that the data from the
      fire alarm example were used in combination with the following
      rule where there ar no field constraints:</para>

      <programlisting>rule
when
    $room : Room()
    $sprinkler : Sprinkler()
then
    System.out.println( "room:" + $room.getName() +
                        " sprinkler:" + $sprinkler.getRoom().getName() );
end</programlisting>

      <para>In SQL terms this would be like doing <code>select * from Room,
      Sprinkler</code> and every row in the Room table would be joined with every
      row in the Sprinkler table resulting in the following output:</para>

      <programlisting>room:office sprinker:office
room:office sprinkler:kitchen
room:office sprinkler:livingroom
room:office sprinkler:bedroom
room:kitchen sprinkler:office
room:kitchen sprinkler:kitchen
room:kitchen sprinkler:livingroom
room:kitchen sprinkler:bedroom
room:livingroom sprinkler:office
room:livingroom sprinkler:kitchen
room:livingroom sprinkler:livingroom
room:livingroom sprinkler:bedroom
room:bedroom sprinkler:office
room:bedroom sprinkler:kitchen
room:bedroom sprinkler:livingroom
room:bedroom sprinkler:bedroom</programlisting>

      <para>These cross products can obviously become huge, and they may
      very well contain spurious data. The size of cross products is
      often the source of performance problems for new rule authors.
      From this it can be seen that it's always desirable to constrain
      the cross products, which is done with the variable constraint.</para>

      <programlisting>rule
when
    $room : Room()
    $sprinkler : Sprinkler( room == $room )
then
    System.out.println( "room:" + $room.getName() +
                        " sprinkler:" + $sprinkler.getRoom().getName() );
end</programlisting>

      <para>This results in just four rows of data, with the correct Sprinkler
      for each Room. In SQL (actually HQL) the corresponding query would be
      <code>select * from Room, Sprinkler where Room == Sprinkler.room</code>.</para>

      <programlisting>room:office sprinkler:office
room:kitchen sprinkler:kitchen
room:livingroom sprinkler:livingroom
room:bedroom sprinkler:bedroom</programlisting>
    </section>

    <section>
      <title>Activations, Agenda and Conflict Sets.</title>

      <para>So far the data and the matching process has been simple and small. To
      mix things up a bit a new example will be explored that handles cashflow
      calculations over date periods. The state of the engine will be
      illustratively shown at key stages to help get a better understanding
      of what is actually going on under the hood. Three classes will be used,
      as shown below.</para>

      <programlisting>public class CashFlow {
    private Date   date;
    private double amount;
    private int    type;
    long           accountNo;
    // getter and setter methods here
}

public class Account {
    private long   accountNo;
    private double balance;
    // getter and setter methods here
}

public AccountPeriod {
    private Date start;
    private Date end;
    // getter and setter methods here
}</programlisting>

      <para>By now you already know how to create Knowledge Bases and how to
      instantiate facts to populate the <code>StatefulKnowledgeSession</code>, so tables
      will be used to show the state of the inserted data, as it makes things
      clearer for illustration purposes. The tables below show that a single fact
      was inserted for the <code>Account</code>. Also inserted are a series of debits
      and credits as <code>CashFlow</code> objects for that account, extending over two
      quarters.</para>

      <figure>
        <title>CashFlows and Account</title>

        <mediaobject>
          <imageobject>
            <imagedata width="100%"
                       fileref="images/Chapter-Quick_Start/tables1.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Two rules can be used to determine the debit and credit for that
      quarter and update the Account balance. The two rules below constrain
      the cashflows for an account for a given time period. Notice the
      "&amp;&amp;" which use short cut syntax to avoid repeating the field
      name twice.</para>

      <informaltable frame="void">
        <tbody>
          <tr>
            <td align="left" valign="top">
              <programlisting>rule "increase balance for credits"
when
  ap : AccountPeriod()
  acc : Account( $accountNo : accountNo )
  CashFlow( type == CREDIT,
    accountNo == $accountNo,
    date &gt;= ap.start &amp;&amp; &lt;= ap.end,
    $amount : amount )
then
  acc.balance  += $amount;
end</programlisting>
            </td>

            <td align="left" valign="top">
              <programlisting>rule "decrease balance for debits" 
when 
  ap : AccountPeriod() 
  acc : Account( $accountNo : accountNo ) 
  CashFlow( type == DEBIT, 
    accountNo == $accountNo,
    date &gt;= ap.start &amp;&amp; &lt;= ap.end, 
    $amount : amount ) 
then 
  acc.balance -= $amount; 
end</programlisting>
            </td>
          </tr>
        </tbody>
      </informaltable>

      <para>If the <code>AccountPeriod</code> is set to the first quarter we constrain the
      rule "increase balance for credits" to fire on two rows of data and
      "decrease balance for debits" to act on one row of data.</para>

      <figure>
        <title>AccountingPeriod, CashFlows and Account</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter-Quick_Start/tables2.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The two cashflow tables above represent the matched data for the
      two rules. The data is matched during the insertion stage and, as you
      discovered in the previous chapter, does not fire straight away, but only
      after <code>fireAllRules()</code> is called. Meanwhile, the rule plus its 
      matched data is
      placed on the Agenda and referred to as an Activation. The Agenda is a
      table of Activations that are able to fire and have their consequences
      executed, as soon as fireAllRules() is called. Activations on the
      Agenda are executed in turn. Notice that the order of execution 
      so far is considered arbitrary.</para>

      <figure>
        <title>CashFlows and Account</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter-Quick_Start/tables7.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>After all of the above activations are fired, the account has a
      balance of -25.</para>

      <figure>
        <title>CashFlows and Account</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter-Quick_Start/tables3.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>If the <code>AccountPeriod</code> is updated to the second quarter, we have just
      a single matched row of data, and thus just a single Activation on the
      Agenda.</para>

      <figure>
        <title>CashFlows and Account</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter-Quick_Start/tables4.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The firing of that Activation results in a balance of 25.</para>

      <figure>
        <title>CashFlows and Account</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter-Quick_Start/tables5.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>What if you don't want the order of Activation
      execution to be arbitrary? When there is one or more Activations on the
      Agenda they are said to be in conflict, and a conflict resolver strategy
      is used to determine the order of execution. At the simplest level the
      default strategy uses salience to determine rule priority. Each rule has
      a default value of 0, the higher the value the higher the priority. To
      illustrate this we add a rule to print the account balance, where we
      want this rule to be executed after all the debits and credits have
      been applied for all accounts. We achieve this by assigning a negative
      salience to this rule so that it fires after all rules with the default
      salience 0.</para>

      <table border="0">
        <tbody>
          <tr>
            <td>
              <programlisting>rule "Print balance for AccountPeriod"
        salience -50
    when
        ap : AccountPeriod()
        acc : Account()        
    then
        System.out.println( acc.accountNo + " : " + acc.balance );    
end</programlisting>
            </td>
          </tr>
        </tbody>
      </table>

      <para>The table below depicts the resulting Agenda. The three debit and credit
      rules are shown to be in arbitrary order, while the print rule is ranked
      last, to execute afterwards.</para>

      <figure>
        <title>CashFlows and Account</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter-Quick_Start/tables6.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Earlier we showed how rules would equate to SQL, which can often
      help people with an SQL background to understand rules.
      The two rules above can be represented with two views and a trigger for
      each view, as below:</para>

      <table border="0">
        <tbody>
          <tr>
            <td align="left" valign="top">
              <programlisting>select * from Account acc,
              Cashflow cf,
              AccountPeriod ap      
where acc.accountNo == cf.accountNo and 
      cf.type == CREDIT and
      cf.date &gt;= ap.start and 
      cf.date &lt;= ap.end</programlisting>
            </td>

            <td align="left" valign="top">
              <programlisting>select * from Account acc, 
              Cashflow cf,
              AccountPeriod ap 
where acc.accountNo == cf.accountNo and 
      cf.type == DEBIT and
      cf.date &gt;= ap.start and 
      cf.date &lt;= ap.end</programlisting>
            </td>
          </tr>

          <tr>
            <td align="left" valign="top">
              <programlisting>trigger : acc.balance += cf.amount</programlisting>
            </td>

            <td align="left" valign="top">
              <programlisting>trigger : acc.balance -= cf.amount</programlisting>
            </td>
          </tr>
        </tbody>
      </table>

      <para>Drools also features ruleflow-group attributes which allows
      workflow diagrams to declaratively specify when rules are allowed to
      fire. The screenshot below is taken from Eclipse using the Drools
      plugin. It has two ruleflow-group nodes which ensures that the calculation
      rules are executed before the reporting rules.</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Quick_Start/ruleflow.png" />
        </imageobject>
      </mediaobject>

      <para>The use of the ruleflow-group attribute in a rule is shown
      below.</para>

      <table border="0">
        <tbody>
          <tr>
            <td align="left" valign="top">
              <programlisting>rule "increase balance for credits"
  ruleflow-group "calculation"
when
  ap : AccountPeriod()
  acc : Account( $accountNo : accountNo )
  CashFlow( type == CREDIT,
            accountNo == $accountNo,
            date &gt;= ap.start &amp;&amp; &lt;= ap.end,
            $amount : amount )
then
  acc.balance  += $amount;
end</programlisting>
            </td>

            <td align="left" valign="top">
              <programlisting>rule "Print balance for AccountPeriod"
  ruleflow-group "report"
when
  ap : AccountPeriod()
  acc : Account()
then
  System.out.println( acc.accountNo +
                      " : " + acc.balance );    
end</programlisting>
            </td>
          </tr>
        </tbody>
      </table>
    </section>

 

</section>
