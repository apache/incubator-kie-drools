import org.drools.pmml_4_0.descr.*;
import org.drools.pmml_4_0.*;
import org.mvel2.templates.*;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.LinkedList;

global StringBuilder theory;
global TemplateRegistry registry;
global Map fld2var;
global PMML4Wrapper utils;



 function void applyTemplate(String templateName, Object context, TemplateRegistry registry, Map vars, StringBuilder builder) {
    CompiledTemplate template = (CompiledTemplate) registry.getNamedTemplate(templateName);
    builder.append(TemplateRuntime.execute(template, context, vars));
	//builder.append(TemplateRuntime.execute(template, context, new org.mvel2.integration.impl.DefaultLocalVariableResolverFactory()));
 }



// the function is repeated here because of rule processDerivedField_MapValues
    function String format(String type, String val) {
        if (type == null)
            return val;
		if ("Integer".equalsIgnoreCase(type))
			return val;
		else if ("Float".equalsIgnoreCase(type))
			return val;
		else if ("Double".equalsIgnoreCase(type))
			return val;
		else if ("Boolean".equalsIgnoreCase(type))
			return val;
		else if ("String".equalsIgnoreCase(type))
			return "\""+val+"\"";
		else if ("Date".equalsIgnoreCase(type))
			return "\""+val+"\"";
		else if ("Time".equalsIgnoreCase(type))
			return "\""+val+"\"";
		else if ("DateTime".equalsIgnoreCase(type))
			return "\""+val+"\"";
		else if ("DateDaysSince[0]".equalsIgnoreCase(type))
			return val;
		else if ("DateDaysSince[1960]".equalsIgnoreCase(type))
			return val;
		else if ("DateDaysSince[1970]".equalsIgnoreCase(type))
			return val;
		else if ("DateDaysSince[1980]".equalsIgnoreCase(type))
			return val;
		else if ("TimeSeconds".equalsIgnoreCase(type))
			return val;
		else if ("DateTimeSecondsSince[0]".equalsIgnoreCase(type))
			return val;
		else if ("DateTimeSecondsSince[1960]".equalsIgnoreCase(type))
			return val;
		else if ("DateTimeSecondsSince[1970]".equalsIgnoreCase(type))
			return val;
		else if ("DateTimeSecondsSince[1980]".equalsIgnoreCase(type))
			return val;
		else
			return val;
    }


//**********************************************************************************************************
//
//  COMPILATION RULES
//
//**********************************************************************************************************


//*********************************** HEADER SECTION *****************************************************//

rule "processHeader"
salience 9999
when
    $h : Header()
then
    HashMap map = new HashMap();
        map.put("pack",utils.getPack());
    applyTemplate("pmml_header.drlt", $h, registry, map, theory);
    retract($h);
end


//*********************************** DATA DICTIONARY ****************************************************//



declare TypeOfField
    name : String     @key
    dataType : DATATYPE
end



declare QueryMarker
    name : String
    context : String
end




rule "processDataDictionary"
when
    $dic : DataDictionary( $flds : dataFields )
then
    applyTemplate("rootDataField.drlt", utils, registry, new HashMap(), theory);
end


rule "typeOfDataField"
dialect "mvel"
when
    $fld : DataField( $n : name, $t : dataType )
then
    insertLogical( new TypeOfField($n,$t) );
end

rule "processDataField_define"
dialect "mvel"
when
    $fld : DataField( )
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("fullName",$fld.displayName);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("super",null);
        map.put("type",utils.mapDatatype($fld.dataType));
        map.put("modelType",null);
        //map.put("cyclic",("1".equals($fld.isCyclic)));
        //map.put("categorical","categorical".equalsIgnoreCase($fld.optype.value));
        //map.put("continuous","continuous".equalsIgnoreCase($fld.optype.value));
        //map.put("ordinal","ordinal".equalsIgnoreCase($fld.optype.value));
    applyTemplate("ioTypeDeclare.drlt", utils, registry, map, theory);
//    applyTemplate("updateIOField.drlt", utils, registry, map, theory);

end



rule "processDataField_entry"
dialect "mvel"
when
    $fld : DataField( $vals : values , $isize : intervals )
    $validVals : List( $vsize : size ) from collect (
        Value( property != "invalid", property != "missing" ) from $vals
    )
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("fullName",$fld.displayName);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("type",utils.mapDatatype($fld.dataType));
        map.put("cyclic",("1".equals($fld.isCyclic)));
        map.put("notRestricted", ($isize.size() == 0 && $vsize == 0));
        map.put("categorical","categorical".equalsIgnoreCase($fld.optype.value));
        map.put("continuous","continuous".equalsIgnoreCase($fld.optype.value));
        map.put("ordinal","ordinal".equalsIgnoreCase($fld.optype.value));
    applyTemplate("inputFromEP.drlt", utils, registry, map, theory);
end



rule "processDataField_interValidation_fixLeft"
salience 999
dialect "java"
when
    $fld : DataField( $ivals : intervals )
    $i : Interval( leftMargin == null ) from $ivals
then
    $i.setLeftMargin(-Double.MAX_VALUE);
end


rule "processDataField_interValidation_fixRight"
salience 999
dialect "java"
when
    $fld : DataField( $ivals : intervals )
    $i : Interval( rightMargin == null ) from $ivals
then
    $i.setRightMargin(Double.MAX_VALUE);
end

rule "processDataField_interValidation"
dialect "mvel"
when
    $fld : DataField( $vals : values , $isize : intervals.size > 0,
                      (optype.value == "continuous" || optype.value == "missing") )
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("ivals",$fld.intervals);
    applyTemplate("intervalsOnDomainRestriction.drlt", utils, registry, map, theory);
end



rule "processDataField_valueValidation_valid"
dialect "mvel"
when
    $fld : DataField( $vals : values, $vsize : values.size > 0 )
    $validz : List( size > 0 ) from accumulate (
                        $val : Value( property == null || (property != "missing" && property != "invalid") ) from $vals,
                        init ( List validz = new java.util.LinkedList(); ),
                        action ( validz.add(utils.format($fld,$val)); ),
                        result ( validz )
                      )
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("vals",$validz);
        map.put("field",$fld);
    applyTemplate("valuesOnDomainRestriction.drlt", utils, registry, map, theory);
end


rule "processDataField_valueValidation_missing"
dialect "mvel"
when
    $fld : DataField( $vals : values, $vsize : values.size > 0,
                      (optype.value == "continuous" || optype.value == "categorical") )
    $missingz : List( size > 0 ) from accumulate(
                        $val : Value( property == "missing" ) from $vals,
                        init( List missingz = new java.util.LinkedList(); ),
                        action( missingz.add(utils.format($fld,$val)); ),
                        result( missingz )
                      )
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("vals",$missingz);
        map.put("field",$fld);
    applyTemplate("valuesOnDomainRestrictionMissing.drlt", utils, registry, map, theory);
end


rule "processDataField_valueValidation_invalid"
dialect "mvel"
when
    $fld : DataField( $vals : values, $vsize : values.size > 0,
                      (optype.value == "continuous" || optype.value == "categorical") )
    $invalidz : List( size > 0 ) from accumulate(
                        $val : Value( property == "invalid" ) from $vals,
                        init( List invalidz = new java.util.LinkedList(); ),
                        action( invalidz.add(utils.format($fld,$val)); ),
                        result( invalidz )
                      )
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("vals",$invalidz);
        map.put("field",$fld);
    applyTemplate("valuesOnDomainRestrictionInvalid.drlt", utils, registry, map, theory);
end






//***************************************************************************************************************
//   TRANSFORMATIONS
//***************************************************************************************************************




//***************************************************************************************************************
//        Derived Fields definition
//              The transformationDictionary includes a set of derived field
//***************************************************************************************************************


rule "processDerivedField_define"
dialect "mvel"
when
    $fld : DerivedField( )
then
//    String opt = $fld.optype.value;
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("fullName",$fld.displayName);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("type",utils.mapDatatype($fld.dataType));
        map.put("super",null);
        map.put("modelType",null);
//        map.put("cyclic",false);
//        map.put("categorical","categorical".equalsIgnoreCase(opt));
//        map.put("continuous","continuous".equalsIgnoreCase(opt));
//        map.put("ordinal","ordinal".equalsIgnoreCase(opt));
    applyTemplate("ioTypeDeclare.drlt", utils, registry, map, theory);
//    applyTemplate("updateIOField.drlt", utils, registry, map, theory);
end


rule "typeOfDerivedField"
dialect "mvel"
when
    $fld : DerivedField( $n : name, $t : dataType )
then
    insertLogical( new TypeOfField($n,$t) );
end



//******************************************************************************************************************
//        Linear Transformations
//          Normalization, piecewise continuous
//******************************************************************************************************************


rule "processDerivedField_linearize_missing"
dialect "mvel"
when
    $fld : DerivedField( $nc : normContinuous )
    NormContinuous( this == $nc, $mapMissing : mapMissingTo != null )
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($nc.field));
        map.put("target",$mapMissing);
    applyTemplate("mapMissingValues.drlt", utils, registry, map, theory);
end



rule "processDerivedField_linearize_piecewiseInterpolate"
dialect "mvel"
when
    $fld : DerivedField( $nc : normContinuous, $name : name )
    TypeOfField( name == $name, $type : dataType )
    NormContinuous( this == $nc, $tracts : linearNorms )
then
    int num = $tracts.size();
    int j = 1;
    while (j < num) {
        java.util.HashMap map = new java.util.HashMap();
            map.put("context",utils.context);
            map.put("name",utils.compactUpperCase($fld.name));
            map.put("origField",utils.compactUpperCase($nc.field));
            map.put("xmin",((LinearNorm) $tracts.get(j-1)).orig);
            map.put("ymin",((LinearNorm) $tracts.get(j-1)).norm);
            map.put("xmax",((LinearNorm) $tracts.get(j)).orig);
            map.put("ymax",((LinearNorm) $tracts.get(j)).norm);
            map.put("index",j);
            map.put("type",utils.mapDatatype($type));
        applyTemplate("linearTractNormalization.drlt", utils, registry, map, theory);
        j++;
    }
end


rule "processDerivedField_linearize_outliers_asMissing"
dialect "mvel"
when
    $fld : DerivedField( $nc : normContinuous, $name : name  )
    TypeOfField( name == $name, $type : dataType )
    NormContinuous( this == $nc, $tracts : linearNorms, outliers.value == "asMissingValues" )
    $XMIN : Double() from accumulate ( LinearNorm( $x : orig ) from $tracts, min( $x ) )
    $XMAX : Double() from accumulate ( LinearNorm( $x : orig ) from $tracts, max( $x ) )
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($nc.field));
        map.put("xmin",$XMIN);
        map.put("xmax",$XMAX);
        map.put("type",utils.mapDatatype($type));
    applyTemplate("normContOutliersAsMissing.drlt", utils, registry, map, theory);
end


//
rule "processDerivedField_linearize_outliers_asExtreme"
dialect "mvel"
when
    $fld : DerivedField( $nc : normContinuous, $name : name  )
    TypeOfField( name == $name, $type : dataType )
    NormContinuous( this == $nc, $tracts : linearNorms, outliers.value == "asExtremeValues" )
    $XMIN : Double() from accumulate ( LinearNorm( $x : orig ) from $tracts, min( $x ) )
    $XMAX : Double() from accumulate ( LinearNorm( $x : orig ) from $tracts, max( $x ) )
    $YMIN : Double() from accumulate ( LinearNorm( $y : norm ) from $tracts, min( $y ) )
    $YMAX : Double() from accumulate ( LinearNorm( $y : norm ) from $tracts, max( $y ) )

then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($nc.field));
        map.put("xmin",$XMIN);
        map.put("xmax",$XMAX);
        map.put("ymin",$YMIN);
        map.put("ymax",$YMAX);
        map.put("type",utils.mapDatatype($type));
    applyTemplate("boundedLowerOutliers.drlt", utils, registry, map, theory);
    applyTemplate("boundedUpperOutliers.drlt", utils, registry, map, theory);
end

rule "processDerivedField_linearize_outliers_asExtrapolate"
dialect "mvel"
when
    $fld : DerivedField( $nc : normContinuous, $name : name  )
    TypeOfField( name == $name, $type : dataType )
    NormContinuous( this == $nc,  $tracts : linearNorms , $norms : linearNorms, outliers.value != "asMissingValues" && outliers.value != "asExtremeValues" )
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($nc.field));
        map.put("xmin",((LinearNorm) ($tracts.get(0))).orig);
        map.put("xmax",((LinearNorm) ($tracts.get(1))).orig);
        map.put("ymin",((LinearNorm) ($tracts.get(0))).norm);
        map.put("ymax",((LinearNorm) ($tracts.get(1))).norm);
        map.put("index",0);
        map.put("type",utils.mapDatatype($type));
    applyTemplate("lowerExtrapolateLinearTractNormalization.drlt", utils, registry, map, theory);

    int $N = $norms.size();
        map.put("xmin",((LinearNorm) ($tracts.get($N-2))).orig);
        map.put("xmax",((LinearNorm) ($tracts.get($N-1))).orig);
        map.put("ymin",((LinearNorm) ($tracts.get($N-2))).norm);
        map.put("ymax",((LinearNorm) ($tracts.get($N-1))).norm);
        map.put("index",$N);
    applyTemplate("upperExtrapolateLinearTractNormalization.drlt", utils, registry, map, theory);
end



//******************************************************************************************************************
//        Constants and References
//
//******************************************************************************************************************


rule "processDerivedField_constant"
dialect "mvel"
when
    $fld : DerivedField( $c : constant )
    Constant( this == $c, $x : value)
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("konst",$x);
    applyTemplate("constantField.drlt", utils, registry, map, theory);
end



rule "processDerivedField_fieldRef"
dialect "mvel"
when
    $fld : DerivedField( $ref : fieldRef )
    FieldRef( this == $ref, $f : field)
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
    applyTemplate("aliasedField.drlt", utils, registry, map, theory);
end




 //******************************************************************************************************************
 //        NormDiscrete
 //
 //******************************************************************************************************************


rule "processDerivedField_normDiscrete_basicField"
dialect "mvel"
when
    $fld : DerivedField( $nd : normDiscrete )
    NormDiscrete( this == $nd, $f : field , $x : value)
    DataField( name == $f, $dataType : dataType )
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
        map.put("target",utils.format($dataType,$x));
    applyTemplate("indicatorFieldYes.drlt", utils, registry, map, theory);
    applyTemplate("indicatorFieldNo.drlt", utils, registry, map, theory);
end



rule "processDerivedField_normDiscrete_derivedField"
dialect "mvel"
when
    $fld : DerivedField( $nd : normDiscrete )
    NormDiscrete( this == $nd, $f : field , $x : value)
    DerivedField( name == $f, $dataType : dataType )
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
        map.put("target",utils.format($dataType,$x));
    applyTemplate("indicatorFieldYes.drlt", utils, registry, map, theory);
    applyTemplate("indicatorFieldNo.drlt", utils, registry, map, theory);
end



rule "processDerivedField_normDiscrete_mapMissing"
dialect "mvel"
when
    $fld : DerivedField( $nd : normDiscrete )
    NormDiscrete( this == $nd, $f : field , $m : mapMissingTo != null )
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
        map.put("target",$m);
    applyTemplate("mapMissingValues.drlt", utils, registry, map, theory);
end


rule "processDerivedField_normDiscrete_cleanup"
dialect "mvel"
salience -5
when
    $fld : DerivedField( $nd : normDiscrete )
    NormDiscrete( this == $nd )
then
    retract($nd);
end

 //******************************************************************************************************************
 //       Binning / DiscretizeBin
 //
 //******************************************************************************************************************



rule "processDerivedField_Discretize_mapMissing"
dialect "mvel"
when
    $fld : DerivedField( $dx : discretize )
    Discretize( this == $dx, $f : field , $m : mapMissingTo != null , $dataType : dataType)
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
        map.put("target",utils.format($dataType,$m));
    applyTemplate("mapMissingValues.drlt", utils, registry, map, theory);
end


rule "processDerivedField_Discretize_propagateMissing"
dialect "mvel"
when
    $fld : DerivedField( $dx : discretize )
    Discretize( this == $dx, $f : field , $m : mapMissingTo == null )
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
    applyTemplate("propagateMissingValues.drlt", utils, registry, map, theory);
end

rule "processDerivedField_Discretize_defaultnull"
dialect "mvel"
when
    $fld : DerivedField( $dx : discretize )
    Discretize( this == $dx, $f : field , $d : defaultValue == null, $bins : discretizeBins )
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
        map.put("bins",$bins);
    applyTemplate("outOfBinningMissing.drlt", utils, registry, map, theory);
end


rule "processDerivedField_Discretize_default"
dialect "mvel"
when
    $fld : DerivedField( $dx : discretize )
    Discretize( this == $dx, $f : field , $d : defaultValue != null, $bins : discretizeBins, $dataType : dataType )
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
        map.put("bins",$bins);
        map.put("target",utils.format($dataType,$d));
    applyTemplate("outOfBinningDefault.drlt", utils, registry, map, theory);
end



rule "processDerivedField_Discretize_bin"
dialect "mvel"
when
    $fld : DerivedField( $dx : discretize )
    Discretize( this == $dx, $f : field , $d : defaultValue != null, $bins : discretizeBins, $dataType : dataType )
    $bin : DiscretizeBin( $interval : interval, $x : binValue ) from $bins
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
        map.put("intv",$interval);
        map.put("index",utils.nextCount());
        map.put("target",utils.format($dataType,$x));
    applyTemplate("intervalBinning.drlt", utils, registry, map, theory);
end



rule "processDerivedField_Discretize_cleanup"
dialect "mvel"
salience -10
when
    $fld : DerivedField( $dx : discretize )
    Discretize( this == $dx )
then
    retract($dx);
end

 //******************************************************************************************************************
 //     Value Mapping
 //
 //******************************************************************************************************************

declare MapSupportBean
   ref : MapValues
   columns : Map
   types : Map
end

rule "processDerivedField_MapValues_support_init"
dialect "mvel"
when
    $fld : DerivedField( $map : mapValues )
    MapValues( this == $map )
then
    MapSupportBean msb = new MapSupportBean();
        msb.setRef($map);
        msb.setColumns(new HashMap());
        msb.setTypes(new HashMap());
    insertLogical( msb );
end

rule "processDerivedField_MapValues_support"
dialect "mvel"
when
    $fld : DerivedField( $map : mapValues )
    MapValues( this == $map, $fcpairs : fieldColumnPairs )
    $sup : MapSupportBean( ref == $map )
    $fcp : FieldColumnPair() from $fcpairs
then
    $sup.columns.put($fcp.column, $fcp.field);
end


rule "processDerivedField_MapValues_support2"
dialect "mvel"
when
    $fld : DerivedField( $map : mapValues )
    MapValues( this == $map, $fcpairs : fieldColumnPairs )
    $sup : MapSupportBean( ref == $map )
    $fcp : FieldColumnPair() from $fcpairs
    DataField( name == $fcp.field, $type : dataType )
then
    $sup.types.put($fcp.column, $type.value);
end


rule "processDerivedField_extract"
salience -1
when
    $fld : DerivedField( $map : mapValues )
    MapValues( this == $map, $rows : inlineTable.rows, $outColumn : outputColumn )
    $row : Row( $cells : elementContent ) from $rows
then
    insertLogical( $row );
end


//TODO : can't use utils.format here, maybe a bug?
rule "processDerivedField_MapValues"
salience -2
dialect "mvel"
when
    $fld : DerivedField( $map : mapValues )
    MapValues( this == $map, $rows : inlineTable.rows, $outColumn : outputColumn )
    $sup : MapSupportBean( ref == $map,
                           $colMap : columns != null, $keys : columns.keySet,
                           $typeMap : types != null, $tkeys : types.keySet )
    $row : Row( $cells : elementContent, this memberOf $rows )
    $fieldRestrMap : java.util.HashMap() from accumulate (
        org.w3c.dom.Element( $tag : tagName != $outColumn, $text : textContent,
                             tagName memberOf $keys, tagName memberOf $tkeys ) from $cells,
        init( java.util.HashMap restr = new java.util.HashMap(); ),
        action(
            restr.put($colMap.get($tag),format($typeMap.get($tag),$text));
        ),
        result( restr )
    )
    org.w3c.dom.Element( $tag : tagName == $outColumn, $target : textContent ) from $cells
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("patterns",$fieldRestrMap);
        map.put("index",utils.nextCount());
        map.put("target",utils.format($fld.dataType.value,$target));
    applyTemplate("mapping.drlt", utils, registry, map, theory);
end



rule "processDerivedField_MapValues_cleanup"
dialect "mvel"
salience -10
when
    $fld : DerivedField( $map : mapValues )
    MapValues( this == $map )
then
    retract($map);
end

 //******************************************************************************************************************
 //     Aggregations
 //
 //******************************************************************************************************************

rule "processDerivedField_Collect"
dialect "mvel"
when
    $fld : DerivedField( $ag : aggregate )
    Aggregate( this == $ag, $func : function == "multiset",
                $groupBy : groupField, $afield : field, $constr : sqlWhere )
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("groupBy",$groupBy);
        map.put("afield",$afield);
        map.put("constr",$constr);
    applyTemplate("collect.drlt", utils, registry, map, theory);
end


rule "processDerivedField_Aggregation"
dialect "mvel"
when
    $fld : DerivedField( $ag : aggregate )
    Aggregate( this == $ag, $func : function != "multiset",
                $groupBy : groupField, $afield : field, $constr : sqlWhere )
then
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("groupBy",$groupBy);
        map.put("afield",$afield);
        map.put("dataType",utils.mapDatatype($fld.dataType));
        map.put("constr",$constr);
        map.put("aggrFunc",$func);
    applyTemplate("aggregate.drlt", utils, registry, map, theory);
end


rule "processDerivedField_Aggregate_cleanup"
dialect "mvel"
salience -10
when
    $fld : DerivedField( $agg : aggregate )
    Aggregate( this == $agg )
then
    retract($agg);
end



 //******************************************************************************************************************
 //     Functions
 //
 //******************************************************************************************************************


declare FunctionResult
    expr : String
    father : Apply
end




rule "processDerivedField_Apply"
dialect "mvel"
salience -5
when
    $fld : DerivedField( $app : apply )
    $a : Apply( this == $app, $fun : function, $arity : constantsAndFieldRevesAndNormContinuouses.size )
    $args : List( size == $arity ) from accumulate (
        $res : FunctionResult( father == $a, $x : expr ),
        init( List list = new LinkedList(); ),
        action( list.add($x); ),
        result ( list )
    )
then
    String funExpr = utils.mapFunction($fun, $args);
    //System.err.println(">>>>>>>>>>>>>>>>>>>>>>>>>  Built bit " + funExpr);

    Map exprFieldList = new java.util.LinkedHashMap();
    HashMap map = new HashMap();
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("dataType",utils.mapDatatype($fld.dataType));
        map.put("funExpr",funExpr);
        map.put("exprFieldList",fld2var);
    applyTemplate("apply.drlt", utils, registry, map, theory);

    retract($a);
    fld2var.clear();
end






rule "NestedConst"
dialect "mvel"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : function )
    $c : Constant( this memberOf $expr, $x : value)
then
    //System.out.println("Visit const : " + $x + " child of " + $f);
    insertLogical( new FunctionResult($x, $a) );
end

rule "NestedRef"
dialect "java"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : function )
    $fr : FieldRef( this memberOf $expr, $x : field )
then
    //System.out.println("Visit field : " + $x + " child of " + $f + " || " + fld2var);
    if (! fld2var.containsKey($x)) {
        fld2var.put($x,"$var"+fld2var.size());
    }
    insertLogical( new FunctionResult((String) fld2var.get($x), $a) );
end


rule "Scoop"
dialect "mvel"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : function )
    $a2 : Apply( this memberOf $expr, $f2 : function, $arity : constantsAndFieldRevesAndNormContinuouses.size )
    $args : List( size == $arity ) from accumulate (
        $res : FunctionResult( father == $a2, $x : expr ),
        init( List list = new LinkedList(); ),
        action( list.add($x); ),
        result ( list )
    )
then
    //System.err.println("Building bit for " + $f2 + " child of " + $f + " with args " + $args.size);
    String bit = utils.mapFunction($f2, $args);
    //System.err.println("Built bit " + bit + ", result for " + $f);
    insertLogical( new FunctionResult( bit , $a) );
    //System.err.println("Kill " + $f2 + "and its children results");
end




rule "NestedAggregate_onBasicField"
dialect "java"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : function )
    $agg : Aggregate( this memberOf $expr, $aggField : field )
    $super : DataField( name == $aggField, $optype : optype, $dataType : dataType)
then
    String name = "Inner"+utils.nextCount();
    DerivedField mockField = new DerivedField();
        mockField.setName(name);
        mockField.setOptype($optype);
        mockField.setDataType($dataType);
        mockField.setAggregate($agg);
    insertLogical(mockField);
    if (! fld2var.containsKey(name)) {
        fld2var.put( name,"$var"+fld2var.size() );
    }
    insertLogical( new FunctionResult((String) fld2var.get(name), $a) );
end


rule "NestedAggregate_onDerivedField"
dialect "java"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : function )
    $agg : Aggregate( this memberOf $expr, $aggField : field )
    $super : DerivedField( name == $aggField, $optype : optype, $dataType : dataType)
then
    String name = "Inner"+utils.nextCount();
    DerivedField mockField = new DerivedField();
        mockField.setName(name);
        mockField.setOptype($optype);
        mockField.setDataType($dataType);
        mockField.setAggregate($agg);
    insertLogical(mockField);
    if (! fld2var.containsKey(name)) {
        fld2var.put(name,"$var"+fld2var.size());
    }
    insertLogical( new FunctionResult((String) fld2var.get(name), $a) );
end


rule "NestedMapValues"
dialect "java"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : function )
    $map : MapValues( this memberOf $expr, $dataType : dataType  )
then
    String name = "Inner"+utils.nextCount();
    DerivedField mockField = new DerivedField();
        mockField.setName(name);
        mockField.setDataType($dataType);
        mockField.setMapValues($map);
        mockField.setOptype(OPTYPE.CONTINUOUS);
    insertLogical(mockField);
    if (! fld2var.containsKey(name)) {
        fld2var.put(name,"$var"+fld2var.size());
    }
    insertLogical( new FunctionResult((String) fld2var.get(name), $a) );
end


rule "NestedDiscretize"
dialect "java"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : function )
    $dix : Discretize( this memberOf $expr, $dataType : dataType  )
then
    String name = "Inner"+utils.nextCount();
    DerivedField mockField = new DerivedField();
        mockField.setName(name);
        mockField.setDataType($dataType);
        mockField.setDiscretize($dix);
        mockField.setOptype(OPTYPE.CATEGORICAL);
    insertLogical(mockField);
    if (! fld2var.containsKey(name)) {
        fld2var.put(name,"$var"+fld2var.size());
    }
    insertLogical( new FunctionResult((String) fld2var.get(name), $a) );
end


rule "NestedNormContinuous"
dialect "java"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : function )
    $nct : NormContinuous( this memberOf $expr  )
then
    String name = "Inner"+utils.nextCount();
    DerivedField mockField = new DerivedField();
        mockField.setName(name);
        mockField.setDataType(DATATYPE.DOUBLE);
        mockField.setNormContinuous($nct);
        mockField.setOptype(OPTYPE.CONTINUOUS);
    insertLogical(mockField);
    if (! fld2var.containsKey(name)) {
        fld2var.put(name,"$var"+fld2var.size());
    }
    insertLogical( new FunctionResult((String) fld2var.get(name), $a) );
end



rule "NestedNormDiscrete"
dialect "java"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : function )
    $ndx : NormDiscrete( this memberOf $expr  )
then
    String name = "Inner"+utils.nextCount();
    DerivedField mockField = new DerivedField();
        mockField.setName(name);
        mockField.setDataType(DATATYPE.DOUBLE);
        mockField.setNormDiscrete($ndx);
        mockField.setOptype(OPTYPE.CATEGORICAL);
    insertLogical(mockField);
    if (! fld2var.containsKey(name)) {
        fld2var.put(name,"$var"+fld2var.size());
    }
    insertLogical( new FunctionResult((String) fld2var.get(name), $a) );
end





  //******************************************************************************************************************
  //     User-defined Functions
  //
  //******************************************************************************************************************




 declare MatchContext
     father : Apply @key
     root : Apply @key
     body : Object
     params : Map
 end


 rule "visitApply_user_root"
 salience 15
 no-loop
 when
     $a : Apply( $args : constantsAndFieldRevesAndNormContinuouses, $fun : function  )
     DefineFunction( name == $fun, apply != $a )
     $df : DerivedField( apply == $a )
 then
     Apply idApply = new Apply();
         idApply.setFunction("identity");
         idApply.getConstantsAndFieldRevesAndNormContinuouses().add($a);
     $df.setNormContinuous(null);
     $df.setApply(idApply);
     retract($a);
     update($df);
 end



 rule "visitApply_user_nested"
 salience -1
 no-loop
 when
     $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $fun : function  )
     DefineFunction( name == $fun, $body : apply != $a, $paramFields : parameterFields )
     $father : Apply( $superArgs : constantsAndFieldRevesAndNormContinuouses contains $a )
     $params : java.util.LinkedHashMap() from accumulate (
         ParameterField( $name : name, $type : dataType ) from $paramFields,
         init( java.util.LinkedHashMap map = new java.util.LinkedHashMap(); int j = 0; ),
         action( map.put($name,new Integer(j++)); ),
         result( map )
     )
 then
     //System.out.println("\n\nINTERCEPTED USER-DEFINED APPLY " + $fun + " with params " + $params + " and args " + $expr.size() );


     // copy the function body to instantiate it
     Apply bodyInstance = (Apply) utils.copy($body);

     MatchContext mc = new MatchContext();
         mc.setFather($father);
         mc.setRoot($a);
         mc.setBody(bodyInstance.getConstantsAndFieldRevesAndNormContinuouses().get(0)); //body here is always identity
         mc.setParams($params);
     //System.out.println("\t About to insert context for");
     //System.out.println("\t\t father : " + $father);
     //System.out.println("\t\t root : " + $a);
     //System.out.println("\t\t body : " + mc.getBody());
     //System.out.println("\t\t ctx : " + $params + "\n\n");

     insert( mc );


 end



 rule "pre_visit_mc"
 no-loop
 salience 1000
 when
     MatchContext( $body : body )
 then
     insertLogical( $body );
 end


 rule "visit_mc"
 no-loop
 salience -1
 when
     MatchContext( $body : body, $params : params, $root : root )
     Apply( this == $root, $args : constantsAndFieldRevesAndNormContinuouses )
     $a : Apply( $bodyArgs : constantsAndFieldRevesAndNormContinuouses )
     $ref : FieldRef( this memberOf $bodyArgs, $fname : field )
     java.util.LinkedHashMap( keySet contains $fname ) from $params
 then
     //System.out.println("MC with body and args, found ref  " + $ref);

     int index = $bodyArgs.indexOf($ref);
     $bodyArgs.remove(index);
     Object arg = $args.get((Integer) $params.get($fname));
     $bodyArgs.add(index, utils.copy(arg));

     //System.out.println("REPLACE fieldRef in function " + $fname + " with " + arg + " in context " + $params);
 end









 rule "rebuildApply"
 salience -1
 no-loop
 when
     $mc : MatchContext( $father: father, $a : root, $newbody : body )
     Apply(  this == $a, $expr : constantsAndFieldRevesAndNormContinuouses, $fun : function  )
     DefineFunction( name == $fun )
     Apply( this == $father, $superArgs : constantsAndFieldRevesAndNormContinuouses )
 then
      //System.out.println("\t After some processing: matchContext ");
     //System.out.println("\t\t father : " + $mc.getFather());
     //System.out.println("\t\t root : " + $mc.getRoot());
     //System.out.println("\t\t body : " + $mc.getBody());
     //System.out.println("\t\t ctx : " + $mc.getParams() + "\n\n");
     retract($newbody);

     //System.out.println("REBUILD APPLY " + $fun + " with " + $newbody);
     int index = $superArgs.indexOf($a);
     $superArgs.remove(index);
     $superArgs.add(index,$newbody);

     //System.out.println("FATHER IS NOW  " + $father);
     retract($mc);
     update($father);
 end







//**********************************************************************************************************
//
//  MODELS
//
//**********************************************************************************************************

declare ModelStat
    neuralNetwork : boolean
end

rule "InitStats"
when

then
    insert(new ModelStat());
end









  //******************************************************************************************************************
  //     MiningSchema
  //
  //******************************************************************************************************************







rule "Preprocess_Inputs"
dialect "mvel"
when
    MiningSchema( $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs, usageType.value == "active" )
then
    //System.err.println("Found Mined Field " + $fld.name );
    HashMap map = new HashMap();
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("model",utils.context);
    applyTemplate("miningField.drlt", utils, registry, map, theory);
end


rule "Preprocess_Inputs_InvalidsAsInvalid"
dialect "mvel"
when
    MiningSchema( $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs,  usageType.value == "active", invalidValueTreatment.value == "returnInvalid" )
then
    //TODO : Do not eval, but return invalid !
end


rule "Preprocess_Inputs_InvalidsAsMissing"
dialect "java"
when
    MiningSchema(  $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs,  $name : name, usageType.value == "active",
                        invalidValueTreatment.value == "asMissing", $val : missingValueReplacement )
    TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap();
        map.put("name",utils.compactUpperCase($name));
        map.put("model",utils.context);
        map.put("replacement",utils.format( utils.mapDatatype($type), $val ) );
    applyTemplate("miningFieldInvalid.drlt", utils, registry, map, theory);
end






rule "Preprocess_Inputs_MissingReplacement"
dialect "java"
when
    MiningSchema( $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs,  $name : name, usageType.value == "active",
                        $val : missingValueReplacement != null )
    TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap();
        map.put("name",utils.compactUpperCase($name));
        map.put("model",utils.context);
        map.put("replacement",utils.format( utils.mapDatatype($type), $val));
    applyTemplate("miningFieldMissing.drlt", utils, registry, map, theory);
end




rule "Preprocess_Inputs_OutliersAsMissing" //numeric only
dialect "java"
when
    MiningSchema( $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs,  $name : name, usageType.value == "active",
                        outliers.value == "asMissingValues",
                        $low : lowValue, $upp : highValue )
    TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap();
        map.put("name",utils.compactUpperCase($name));
        map.put("model",utils.context);
        map.put("upp",utils.format(utils.mapDatatype($type),$upp));
        map.put("low",utils.format(utils.mapDatatype($type),$low));
    applyTemplate("miningFieldOutlierAsMissing.drlt", utils, registry, map, theory);
end


rule "Preprocess_Inputs_OutliersAsExtremeLow" //numeric only
dialect "java"
when
    MiningSchema( $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs,  $name : name, usageType.value == "active",
                        outliers.value == "asExtremeValues",
                        $low : lowValue != null )
    TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap();
        map.put("name",utils.compactUpperCase($name));
        map.put("model",utils.context);
        map.put("low",utils.format(utils.mapDatatype($type),$low));
    applyTemplate("miningFieldOutlierAsExtremeLow.drlt", utils, registry, map, theory);
end


rule "Preprocess_Inputs_OutliersAsExtremeUpp" //numeric only
dialect "java"
when
    MiningSchema( $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs,  $name : name, usageType.value == "active",
                        outliers.value == "asExtremeValues",
                        $upp : highValue != null )
    TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap();
        map.put("name",utils.compactUpperCase($name));
        map.put("model",utils.context);
        map.put("upp",utils.format(utils.mapDatatype($type),$upp));
    applyTemplate("miningFieldOutlierAsExtremeUpp.drlt", utils, registry, map, theory);
end


rule "BuildQuery"
when
    // can't use assertBehaviour.EQUALITY because of poorly formed PMML Descr
    $q: QueryMarker( $name : name, $context : context)
    not QueryMarker( this != $q, name == $name, context == $context )
then
    HashMap map = new HashMap();
             map.put("model",$context);
             map.put("field",$name);
    applyTemplate("neuralOutputQuery.drlt", utils, registry, map, theory);
end

  //******************************************************************************************************************
    //    Targets
    //
    //******************************************************************************************************************


 rule "Generic_Target"
 when
    $t: Target( $field : field, targetValues.size == 0,
                 $cast : castInteger, $max : max, $min : min, $offset : rescaleConstant, $scale : rescaleFactor  )
    MiningField( name == $field, usageType.value == "predicted")
 then
     HashMap map = new HashMap();
         map.put("model",utils.context);
         map.put("field",utils.compactUpperCase($field));
         map.put("cast",$cast);
         map.put("min",$min);
         map.put("max",$max);
         map.put("offset",$offset);
         map.put("scale",$scale);
     applyTemplate("targetReshape.drlt", utils, registry, map, theory);
 end


 //******************************************************************************************************************
     //    Outputs
     //
     //******************************************************************************************************************




 rule "Output_Type"
 when
     $of : OutputField( $name : name, $dataType : dataType != null)
 then
     insert(new TypeOfField($name,$dataType));
 end


  rule "Output_Type2"
  no-loop
  when
      $of : OutputField( $name : name, dataType == null, $tgt : targetField)
      TypeOfField( name == $tgt, $dataType : dataType )
  then
      insert(new TypeOfField($name,$dataType));
  end




 rule "DeclareOutput_Neural"
 dialect "mvel"
 when
     $of : OutputField( $name : name, $tgt : targetField )
     $tf : TypeOfField( name == $name )
     $mod : OutputParentModel( field == $of, $mt : modelType )
 then
     HashMap map = new HashMap();
         map.put("context",utils.context);
         map.put("fullName",$of.displayName);
         map.put("name",utils.compactUpperCase($of.name));
         map.put("super","OutputField");
         map.put("modelType",$mt)

         map.put("type",utils.mapDatatype($tf.dataType));
     applyTemplate("ioTypeDeclare.drlt", utils, registry, map, theory);
     applyTemplate("updateIOField.drlt", utils, registry, map, theory);
 end

 rule "Output_Expose"
 when
     $of : OutputField( $name : name )
 then
      insert( new QueryMarker(utils.compactUpperCase($name),utils.context) );
 end




 rule "SimpleValueOutput"
 dialect "mvel"
 when
     $of : OutputField( $tgt : targetField, $val : value, $name : name, feature == null || feature.value == "predictedValue" )
     $tf : TypeOfField( name == $name, $type : dataType )
 then
     HashMap map = new HashMap();
         map.put("context",utils.context);
         map.put("origField",utils.compactUpperCase($tgt));
         map.put("name",utils.compactUpperCase($name));
         map.put("value",$val);
         map.put("type",$type);
     applyTemplate("aliasedOutput.drlt", utils, registry, map, theory);
 end





 rule "AddFeature_DisplayValue"
 dialect "mvel"
 when
     $of : OutputField( $tgt : targetField, $val : value, $name : name,
                        feature == "predictedDisplayValue" )
     $tf : TypeOfField( name == $name, $type : dataType )
 then
     HashMap map = new HashMap();
         map.put("context",utils.context);
         map.put("origField",utils.compactUpperCase($tgt));
         map.put("name",utils.compactUpperCase($name));
         map.put("value",$val);
         map.put("type",$type);
         map.put("feature","displayValue");
     applyTemplate("addOutputFeature.drlt", utils, registry, map, theory);
 end







  //******************************************************************************************************************
  //     NeuralNetwork
  //
  //******************************************************************************************************************





rule "setupNNs"
dialect "mvel"
when
   NeuralNetwork()
   $stat : ModelStat( neuralNetwork == false )
then
   applyTemplate("neuralBeans.drlt", null, registry, null, theory);
   applyTemplate("neuralLinkSynapses.drlt", null, registry, null, theory);
   $stat.neuralNetwork = true;
   update($stat);
end



rule "visitNeuralNetwork_context"
salience -9
when
    $net : NeuralNetwork( $name : modelName)
then
    //System.out.println("Set context, now is " + $name);
     utils.context = utils.compactUpperCase($name);
end


rule "Neural_InputFieldGeneration"
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName)
    NeuralInputs( this memberOf $info, $nis : neuralInputs )
    $ni : NeuralInput( this memberOf $nis, $fld : derivedField, $id : id)
then
    String name = utils.compactUpperCase($nn)+"_"+$id;
    $fld.setName(name);
    insertLogical($fld);

    HashMap map = new HashMap();
        map.put("name",utils.compactUpperCase(name));
        map.put("context",utils.context);
        map.put("index",$id);
    applyTemplate("neuralWireInput.drlt", utils, registry, map, theory);
end


rule "Neural_DerivedInputFieldOverride"
dialect "mvel"
when
    NeuralInput( derivedField != null, $fld : derivedField.name != null)
then
    HashMap map = new HashMap();
        map.put("name",utils.compactUpperCase($fld));
        map.put("context",utils.context);
    applyTemplate("updateIOField.drlt", utils, registry, map, theory);
end

rule "Neural_RefInputFieldOverride"
dialect "mvel"
when
    NeuralInput( derivedField != null, $fld :derivedField.fieldRef != null)
then
    HashMap map = new HashMap();
        map.put("name",utils.compactUpperCase($fld.field));
        map.put("context",utils.context);
    applyTemplate("updateIOField.drlt", utils, registry, map, theory);
end




rule "SetDefaultActivation"
salience 100
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs, $act : activationFunction )
    $nl : NeuralLayer( this memberOf $info, activationFunction == null)
then
    $nl.setActivationFunction($act);
    update($nl);
end

rule "SetDefaultThreshold"
salience 100
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs, $thold : threshold )
    $nl : NeuralLayer( this memberOf $info, threshold == null)
then
    $nl.setThreshold($thold);
    update($nl);
end


rule "SetDefaultBias"
salience 100
when
    $n : Neuron( bias == null )
then
    $n.setBias(0.0);
    update($n);
end


rule "SetDefaultNormalization"
salience 100
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs,
                    $norm : normalizationMethod != null && normalizationMethod.value != "none" )
    $nl : NeuralLayer( this memberOf $info, normalizationMethod == null)
then
    $nl.setNormalizationMethod($norm);
    update($nl);
end

rule "Synapses"
salience -10
when
    $n : Neuron( $links : cons, $index : id )
then
    HashMap map = new HashMap();
        map.put("model",utils.context);
        map.put("index",$index);
        map.put("links",$links);
    applyTemplate("neuralBuildSynapses.drlt", utils, registry, map, theory);
end


rule "Neuron"
salience -9
when
    NeuralLayer( $ns : neurons, $act : activationFunction != null, $thold : threshold != null, $norm : normalizationMethod )
    $n : Neuron( this memberOf $ns, $index : id, $bias : bias != null, $in : cons )
then
    //System.err.println("CREATE NEURON RULE FOR " + $index + " >> " + $act + "  " + $bias + "  " + $thold);

     HashMap map = new HashMap();
        map.put("model",utils.context);
        map.put("index",$index);
        map.put("actFun",$act);
        map.put("needsNormal",$norm != null );
        map.put("bias",$bias);
        map.put("thold",$thold);
        map.put("inLink",$in.size());
    applyTemplate("neuralFire.drlt", utils, registry, map, theory);
end


rule "Neural_Layer_Max_Normalization"
salience -9
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName)
    $nl : NeuralLayer( this memberOf $info, $ns : neurons,
                 normalizationMethod != null && normalizationMethod.value == "simplemax")
then
    HashMap map = new HashMap();
        map.put("model",utils.context);
        map.put("neurons",$ns);
        map.put("j",utils.nextCount());
    applyTemplate("neuralLayerMaxNormalization.drlt", utils, registry, map, theory);
end


rule "Neural_Layer_Max_SoftNormalization"
salience -9
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName)
    $nl : NeuralLayer( this memberOf $info, $ns : neurons,
                 normalizationMethod != null && normalizationMethod.value == "softmax")
then
    HashMap map = new HashMap();
        map.put("model",utils.context);
        map.put("neurons",$ns);
        map.put("j",utils.nextCount());
    applyTemplate("neuralLayerSoftMaxNormalization.drlt", utils, registry, map, theory);
end



rule "Neural_Output_Field_Def"
salience -9
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName)
    NeuralOutputs( this memberOf $info, $outs : neuralOutputs )
    $out : NeuralOutput( $id : outputNeuron, $fld : derivedField )
then
    String name = utils.compactUpperCase($nn)+"_"+$id;

    HashMap map = new HashMap();
        map.put("model",utils.context);
        map.put("name",name);
        map.put("index",$id);
    applyTemplate("neuralOutputField.drlt", utils, registry, map, theory);

    map = new HashMap();
        map.put("context",utils.context);
        map.put("fullName",name);
        map.put("name",name);
        map.put("super",null);
        map.put("type",utils.mapDatatype(DATATYPE.DOUBLE));
        map.put("cyclic",false);
        map.put("categorical",false);
        map.put("continuous",true);
        map.put("ordinal",false);
        map.put("modelType",null);
    applyTemplate("ioTypeDeclare.drlt", utils, registry, map, theory);
    applyTemplate("updateIOField.drlt", utils, registry, map, theory);
end

/*
 rule "Neural_Output_Expose"
 salience -9
 when
     NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName)
     NeuralOutputs( this memberOf $info, $outs : neuralOutputs )
     $out : NeuralOutput( $id : outputNeuron, $fld : derivedField )
 then
     String name = utils.compactUpperCase($nn)+"_"+$id;
     insert( new QueryMarker(name,utils.context) );

     HashMap map = new HashMap();
         map.put("name",name);
     applyTemplate("confirm.drlt", utils, registry, map, theory);
 end
*/



rule "Neural_Output_Invert_NormContinuous"
salience -15
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName, functionName.value == "regression")
    NeuralOutputs( this memberOf $info, $outs : neuralOutputs )
    $out : NeuralOutput( $id : outputNeuron, $fld : derivedField )
    $df : DerivedField( $norm : normContinuous != null ) from $fld
    NormContinuous( $mmt : mapMissingTo, $field : field, $outl : outliers, $ls : linearNorms ) from $norm
then

    //insert( new QueryMarker(utils.compactUpperCase($field),utils.context) );

    NormContinuous invertedNC = new NormContinuous();
        invertedNC.setMapMissingTo($mmt);
        invertedNC.setField(utils.compactUpperCase($nn)+"_"+$id);
        invertedNC.setOutliers($outl);
        for (int j = 0; j < $ls.size(); j++) {
            LinearNorm orig = (LinearNorm) $ls.get(j);
            LinearNorm inv = new LinearNorm();
                inv.setNorm(orig.getOrig());
                inv.setOrig(orig.getNorm());
            invertedNC.getLinearNorms().add(inv);
        }

//    HashMap map = new HashMap();
//        map.put("name",utils.compactUpperCase($field));
//    applyTemplate("confirm.drlt", utils, registry, map, theory);

    $df.setName($field);
    $df.setNormContinuous(invertedNC);

    insertLogical($df);
    insertLogical(invertedNC);
end




rule "Neural_Output_Invert_NormDiscrete_asPredicate"
salience -15
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName, functionName.value == "classification")
    NeuralOutputs( this memberOf $info, $outs : neuralOutputs )
    $out : NeuralOutput( $id : outputNeuron, $fld : derivedField )
    $df : DerivedField( $norm : normDiscrete != null) from $fld
    NormDiscrete( $field : field, $val : value ) from $norm
    TypeOfField( name == $field, $type : dataType )
then
    HashMap map = new HashMap();
        map.put("model",utils.context);
        map.put("field",utils.compactUpperCase($field));
        map.put("label",$val);
        map.put("target",utils.format($type,utils.compactUpperCase($val)));
    applyTemplate("neuralOutputQueryPredicate.drlt", utils, registry, map, theory);

    map = new HashMap();
        map.put("name",utils.compactUpperCase($field));
        map.put("model",utils.context);
        map.put("target",utils.format($type,$val));
        map.put("origField",utils.compactUpperCase($nn)+"_"+$id);
    applyTemplate("predicateField.drlt", utils, registry, map, theory);
end



rule "Neural_Output_Invert_FieldRef"
salience -15
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName)
    NeuralOutputs( this memberOf $info, $outs : neuralOutputs )
    $out : NeuralOutput( $id : outputNeuron, $fld : derivedField )
    $df : DerivedField( $ref : fieldRef != null ) from $fld
    FieldRef( $field : field ) from $ref
then

    //insert( new QueryMarker(utils.compactUpperCase($field),utils.context) );

    $df.setName($field);
    $ref.setField(utils.compactUpperCase($nn)+"_"+$id);

    insertLogical($ref);
    insertLogical($fld);
end






rule "Clean_WM_Pre"
salience -18
dialect "mvel"
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName)
    $ms : MiningSchema( this memberOf $info, $fields : miningFields )
    $fld : MiningField( usageType.value != null &&
                 (usageType.value == "predicted" || usageType.value == "supplementary")
               ) from $fields
then
    $fields.remove($fld);
end


rule "Clean_WM"
salience -19
dialect "mvel"
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName)
    $ms : MiningSchema( this memberOf $info, $fields : miningFields )
then
    HashMap map = new HashMap();
        map.put("model",utils.context);
        map.put("fields",$fields);
    applyTemplate("neuralClean.drlt", utils, registry, map, theory);
end



rule "Neural_Cleanup"
salience -20
when
    $nn : NeuralNetwork( )
then
    utils.context = null;
    retract($nn);
end


//**********************************************************************************************************
//
//  INTEGRITY RULES
//
//**********************************************************************************************************


rule "checkDataDictionary"
when
    DataDictionary( $exp : numberOfFields != null, $act : dataFields.size != $exp )
then
   System.err.println("TODO WARNING : Expected number of fields in datadictionary different from actual : " + $exp + " vs " + $act);
end
