<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="../" xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Rule</title>

  <figure>
    <title>rule</title>

    <mediaobject>
      <imageobject>
        <imagedata align="center"
                   fileref="images/Chapter-Rule_Language/rule.png"
                   format="PNG" role=""></imagedata>
      </imageobject>
    </mediaobject>
  </figure>

  <para>A rule specifies that <emphasis>when</emphasis> a particular set of
  conditions occur, specified in the Left Hand Side (LHS),
  <emphasis>then</emphasis> do what queryis specified as a list of actions in
  the Right Hand Side (RHS). A common question from users is "Why use when
  instead of if?" "When" was chosen over "if" because "if" is normally part of
  a procedural execution flow, where, at a specific point in time, a condition
  is to be checked. In contrast, "when" indicates that the condition
  evaluation is not tied to a specific evaluation sequence or point in time,
  but that it happens continually, at any time during the life time of the
  engine; whenever the condition is met, the actions are executed.</para>

  <para>A rule must have a name, unique within its rule package. If you define
  a rule twice in the same DRL it produces an error while loading. If you add
  a DRL that includes a rule name already in the package, it replaces the
  previous rule. If a rule name is to have spaces, then it will need to be
  enclosed in double quotes (it is best to always use double quotes).</para>

  <para>Attributes - described below - are optional. They are best written one
  per line.</para>

  <para>The LHS of the rule follows the <literal>when</literal> keyword
  (ideally on a new line), similarly the RHS follows the
  <literal>then</literal> keyword (again, ideally on a newline). The rule is
  terminated by the keyword <literal>end</literal>. Rules cannot be
  nested.</para>

  <example>
    <title>Rule Syntax Overview</title>

    <programlisting>rule "&lt;name&gt;"
    &lt;attribute&gt;*
when
    &lt;conditional element&gt;*
then
    &lt;action&gt;*
end</programlisting>
  </example>

  <example>
    <title>A simple rule</title>

    <programlisting>rule "Approve if not rejected"
  salience -100 
  agenda-group "approval"
    when
        not Rejection() 
        p : Policy(approved == false, policyState:status)
        exists Driver(age &gt; 25)
        Process(status == policyState)
    then
        log("APPROVED: due to no objections."); 
        p.setApproved(true);
end</programlisting>
  </example>

  <section>
    <title>Rule Attributes</title>

    <para>Rule attributes provide a declarative way to influence the behavior
    of the rule. Some are quite simple, while others are part of complex
    subsystems such as ruleflow. To get the most from Drools you should make
    sure you have a proper understanding of each attribute.</para>

    <figure>
      <title>rule attributes</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center"
                     fileref="images/Chapter-Rule_Language/rule_attributes.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <variablelist>
      <varlistentry>
        <term><literal>no-loop</literal></term>

        <listitem>
          <para>default value: <literal>false</literal></para>

          <para>type: Boolean</para>

          <para>When a rule's consequence modifies a fact it may cause the
          rule to activate again, causing an infinite loop. Setting no-loop to
          true will skip the creation of another Activation for the rule with
          the current set of facts.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>ruleflow-group</literal></term>

        <listitem>
          <para>default value: N/A</para>

          <para>type: String</para>

          <para>Ruleflow is a Drools feature that lets you exercise control
          over the firing of rules. Rules that are assembled by the same
          ruleflow-group identifier fire only when their group is
          active.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>lock-on-active</literal></term>

        <listitem>
          <para>default value: <literal>false</literal></para>

          <para>type: Boolean</para>

          <para>Whenever a ruleflow-group becomes active or an agenda-group
          receives the focus, any rule within that group that has
          lock-on-active set to true will not be activated any more;
          irrespective of the origin of the update, the activation of a
          matching rule is discarded. This is a stronger version of no-loop,
          because the change could now be caused not only by the rule itself.
          It's ideal for calculation rules where you have a number of rules
          that modify a fact and you don't want any rule re-matching and
          firing again. Only when the ruleflow-group is no longer active or
          the agenda-group loses the focus those rules with lock-on-active set
          to true become eligible again for their activations to be placed
          onto the agenda.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>salience</literal></term>

        <listitem>
          <para>default value: <literal>0</literal></para>

          <para>type: integer</para>

          <para>Each rule has an integer salience attribute which defaults to
          zero and can be negative or positive. Salience is a form of priority
          where rules with higher salience values are given higher priority
          when ordered in the Activation queue.</para>

          <para>Drools also supports dynamic salience where you can use an
          expression involving bound variables.</para>

          <example>
            <title>Dynamic Salience</title>

            <programlisting>rule "Fire in rank order 1,2,.."
        salience( -$rank )
    when
        Element( $rank : rank,... )
    then
        ...
end</programlisting>
          </example>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>agenda-group</literal></term>

        <listitem>
          <para>default value: MAIN</para>

          <para>type: String</para>

          <para>Agenda groups allow the user to partition the Agenda providing
          more execution control. Only rules in the agenda group that has
          acquired the focus are allowed to fire.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>auto-focus</literal></term>

        <listitem>
          <para>default value: <literal>false</literal></para>

          <para>type: Boolean</para>

          <para>When a rule is activated where the <code>auto-focus</code>
          value is true and the rule's agenda group does not have focus yet,
          then it is given focus, allowing the rule to potentially
          fire.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>activation-group</literal></term>

        <listitem>
          <para>default value: N/A</para>

          <para>type: String</para>

          <para>Rules that belong to the same activation-group, identified by
          this attribute's string value, will only fire exclusively. More
          precisely, the first rule in an activation-group to fire will
          cancel all pending activations of all rules in the group, i.e., stop
          them from firing.</para>

          <para>Note: This used to be called Xor group, but technically it's
          not quite an Xor. You may still hear people mention Xor group; just
          swap that term in your mind with activation-group.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>dialect</literal></term>

        <listitem>
          <para>default value: as specified by the package</para>

          <para>type: String</para>

          <para>possible values: "java" or "mvel"</para>

          <para>The dialect species the language to be used for any code
          expressions in the LHS or the RHS code block. Currently two dialects
          are available, Java and MVEL. While the dialect can be specified at
          the package level, this attribute allows the package definition to
          be overridden for a rule.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>date-effective</literal></term>

        <listitem>
          <para>default value: N/A</para>

          <para>type: String, containing a date and time definition</para>

          <para>A rule can only activate if the current date and time is after
          date-effective attribute.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>date-expires</literal></term>

        <listitem>
          <para>default value: N/A</para>

          <para>type: String, containing a date and time definition</para>

          <para>A rule cannot activate if the current date and time is after
          the date-expires attribute.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>duration</literal></term>

        <listitem>
          <para>default value: no default value</para>

          <para>type: long</para>

          <para>The duration dictates that the rule will fire after a
          specified duration, if it is still true.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <example>
      <title>Some attribute examples</title>

      <programlisting>rule "my rule"
  salience 42
  agenda-group "number 1"
    when ...</programlisting>
    </example>
  </section>

  <section>
    <title>Timers and Calendars</title>

    <para>Rules now support both interval and cron based timers, which replace
    the now deprecated duration attribute.</para>

    <example>
      <title>Sample timer attribute uses</title>

      <programlisting language="java">timer ( int: &lt;initial delay&gt; &lt;repeat interval&gt;? )
timer ( int: 30s )
timer ( int: 30s 5m )

timer ( cron: &lt;cron expression&gt; )
timer ( cron:* 0/15 * * * ? )</programlisting>
    </example>

    <para>Interval (indicated by "int:") timers follow the semantics of
    java.util.Timer objects, with an initial delay and an optional repeat
    interval. Cron (indicated by "cron:") timers follow standard Unix cron
    expressions:</para>

    <example>
      <title>A Cron Example</title>

      <programlisting language="java">rule "Send SMS every 15 minutes"
    timer (cron:* 0/15 * * * ?)
when
    $a : Alarm( on == true )
then
    channels[ "sms" ].insert( new Sms( $a.mobileNumber, "The alarm is still on" );
end</programlisting>
    </example>

    <para>A rule controlled by a timer becomes active when it matches, and
    once for each individual match. Its consequence is executed
    repeatedly, according to the timer's settings. This stops as soon
    as the condition doesn't match any more.</para>

    <para>Consequences are executed even after control returns from a call
    to fireUntilHalt. Moreover, the Engine remains reactive to any
    changes made to the Working Memory. For instance, removing a fact
    that was involved in triggering the timer rule's execution causes
    the repeated execution to terminate, or inserting a fact so that
    some rule matches will cause that rule to fire. But the Engine is
    not continually active, only after a rule fires, for whatever
    reason. Thus, reactions to an insertion done asynchronously will
    not happen until the next execution of a timer-controlled rule.
    Disposing a session puts an end to all timer activity.</para>

    <para>For what regards interval timers it is also possible to define both the delay
    and interval as an expression instead of a fixed value. To do that it is necessary to
    use an expression timer (indicated by "expr:") as in the following example:</para>

    <example>
      <title>An Expression Timer Example</title>

      <programlisting language="java">declare Bean
    delay   : String = "30s"
    period  : long = 60000
end

rule "Expression timer"
    timer( expr: $d, $p )
when
    Bean( $d : delay, $p : period )
then
end</programlisting>
    </example>

    <para>The expressions, $d and $p in this case, can use any variable defined in the
    pattern matching part of the rule and can be any String that can be parsed in a time
    duration or any numeric value that will be internally converted in a long representing
    a duration expressed in milliseconds.</para>

    <para>Both interval and expression timers can have 3 optional parameters named
    "start", "end" and "repeat-limit". When one or more of these parameters are used the first
    part of the timer definition must be followed by a semicolon ';' and the parameters have
    to be separated by a comma ',' as in the following example:</para>

    <example>
      <title>An Interval Timer with a start and an end</title>

      <programlisting language="java">timer (int: 30s 10s; start=3-JAN-2010, end=5-JAN-2010)</programlisting>
    </example>

    <para>The value for start and end parameters can be a Date, a String representing
    a Date or a long, or more in general any Number, that will be transformed in a Java Date
    applying the following conversion:</para>

    <programlisting language="java">new Date( ((Number) n).longValue() )</programlisting>

    <para>Conversely the repeat-limit can be only an integer and it defines the maximum
    number of repetitions allowed by the timer. If both the end and the repeat-limit parameters
    are set the timer will stop when the first of the two will be matched.</para>

    <para>The using of the start parameter implies the definition of a phase for the timer,
    where the beginning of the phase is given by the start itself plus the eventual delay.
    In other words in this case the timed rule will then be scheduled at times:</para>

    <programlisting language="java">start + delay + n*period</programlisting>

    <para>for up to repeat-limit times and no later than the end timestamp (whichever first).
    For instance the rule having the following interval timer</para>

    <programlisting language="java">timer ( int: 30s 1m; start="3-JAN-2010" )</programlisting>

    <para>will be scheduled at the 30th second of every minute after the midnight of the
    3-JAN-2010. This also means that if for example you turn the system on at midnight of
    the 3-FEB-2010 it won't be scheduled immediately but will preserve the phase defined by
    the timer and so it will be scheduled for the first time 30 seconds after the midnight.
    If for some reason the system is paused (e.g. the session is serialized and then deserialized
    after a while) the rule will be scheduled only once to recover from missing activations
    (regardless of how many activations we missed) and subsequently it will be scheduled
    again in phase with the timer.</para>

    <para>Calendars are used to control when rules can fire. The Calendar API
    is modelled on <link
    xlink:href="http://www.quartz-scheduler.org/">Quartz</link>:</para>

    <example>
      <title>Adapting a Quartz Calendar</title>

      <programlisting language="java">Calendar weekDayCal = QuartzHelper.quartzCalendarAdapter(org.quartz.Calendar quartzCal)</programlisting>
    </example>

    <para>Calendars are registered with the StatefulKnowledgeSession:</para>

    <example>
      <title>Registering a Calendar</title>

      <programlisting language="java">ksession.getCalendars().set( "weekday", weekDayCal );</programlisting>
    </example>

    <para>They can be used in conjunction with normal rules and rules
    including timers. The rule attribute "calendars" may contain one or more
    comma-separated calendar names written as string literals.</para>

    <example>
      <title>Using Calendars and Timers together</title>

      <programlisting language="java">rule "weekdays are high priority"
   calendars "weekday"
   timer (int:0 1h)
when 
    Alarm()
then
    send( "priority high - we have an alarm” );
end 

rule "weekend are low priority"
   calendars "weekend"
   timer (int:0 4h)
when 
    Alarm()
then
    send( "priority low - we have an alarm” );
end</programlisting>
    </example>
  </section>

  <section>
    <title>Left Hand Side (when) syntax</title>

    <section>
      <title>What is the Left Hand Side?</title>

      <para>The Left Hand Side (LHS) is a common name for the conditional part
      of the rule. It consists of zero or more Conditional Elements. If the
      LHS is empty, it will be considered as a condition element that is
      always true and it will be activated once, when a new WorkingMemory
      session is created.</para>

      <figure>
        <title>Left Hand Side</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="images/Chapter-Rule_Language/lhs.png"
                       format="PNG" role=""></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <example>
        <title>Rule without a Conditional Element</title>

        <programlisting>rule "no CEs"
when
    // empty
then
    ... // actions (executed once)
end

// The above rule is internally rewritten as:

rule "eval(true)"
when
    eval( true )
then
    ... // actions (executed once)
end</programlisting>
      </example>

      <para>Conditional elements work on one or more
      <emphasis>patterns</emphasis> (which are described below). The most
      common conditional element is "<literal>and"</literal>. Therefore it is
      implicit when you have multiple patterns in the LHS of a rule that are
      not connected in any way:</para>

      <example>
        <title>Implicit and</title>

        <programlisting>rule "2 unconnected patterns"
when
    Pattern1()
    Pattern2()
then
    ... // actions
end

// The above rule is internally rewritten as:

rule "2 and connected patterns"
when
    Pattern1()
    and Pattern2()
then
    ... // actions
end</programlisting>
      </example>

      <note>
        <para>An "<literal>and"</literal> cannot have a leading declaration
        binding (unlike for example <literal>or</literal>). This is obvious,
        since a declaration can only reference a single fact at a time, and
        when the "<literal>and"</literal> is satisfied it matches both facts -
        so which fact would the declaration bind to?</para>

        <programlisting>// Compile error
$person : (Person( name == "Romeo" ) and Person( name == "Juliet"))</programlisting>
      </note>
    </section>

    <section>
      <title>Pattern (conditional element)</title>

      <section>
        <title>What is a pattern?</title>

        <para>A pattern element is the most important Conditional Element. It
        can potentially match on each fact that is inserted in the working
        memory.</para>

        <para>A pattern contains of zero or more constraints and has an
        optional pattern binding. The railroad diagram below shows the syntax
        for this.</para>

        <figure>
          <title>Pattern</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="images/Chapter-Rule_Language/pattern.png"
                         format="PNG" role=""></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>In its simplest form, with no constraints, a pattern matches
        against a fact of the given type. In the following case the type is
        <code>Cheese</code>, which means that the pattern will match against
        all <code>Person</code> objects in the Working Memory:</para>

        <programlisting>Person()</programlisting>

        <para>The type need not be the actual class of some fact object.
        Patterns may refer to superclasses or even interfaces, thereby
        potentially matching facts from many different classes.</para>

        <programlisting>Object() // matches all objects in the working memory</programlisting>

        <para>Inside of the pattern parenthesis is where all the action
        happens: it defines the constraints for that pattern. For example,
        with a age related constraint:</para>

        <programlisting>Person( age == 100 )</programlisting>

        <note>
          <para>For backwards compatibility reasons it's allowed to suffix
          patterns with the <literal>;</literal> character. But it is not
          recommended to do that.</para>
        </note>
      </section>

      <section>
        <title>Pattern binding</title>

        <para>For referring to the matched object, use a pattern binding
        variable such as <code>$p</code>.</para>

        <example>
          <title>Pattern with a binding variable</title>

          <programlisting>rule ...
when
    $p : Person()
then
    System.out.println( "Person " + $p );
end</programlisting>
        </example>

        <para>The prefixed dollar symbol (<literal>$</literal>) is just a
        convention; it can be useful in complex rules where it helps to easily
        differentiate between variables and fields, but it is not
        mandatory.</para>
      </section>
    </section>

    <section>
      <title>Constraint (part of a pattern)</title>

      <section>
        <title>What is a constraint?</title>

        <para>A constraint is an expression that returns
        <literal>true</literal> or <literal>false</literal>. This example has
        a constraint that states <emphasis>5 is smaller than
        6</emphasis>:</para>

        <programlisting>Person( 5 &lt; 6 )  // just an example, as constraints like this would be useless in a real pattern</programlisting>

        <para>In essence, it's a Java expression with some enhancements (such
        as property access) and a few differences (such as
        <literal>equals()</literal> semantics for <literal>==</literal>).
        Let's take a deeper look.</para>
      </section>

      <section>
        <title>Property access on Java Beans (POJO's)</title>

        <para>Any bean property can be used directly. A bean property is
        exposed using a standard Java bean getter: a method
        <literal>getMyProperty()</literal> (or
        <literal>isMyProperty()</literal> for a primitive boolean) which takes
        no arguments and return something. For example: the age property is
        written as <literal>age</literal> in DRL instead of the getter
        <literal>getAge()</literal>:</para>

        <programlisting>Person( age == 50 )

// this is the same as:
Person( getAge() == 50 )</programlisting>

        <para>Drools uses the standard JDK <literal>Introspector</literal>
        class to do this mapping, so it follows the standard Java bean
        specification.</para>

        <note>
          <para>We recommend using property access (<literal>age</literal>)
          over using getters explicitly (<literal>getAge()</literal>) because
          of performance enhancements through field indexing.</para>
        </note>

        <warning>
          <para>Property accessors must not change the state of the object in
          a way that may effect the rules. Remember that the rule engine
          effectively caches the results of its matching in between
          invocations to make it faster.</para>

          <programlisting>public int getAge() {
    age++; // Do NOT do this
    return age;
}</programlisting>

          <programlisting>public int getAge() {
    Date now = DateUtil.now(); // Do NOT do this
    return DateUtil.differenceInYears(now, birthday);
}</programlisting>

          <para>To solve this latter case, insert a fact that wraps the
          current date into working memory and update that fact between
          <literal>fireAllRules</literal> as needed.</para>
        </warning>

        <note>
          <para>The following fallback applies: if the getter of a property
          cannot be found, the compiler will resort to using the property name
          as a method name and without arguments:</para>

          <programlisting>Person( age == 50 )

// If Person.getAge() does not exists, this falls back to:
Person( age() == 50 )</programlisting>
        </note>

        <para>Nested property access is also supported:</para>

        <programlisting>Person( address.houseNumber == 50 )

// this is the same as:
Person( getAddress().getHouseNumber() == 50 )</programlisting>

        <para>Nested properties are also indexed.</para>

        <warning>
          <para>In a stateful session, care should be taken when using nested
          accessors as the Working Memory is not aware of any of the nested
          values, and does not know when they change. Either consider them
          immutable while any of their parent references are inserted into the
          Working Memory. Or, instead, if you wish to modify a nested value
          you should mark all of the outer facts as updated. In the above
          example, when the <literal>houseNumber</literal> changes, any
          <literal>Person</literal> with that <literal>Address</literal> must
          be marked as updated.</para>
        </warning>
      </section>

      <section>
        <title>Java expression</title>

        <para>You can use any Java expression that returns a
        <literal>boolean</literal> as a constraint inside the parentheses of a
        pattern. Java expressions can be mixed with other expression
        enhancements, such as property access:</para>

        <programlisting>Person( age == 50 )</programlisting>

        <para>It is possible to change the evaluation priority by using
        parentheses, as in any logic or mathematical expression:</para>

        <programlisting>Person( age &gt; 100 &amp;&amp; ( age % 10 == 0 ) )</programlisting>

        <para>It is possible to reuse Java methods:</para>

        <programlisting>Person( Math.round( weight / ( height * height ) ) &lt; 25.0 )</programlisting>

        <warning>
          <para>As for property accessors, methods must not change the state
          of the object in a way that may affect the rules. Any method
          executed on a fact in the LHS should be a <emphasis>read
          only</emphasis> method.</para>

          <programlisting>Person( incrementAndGetAge() == 10 ) // Do NOT do this</programlisting>
        </warning>

        <warning>
          <para>The state of a fact should not change between rule invocations
          (unless those facts are marked as updated to the working memory on
          every change):</para>

          <programlisting>Person( System.currentTimeMillis() % 1000 == 0 ) // Do NOT do this</programlisting>
        </warning>

        <para>Normal Java operator precedence applies, see the operator
        precedence list below.</para>

        <important>
          <para>All operators have normal Java semantics except for
          <literal>==</literal> and <literal>!=</literal>.</para>

          <para>The <literal>==</literal> operator has null-safe
          <literal>equals()</literal> semantics:</para>

          <programlisting>// Similar to: java.util.Objects.equals(person.getFirstName(), "John")
// so (because "John" is not null) similar to:
// "John".equals(person.getFirstName())
Person( firstName == "John" )</programlisting>

          <para>The <literal>!=</literal> operator has null-safe
          <literal>!equals()</literal> semantics:</para>

          <programlisting>// Similar to: !java.util.Objects.equals(person.getFirstName(), "John")
Person( firstName != "John" )</programlisting>
        </important>

        <para>Type coercion is always attempted if the field and the value are
        of different types; exceptions will be thrown if a bad coercion is
        attempted. For instance, if "ten" is provided as a string in a numeric
        evaluator, an exception is thrown, whereas "10" would coerce to a
        numeric 10. Coercion is always in favor of the field type and not the
        value type:</para>

        <programlisting>Person( age == "10" ) // "10" is coerced to 10</programlisting>
      </section>

      <section>
        <title>Comma separated AND</title>

        <para>The comma character ('<literal>,</literal>') is used to separate
        constraint groups. It has implicit <emphasis>AND</emphasis> connective
        semantics.</para>

        <programlisting>// Person is at least 50 and weighs at least 80 kg
Person( age &gt; 50, weight &gt; 80 )</programlisting>

        <programlisting>// Person is at least 50, weighs at least 80 kg and is taller than 2 meter.
Person( age &gt; 50, weight &gt; 80, height &gt; 2 )</programlisting>

        <note>
          <para>Although the <literal>&amp;&amp;</literal> and
          <literal>,</literal> operators have the same semantics, they are
          resolved with different priorities: The
          <literal>&amp;&amp;</literal> operator precedes the
          <literal>||</literal> operator. Both the
          <literal>&amp;&amp;</literal> and <literal>||</literal> operator
          precede the <literal>,</literal> operator. See the operator
          precedence list below.</para>

          <para>The comma operator should be preferred at the top level
          constraint, as it makes constraints easier to read and the engine
          will often be able to optimize them better.</para>
        </note>

        <para>The comma (<literal>,</literal>) operator cannot be embedded in
        a composite constraint expression, such as parentheses:</para>

        <programlisting>Person( ( age &gt; 50, weight &gt; 80 ) || height &gt; 2 ) // Do NOT do this: compile error

// Use this instead
Person( ( age &gt; 50 &amp;&amp; weight &gt; 80 ) || height &gt; 2 )</programlisting>
      </section>

      <section>
        <title>Binding variables</title>

        <para>A property can be bound to a variable:</para>

        <programlisting>// 2 persons of the same age
Person( $firstAge : age ) // binding
Person( age == $firstAge ) // constraint expression</programlisting>

        <para>The prefixed dollar symbol (<literal>$</literal>) is just a
        convention; it can be useful in complex rules where it helps to easily
        differentiate between variables and fields.</para>

        <note>
          <para>For backwards compatibility reasons, It's allowed (but not
          recommended) to mix a constraint binding and constraint expressions
          as such:</para>

          <programlisting>// Not recommended
Person( $age : age * 2 &lt; 100 )</programlisting>

          <programlisting>// Recommended (separates bindings and constraint expressions)
Person( age * 2 &lt; 100, $age : age )</programlisting>
        </note>

        <para>Bound variable restrictions using the operator
        <literal>==</literal> provide for very fast execution as it use hash
        indexing to improve performance.</para>
      </section>

      <section>
        <title>Unification</title>

        <para>Drools does not allow bindings to the same declaration. However
        this is an important aspect to derivation query unification. While
        positional arguments are always processed with unification a special
        unification symbol, ':=', was introduced for named arguments named
        arguments. The following "unifies" the age argument across two
        people.</para>

        <programlisting>Person( $age := age ) 
Person( $age := age) </programlisting>

        <para>In essence unification will declare a binding for the first
        occurrence and constrain to the same value of the bound field for
        sequence occurrences.</para>
      </section>

      <section>
        <title>Special literal support</title>

        <para>Besides normal Java literals (including Java 5 enums), this
        literal is also supported:</para>

        <section>
          <title>Date literal</title>

          <para>The date format <literal>dd-mmm-yyyy</literal> is supported by
          default. You can customize this by providing an alternative date
          format mask as the System property named
          <code>drools.dateformat</code>. If more control is required, use a
          restriction.</para>

          <example>
            <title>Date Literal Restriction</title>

            <programlisting>Cheese( bestBefore &lt; "27-Oct-2009" )</programlisting>
          </example>
        </section>
      </section>

      <section>
        <title>List and Map access</title>

        <para>It's possible to directly access a <literal>List</literal> value
        by index:</para>

        <programlisting>// Same as childList(0).getAge() == 18
Person( childList[0].age == 18 )</programlisting>

        <para>It's also possible to directly access a <literal>Map</literal>
        value by key:</para>

        <programlisting>// Same as credentialMap.get("jsmith").isValid()
Person( credentialMap["jsmith"].valid )</programlisting>
      </section>

      <section>
        <title>Abbreviated combined relation condition</title>

        <para>This allows you to place more than one restriction on a field
        using the restriction connectives <literal>&amp;&amp;</literal> or
        <literal>||</literal>. Grouping via parentheses is permitted,
        resulting in a recursive syntax pattern.</para>

        <figure>
          <title>Abbreviated combined relation condition</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="images/Chapter-Rule_Language/abbreviatedCombinedRelationCondition.png"
                         format="PNG" role=""></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <figure>
          <title>Abbreviated combined relation condition with
          parentheses</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="images/Chapter-Rule_Language/abbreviatedCombinedRelationConditionGroup.png"
                         format="PNG" role=""></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <programlisting>// Simple abbreviated combined relation condition using a single &amp;&amp;
Person( age &gt; 30 &amp;&amp; &lt; 40 )</programlisting>

        <programlisting>// Complex abbreviated combined relation using groupings
Person( age ( (&gt; 30 &amp;&amp; &lt; 40) ||
              (&gt; 20 &amp;&amp; &lt; 25) ) )</programlisting>

        <programlisting>// Mixing abbreviated combined relation with constraint connectives
Person( age &gt; 30 &amp;&amp; &lt; 40 || location == "london" )</programlisting>
      </section>

      <section>
        <title>Special DRL operators</title>

        <figure>
          <title>Operators</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="images/Chapter-Rule_Language/operator.png"
                         format="PNG"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Coercion to the correct value for the evaluator and the field
        will be attempted.</para>

        <section>
          <title>The operators <literal>&lt;</literal>
          <literal>&lt;=</literal> <literal>&gt;</literal>
          <literal>&gt;=</literal></title>

          <para>These operators can be used on properties with natural
          ordering. For example, for Date fields, <literal>&lt;</literal>
          means <emphasis>before</emphasis>, for <literal>String</literal>
          fields, it means alphabetically lower.</para>

          <programlisting>Person( firstName &lt; $otherFirstName )</programlisting>

          <programlisting>Person( birthDate &lt; $otherBirthDate )</programlisting>

          <para>Only applies on <literal>Comparable</literal>
          properties.</para>
        </section>

        <section>
          <title>The operator <literal>matches</literal></title>

          <para>Matches a field against any valid Java <indexterm>
              <primary>regular expression</primary>
            </indexterm>Regular Expression. Typically that regexp is a string
          literal, but variables that resolve to a valid regexp are also
          allowed.</para>

          <example>
            <title>Regular Expression Constraint</title>

            <programlisting>Cheese( type matches "(Buffalo)?\\S*Mozarella" )</programlisting>
          </example>

          <note>
            <para>Like in Java, regular expressions written as string literals
            <emphasis>need to escape '<literal>\</literal></emphasis>'.</para>
          </note>

          <para>Only applies on <literal>String</literal> properties.
          Using <literal>matches</literal> against a <literal>null</literal> value
          always evaluates to false.</para>
        </section>

        <section>
          <title>The operator <literal>not matches</literal></title>

          <para>The operator returns true if the String does not match the
          regular expression. The same rules apply as for the
          <literal>matches</literal> operator. Example:</para>

          <example>
            <title>Regular Expression Constraint</title>

            <programlisting>Cheese( type not matches "(Buffulo)?\\S*Mozarella" )</programlisting>
          </example>

          <para>Only applies on <literal>String</literal> properties.
          Using <literal>not matches</literal> against a <literal>null</literal> value
          always evaluates to true.</para>
        </section>

        <section>
          <title>The operator <literal>contains</literal></title>

          <para>The operator <literal>contains</literal> is used to check
          whether a field that is a <indexterm>
              <primary>Collection</primary>
            </indexterm>Collection or elements contains the specified
          value.</para>

          <example>
            <title>Contains with Collections</title>

            <programlisting>CheeseCounter( cheeses contains "stilton" ) // contains with a String literal
CheeseCounter( cheeses contains $var ) // contains with a variable</programlisting>
          </example>

          <para>Only applies on <literal>Collection</literal>
          properties.</para>
        </section>

        <section>
          <title>The operator <literal>not contains</literal></title>

          <para>The operator <literal>not contains</literal> is used to check
          whether a field that is a <indexterm>
              <primary>Collection</primary>
            </indexterm>Collection or elements does <emphasis>not</emphasis>
          contain the specified value.</para>

          <example>
            <title>Literal Constraint with Collections</title>

            <programlisting>CheeseCounter( cheeses not contains "cheddar" ) // not contains with a String literal
CheeseCounter( cheeses not contains $var ) // not contains with a variable</programlisting>
          </example>

          <para>Only applies on <literal>Collection</literal>
          properties.</para>

          <blockquote>
            <note>
              <para>For backward compatibility, the
              <literal>excludes</literal> operator is supported as a synonym
              for <literal>not contains</literal>.</para>
            </note>
          </blockquote>
        </section>

        <section>
          <title>The operator <literal>memberOf</literal></title>

          <para>The operator <literal>memberOf</literal> is used to check
          whether a field is a member of a collection or elements; that
          collection must be a variable.</para>

          <example>
            <title>Literal Constraint with Collections</title>

            <programlisting>CheeseCounter( cheese memberOf $matureCheeses )</programlisting>
          </example>
        </section>

        <section>
          <title>The operator <literal>not memberOf</literal></title>

          <para>The operator <literal>not memberOf</literal> is used to check
          whether a field is not a member of a collection or elements; that
          collection must be a variable.</para>

          <example>
            <title>Literal Constraint with Collections</title>

            <programlisting>CheeseCounter( cheese not memberOf $matureCheeses )</programlisting>
          </example>
        </section>

        <section>
          <title>The operator <literal>soundslike</literal></title>

          <para>This operator is similar to <literal>matches</literal>, but it
          checks whether a word has almost the same sound (using English
          pronunciation) as the given value. This is based on the Soundex
          algorithm (see
          <code>http://en.wikipedia.org/wiki/Soundex</code>).</para>

          <example>
            <title>Test with soundslike</title>

            <programlisting>// match cheese "fubar" or "foobar"
Cheese( name soundslike 'foobar' )</programlisting>
          </example>
        </section>

        <section>
          <title>The operator <literal>str</literal></title>

          <para>This operator <literal>str</literal> is used to check whether
          a field that is a <literal>String</literal> starts with or ends with
          a certain value. It can also be used to check the length of the
          String.</para>

          <programlisting>Message( routingValue str[startsWith] "R1" )</programlisting>

          <programlisting>Message( routingValue str[endsWith] "R2" )</programlisting>

          <programlisting>Message( routingValue str[length] 17 )</programlisting>
        </section>

        <section>
          <title>The operators <literal>in</literal> and <literal>not
          in</literal> (compound value restriction)</title>

          <para>The compound value restriction is used where there is more
          than one possible value to match. Currently only the
          <literal>in</literal> and <literal>not in</literal> evaluators
          support this. The second operand of this operator must be a
          comma-separated list of values, enclosed in parentheses. Values may
          be given as variables, literals, return values or qualified
          identifiers. Both evaluators are actually <emphasis>syntactic
          sugar</emphasis>, internally rewritten as a list of multiple
          restrictions using the operators <literal>!=</literal> and
          <literal>==</literal>.</para>

          <figure>
            <title>compoundValueRestriction</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center"
                           fileref="images/Chapter-Rule_Language/compoundValueRestriction.png"
                           format="PNG" role=""></imagedata>
              </imageobject>
            </mediaobject>
          </figure>

          <example>
            <title>Compound Restriction using "in"</title>

            <programlisting>Person( $cheese : favouriteCheese )
Cheese( type in ( "stilton", "cheddar", $cheese ) )</programlisting>
          </example>
        </section>
      </section>

      <section>
        <title>Inline eval operator (deprecated)</title>

        <figure>
          <title>Inline Eval Expression</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="images/Chapter-Rule_Language/inlineEvalConstraint.png"
                         format="PNG"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>An <indexterm>
            <primary>Predicate</primary>
          </indexterm>inline eval constraint can use any valid dialect
        expression as long as it results to a primitive boolean. The
        expression must be constant over time. Any previously bound variable,
        from the current or previous pattern, can be used; autovivification is
        also used to auto-create field binding variables. When an identifier
        is found that is not a current variable, the builder looks to see if
        the identifier is a field on the current object type, if it is, the
        field binding is auto-created as a variable of the same name. This is
        called autovivification of field variables inside of inline
        eval's.</para>

        <para>This example will find all male-female pairs where the male is 2
        years older than the female; the variable <code>age</code> is
        auto-created in the second pattern by the autovivification
        process.</para>

        <example>
          <title>Return Value operator</title>

          <programlisting>Person( girlAge : age, sex = "F" )
Person( eval( age == girlAge + 2 ), sex = 'M' ) // eval() is actually obsolete in this example</programlisting>
        </example>

        <note>
          <para>Inline eval's are effectively obsolete as their inner syntax
          is now directly supported. It's recommended not to use them. Simply
          write the expression without wrapping eval() around it.</para>
        </note>
      </section>

      <section>
        <title>Operator precedence</title>

        <para>The operators are evaluated in this precedence:</para>

        <table>
          <title>Operator precedence</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry align="center">Operator type</entry>

                <entry align="center">Operators</entry>

                <entry align="center">Notes</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>(nested) property access</entry>

                <entry><literal>.</literal></entry>

                <entry>Not normal Java semantics</entry>
              </row>

              <row>
                <entry>List/Map access</entry>

                <entry><literal>[ ]</literal></entry>

                <entry>Not normal Java semantics</entry>
              </row>

              <row>
                <entry>constraint binding</entry>

                <entry><literal>:</literal></entry>

                <entry>Not normal Java semantics</entry>
              </row>

              <row>
                <entry>multiplicative</entry>

                <entry><literal>*</literal> <literal>/</literal>
                <literal>%</literal></entry>

                <entry></entry>
              </row>

              <row>
                <entry>additive</entry>

                <entry><literal>+</literal> <literal>-</literal></entry>

                <entry></entry>
              </row>

              <row>
                <entry>shift</entry>

                <entry><literal>&lt;&lt;</literal> <literal>&gt;&gt;</literal>
                <literal>&gt;&gt;&gt;</literal></entry>

                <entry></entry>
              </row>

              <row>
                <entry>relational</entry>

                <entry><literal>&lt;</literal> <literal>&gt;</literal>
                <literal>&lt;=</literal> <literal>&gt;=</literal>
                <literal>instanceof</literal></entry>

                <entry></entry>
              </row>

              <row>
                <entry>equality</entry>

                <entry><literal>==</literal> <literal>!=</literal></entry>

                <entry>Does not use normal Java (<emphasis>not</emphasis>)
                <emphasis>same</emphasis> semantics: uses
                (<emphasis>not</emphasis>) <emphasis>equals</emphasis>
                semantics instead.</entry>
              </row>

              <row>
                <entry>non-short circuiting AND</entry>

                <entry><literal>&amp;</literal></entry>

                <entry></entry>
              </row>

              <row>
                <entry>non-short circuiting exclusive OR</entry>

                <entry><literal>^</literal></entry>

                <entry></entry>
              </row>

              <row>
                <entry>non-short circuiting inclusive OR</entry>

                <entry><literal>|</literal></entry>

                <entry></entry>
              </row>

              <row>
                <entry>logical AND</entry>

                <entry><literal>&amp;&amp;</literal></entry>

                <entry></entry>
              </row>

              <row>
                <entry>logical OR</entry>

                <entry><literal>||</literal></entry>

                <entry></entry>
              </row>

              <row>
                <entry>ternary</entry>

                <entry><literal>? :</literal></entry>

                <entry></entry>
              </row>

              <row>
                <entry>Comma separated AND</entry>

                <entry><literal>,</literal></entry>

                <entry>Not normal Java semantics</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>

    <section>
      <title>Positional Arguments</title>

      <para>Patterns now support positional arguments on type
      declarations.</para>

      <para>Positional arguments are ones where you don't need to specify the
      field name, as the position maps to a known named field. i.e. Person(
      name == "mark" ) can be rewritten as Person( "mark"; ). The semicolon
      ';' is important so that the engine knows that everything before it is a
      positional argument. Otherwise we might assume it was a boolean
      expression, which is how it could be interpreted after the semicolon.
      You can mix positional and named arguments on a pattern by using the
      semicolon ';' to separate them. Any variables used in a positional that
      have not yet been bound will be bound to the field that maps to that
      position.</para>

      <programlisting>declare Cheese
    name : String
    shop : String
    price : int
end
</programlisting>

      <para>Example patterns, with two constraints and a binding. Remember
      semicolon ';' is used to differentiate the positional section from the
      named argument section. Variables and literals and expressions using
      just literals are supported in positional arguments, but not variables.
      Positional arguments are always resolved using unification.</para>

      <programlisting>Cheese( "stilton", "Cheese Shop", p; )
Cheese( "stilton", "Cheese Shop"; p : price )
Cheese( "stilton"; shop == "Cheese Shop", p : price )
Cheese( name == "stilton"; shop == "Cheese Shop", p : price )
</programlisting>

      <para>Positional arguments that are given a previously declared binding
      will constrain against that using unification; these are referred to as
      input arguments. If the binding does not yet exist, it will create the
      declaration binding it to the field represented by the position
      argument; these are referred to as output arguments.</para>
    </section>

  <section>
      <title>Fine grained property change listeners</title>

      <para>When you call modify() (see the modify statement section) on a given object it will trigger a revaluation of all
          patterns of the matching object type in the knowledge base. This can can lead to unwanted and useless evaluations
          and in the worst cases to infinite recursions. The only workaround to avoid it was to split up your objects into
          smaller ones having a 1 to 1 relationship with the original object.</para>

      <para>This feature allows the pattern matching to only react to modification of properties actually
          constrained or bound inside of a given pattern. That will help with performance and recursion and avoid artificial
          object splitting.</para>

      <para>By default this feature is off in order to make the behavior of the rule engine backward compatible with the
          former releases. When you want to activate it on a specific bean you have to annotate it with @propertyReactive.
          This annotation works both on drl type declarations:</para>

      <programlisting>declare Person
          @propertyReactive
          firstName : String
          lastName : String
          end</programlisting>

      <para>and on Java classes:</para>

      <programlisting>@PropertyReactive
          public static class Person {
          private String firstName;
          private String lastName;
          }</programlisting>

      <para>In this way, for instance, if you have a rule like the following:</para>

      <programlisting>rule "Every person named Mario is a male" when
          $person : Person( firstName == "Mario" )
          then
          modify ( $person )  { setMale( true ) }
          end</programlisting>

      <para>you won't have to add the no-loop attribute to it in order to avoid an infinite recursion because the engine
          recognizes that the pattern matching is done on the 'firstName' property while the RHS of the rule modifies the
          'male' one. Note that this feature does not work for update(), and this is one of the reasons why we promote
          modify() since it encapsulates the field changes within the statement. Moreover, on Java classes, you can also
          annotate any method to say that its invocation actually modifies other properties. For instance in the former
          Person class you could have a method like:</para>

      <programlisting>@Modifies( { "firstName", "lastName" } )
          public void setName(String name) {
          String[] names = name.split("\\s");
          this.firstName = names[0];
          this.lastName = names[1];
          }</programlisting>

      <para>That means that if a rule has a RHS like the following:</para>

      <programlisting>modify($person) { setName("Mario Fusco") }</programlisting>

      <para>it will correctly recognize that the values of both properties 'firstName' and 'lastName' could have
          potentially been modified and act accordingly, not missing of reevaluating the patterns constrained on them. At
          the moment the usage of @Modifies is not allowed on fields but only on methods. This is coherent with the most
          common scenario where the @Modifies will be used for methods that are not related with a class field as in the
          Person.setName() in the former example. Also note that @Modifies is not transitive, meaning that if another method
          internally invokes the Person.setName() one it won't be enough to annotate it with @Modifies( { "name" } ), but it
          is necessary to use @Modifies( { "firstName", "lastName" } ) even on it. Very likely @Modifies transitivity will
          be implemented in the next release.</para>

      <para>For what regards nested accessors, the engine will be notified only for top level fields. In other words a
          pattern matching like:</para>

      <programlisting>Person ( address.city.name == "London ) </programlisting>

      <para>will be revaluated only for modification of the 'address' property of a Person object. In the same way the
          constraints analysis is currently strictly limited to what there is inside a pattern. Another example could help
          to clarify this. An LHS like the following:</para>

      <programlisting>$p : Person( )
          Car( owner = $p.name )</programlisting>

      <para>will not listen on modifications of the person's name, while this one will do:</para>

      <programlisting>Person( $name : name )
          Car( owner = $name )</programlisting>

      <para>To overcome this problem it is possible to annotate a pattern with @watch as it follows:</para>

      <programlisting>$p : Person( ) @watch ( name )
          Car( owner = $p.name )</programlisting>

      <para>Indeed, annotating a pattern with @watch allows you to modify the inferred set of properties for which that
          pattern will react. Note that the properties named in the @watch annotation are actually added to the ones
          automatically inferred, but it is also possible to explicitly exclude one or more of them prepending their name
          with a ! and to make the pattern to listen for all or none of the properties of the type used in the pattern
          respectively with the wildcrds * and !*. So, for example, you can annotate a pattern in the LHS of a rule
          like:</para>

      <programlisting>// listens for changes on both firstName (inferred) and lastName
          Person( firstName == $expectedFirstName ) @watch( lastName )

          // listens for all the properties of the Person bean
          Person( firstName == $expectedFirstName ) @watch( * )

          // listens for changes on lastName and explicitly exclude firstName
          Person( firstName == $expectedFirstName ) @watch( lastName, !firstName )

          // listens for changes on all the properties except the age one
          Person( firstName == $expectedFirstName ) @watch( *, !age )</programlisting>

      <para>Since doesn't make sense to use this annotation on a pattern using a type not annotated with
          @PropertyReactive the rule compiler will raise a compilation error if you try to do so. Also the duplicated usage
          of the same property in @watch (for example like in: @watch( firstName, ! firstName ) ) will end up in a
          compilation error. In a next release we will make the automatic detection of the properties to be listened smarter
          by doing analysis even outside of the pattern.</para>

      <para>It also possible to enable this feature by default on all the types of your model or to completely disallow
          it by using on option of the KnowledgeBuilderConfiguration. In particular this new PropertySpecificOption can have
          one of the following 3 values:</para>

      <programlisting>- DISABLED =&gt; the feature is turned off and all the other related annotations are just ignored
          - ALLOWED =&gt; this is the default behavior: types are not property reactive unless they are not annotated with @PropertySpecific
          - ALWAYS =&gt; all types are property reactive by default</programlisting>

      <para>So, for example, to have a KnowledgeBuilder generating property reactive types by default you could
          do:</para>

      <programlisting>KnowledgeBuilderConfiguration config = KnowledgeBuilderFactory.newKnowledgeBuilderConfiguration();
          config.setOption(PropertySpecificOption.ALWAYS);
          KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder(config);</programlisting>

      <para>In this last case it will be possible to disable the property reactivity feature on a specific type by
          annotating it with @ClassReactive.</para>
    </section>

    <section>
      <title>Basic conditional elements</title>

      <section>
        <title>Conditional Element <literal>and</literal></title>

        <para>The Conditional Element <literal>"and"</literal> is used to
        group other Conditional Elements into a logical conjunction. Drools
        supports both prefix <literal>and</literal> and infix
        <literal>and</literal>.</para>

        <figure>
          <title>infixAnd</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="images/Chapter-Rule_Language/infixAnd.png"
                         format="PNG" role=""></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Traditional infix <literal>and</literal> is supported:</para>

        <programlisting>//infixAnd
Cheese( cheeseType : type ) and Person( favouriteCheese == cheeseType )</programlisting>

        <para>Explicit grouping with parentheses is also supported:</para>

        <programlisting>//infixAnd with grouping
( Cheese( cheeseType : type ) and
  ( Person( favouriteCheese == cheeseType ) or 
    Person( favouriteCheese == cheeseType ) )</programlisting>

        <note>
          <para>The symbol <literal>&amp;&amp;</literal> (as an alternative to
          <literal>and</literal>) is deprecated. But it is still supported in
          the syntax for backwards compatibility.</para>
        </note>

        <figure>
          <title>prefixAnd</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="images/Chapter-Rule_Language/prefixAnd.png"
                         format="PNG" role=""></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Prefix <literal>and</literal> is also supported:</para>

        <programlisting>(and Cheese( cheeseType : type )
     Person( favouriteCheese == cheeseType ) )</programlisting>

        <para>The root element of the LHS is an implicit prefix
        <literal>and</literal> and doesn't need to be specified:</para>

        <example>
          <title>implicit root prefixAnd</title>

          <programlisting>when
    Cheese( cheeseType : type )
    Person( favouriteCheese == cheeseType )
then
    ...</programlisting>
        </example>
      </section>

      <section>
        <title>Conditional Element <literal>or</literal></title>

        <para>The Conditional Element <literal>or</literal> is used to group
        other Conditional Elements into a logical disjunction. Drools supports
        both prefix <literal>or</literal> and infix
        <literal>or</literal>.</para>

        <figure>
          <title>infixOr</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="images/Chapter-Rule_Language/infixOr.png"
                         format="PNG" role=""></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Traditional infix <literal>or</literal> is supported:</para>

        <programlisting>//infixOr
Cheese( cheeseType : type ) or Person( favouriteCheese == cheeseType )</programlisting>

        <para>Explicit grouping with parentheses is also supported:</para>

        <programlisting>//infixOr with grouping
( Cheese( cheeseType : type ) or
  ( Person( favouriteCheese == cheeseType ) and
    Person( favouriteCheese == cheeseType ) )</programlisting>

        <note>
          <para>The symbol <literal>||</literal> (as an alternative to
          <literal>or</literal>) is deprecated. But it is still supported in
          the syntax for backwards compatibility.</para>
        </note>

        <figure>
          <title>prefixOr</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="images/Chapter-Rule_Language/prefixOr.png"
                         format="PNG" role=""></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Prefix <literal>or</literal> is also supported:</para>

        <programlisting>(or Person( sex == "f", age &gt; 60 )
    Person( sex == "m", age &gt; 65 )</programlisting>

        <note>
          <para>The behavior of the Conditional Element <literal>or</literal>
          is different from the connective <literal>||</literal> for
          constraints and restrictions in field constraints. The engine
          actually has no understanding of the Conditional Element
          <literal>or</literal>. Instead, via a number of different logic
          transformations, a rule with <literal>or</literal> is rewritten as a
          number of subrules. This process ultimately results in a rule that
          has a single <literal>or</literal> as the root node and one subrule
          for each of its CEs. Each subrule can activate and fire like any
          normal rule; there is no special behavior or interaction between
          these subrules. - This can be most confusing to new rule
          authors.</para>
        </note>

        <para>The Conditional Element <literal>or</literal> also allows for
        optional pattern binding. This means that each resulting subrule will
        bind its pattern to the pattern binding. Each pattern must be bound
        separately, using eponymous variables:</para>

        <programlisting>pensioner : ( Person( sex == "f", age &gt; 60 ) or Person( sex == "m", age &gt; 65 ) )</programlisting>

        <programlisting>(or pensioner : Person( sex == "f", age &gt; 60 ) 
    pensioner : Person( sex == "m", age &gt; 65 ) )</programlisting>

        <para>Since the conditional element <literal>or</literal> results in
        multiple subrule generation, one for each possible logically outcome,
        the example above would result in the internal generation of two
        rules. These two rules work independently within the Working Memory,
        which means both can match, activate and fire - there is no
        shortcutting.</para>

        <para>The best way to think of the conditional element
        <literal>or</literal> is as a shortcut for generating two or more
        similar rules. When you think of it that way, it's clear that for a
        single rule there could be multiple activations if two or more terms
        of the disjunction are true.</para>
      </section>

      <section>
        <title>Conditional Element <literal>not</literal></title>

        <figure>
          <title>not</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="images/Chapter-Rule_Language/not.png"
                         format="PNG" role=""></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>The CE <literal>not</literal> is first order logic's
        non-existential quantifier and checks for the non-existence of
        something in the Working Memory. Think of "not" as meaning "there must
        be none of...".</para>

        <para>The keyword <literal>not</literal> may be followed by
        parentheses around the CEs that it applies to. In the simplest case of
        a single pattern (like below) you may optionally omit the
        parentheses.</para>

        <example>
          <title>No Busses</title>

          <programlisting>not Bus()</programlisting>
        </example>

        <example>
          <title>No red Busses</title>

          <programlisting>// Brackets are optional:
not Bus(color == "red")
// Brackets are optional:
not ( Bus(color == "red", number == 42) )
// "not" with nested infix <literal>and</literal> - two patterns,
// brackets are requires:
not ( Bus(color == "red") and
      Bus(color == "blue") )</programlisting>
        </example>
      </section>

      <section>
        <title>Conditional Element <literal>exists</literal></title>

        <figure>
          <title>exists</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="images/Chapter-Rule_Language/exists.png"
                         format="PNG"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>The CE <literal>exists</literal> is first order logic's
        existential quantifier and checks for the existence of something in
        the Working Memory. Think of "exists" as meaning "there is at least
        one..". It is different from just having the pattern on its own, which
        is more like saying "for each one of...". If you use
        <literal>exists</literal> with a pattern, the rule will only activate
        at most once, regardless of how much data there is in working memory
        that matches the condition inside of the <literal>exists</literal>
        pattern. Since only the existence matters, no bindings will be
        established.</para>

        <para>The keyword <literal>exists</literal> must be followed by
        parentheses around the CEs that it applies to. In the simplest case of
        a single pattern (like below) you may omit the parentheses.</para>

        <example>
          <title>At least one Bus</title>

          <programlisting>exists Bus()</programlisting>
        </example>

        <example>
          <title>At least one red Bus</title>

          <programlisting>exists Bus(color == "red")
// brackets are optional:
exists ( Bus(color == "red", number == 42) )
// "exists" with nested infix <literal>and</literal>,
// brackets are required:
exists ( Bus(color == "red") and
         Bus(color == "blue") )</programlisting>
        </example>
      </section>
    </section>

    <section>
      <title>Advanced conditional elements</title>

      <section>
        <title>Conditional Element <literal>forall</literal></title>

        <figure>
          <title>forall</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="images/Chapter-Rule_Language/forall.png"
                         format="PNG"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>The Conditional Element <literal>forall</literal> completes the
        First Order Logic support in Drools. The Conditional Element
        <literal>forall</literal> evaluates to true when all facts that match
        the first pattern match all the remaining patterns. Example:</para>

        <programlisting>rule "All English buses are red"
when
    forall( $bus : Bus( type == 'english') 
                   Bus( this == $bus, color = 'red' ) )
then
    // all English buses are red
end</programlisting>

        <para>In the above rule, we "select" all Bus objects whose type is
        "english". Then, for each fact that matches this pattern we evaluate
        the following patterns and if they match, the forall CE will evaluate
        to true.</para>

        <para>To state that all facts of a given type in the working memory
        must match a set of constraints, <literal>forall</literal> can be
        written with a single pattern for simplicity. Example:</para>

        <example>
          <title>Single Pattern Forall</title>

          <programlisting>rule "All Buses are Red"
when
    forall( Bus( color == 'red' ) )
then
    // all Bus facts are red
end</programlisting>
        </example>

        <para>Another example shows multiple patterns inside the
        <literal>forall</literal>:</para>

        <example>
          <title>Multi-Pattern Forall</title>

          <programlisting>rule "all employees have health and dental care programs"
when
    forall( $emp : Employee()
            HealthCare( employee == $emp )
            DentalCare( employee == $emp )
          )
then
    // all employees have health and dental care
end</programlisting>
        </example>

        <para>Forall can be nested inside other CEs. For instance,
        <literal>forall</literal> can be used inside a <literal>not</literal>
        CE. Note that only single patterns have optional parentheses, so that
        with a nested <literal>forall</literal> parentheses must be
        used:</para>

        <example>
          <title>Combining Forall with Not CE</title>

          <programlisting>rule "not all employees have health and dental care"
when 
    not ( forall( $emp : Employee()
                  HealthCare( employee == $emp )
                  DentalCare( employee == $emp ) ) 
        )
then
    // not all employees have health and dental care
end</programlisting>
        </example>

        <para>As a side note, <code>forall( p1 p2 p3...)</code> is equivalent
        to writing:</para>

        <programlisting>not(p1 and not(and p2 p3...))</programlisting>

        <para>Also, it is important to note that <literal>forall</literal> is
        a <emphasis>scope delimiter</emphasis>. Therefore, it can use any
        previously bound variable, but no variable bound inside it will be
        available for use outside of it.</para>
      </section>

      <section>
        <title>Conditional Element <literal>from</literal></title>

        <figure>
          <title>from</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="images/Chapter-Rule_Language/from.png"
                         format="PNG"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>The Conditional Element <literal>from</literal> enables users to
        specify an arbitrary source for data to be matched by LHS patterns.
        This allows the engine to reason over data not in the Working Memory.
        The data source could be a sub-field on a bound variable or the
        results of a method call. It is a powerful construction that allows
        out of the box integration with other application components and
        frameworks. One common example is the integration with data retrieved
        on-demand from databases using hibernate named queries.</para>

        <para>The expression used to define the object source is any
        expression that follows regular MVEL syntax. Therefore, it allows you
        to easily use object property navigation, execute method calls and
        access maps and collections elements.</para>

        <para>Here is a simple example of reasoning and binding on another
        pattern sub-field:</para>

        <programlisting>rule "validate zipcode"
when
    Person( $personAddress : address ) 
    Address( zipcode == "23920W") from $personAddress 
then
    // zip code is ok
end</programlisting>

        <para>With all the flexibility from the new expressiveness in the
        Drools engine you can slice and dice this problem many ways. This is
        the same but shows how you can use a graph notation with the
        'from':</para>

        <programlisting>rule "validate zipcode"
when
    $p : Person( ) 
    $a : Address( zipcode == "23920W") from $p.address 
then
    // zip code is ok
end</programlisting>

        <para>Previous examples were evaluations using a single pattern. The
        CE <literal>from</literal> also support object sources that return a
        collection of objects. In that case, <literal>from</literal> will
        iterate over all objects in the collection and try to match each of
        them individually. For instance, if we want a rule that applies 10%
        discount to each item in an order, we could do:</para>

        <programlisting>rule "apply 10% discount to all items over US$ 100,00 in an order"
when
    $order : Order()
    $item  : OrderItem( value &gt; 100 ) from $order.items
then
    // apply discount to $item
end</programlisting>

        <para>The above example will cause the rule to fire once for each item
        whose value is greater than 100 for each given order.</para>

        <para>You must take caution, however, when using
        <literal>from</literal>, especially in conjunction with the
        <literal>lock-on-active</literal> rule attribute as it may produce
        unexpected results. Consider the example provided earlier, but now
        slightly modified as follows:</para>

        <programlisting>rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person( ) 
    $a : Address( state == "NC") from $p.address 
then
    modify ($p) {} // Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person( ) 
    $a : Address( city == "Raleigh") from $p.address 
then
    modify ($p) {} // Apply discount to person in a modify block
end</programlisting>

        <para>In the above example, persons in Raleigh, NC should be assigned
        to sales region 1 and receive a discount; i.e., you would expect both
        rules to activate and fire. Instead you will find that only the second
        rule fires.</para>

        <para>If you were to turn on the audit log, you would also see that
        when the second rule fires, it deactivates the first rule. Since the
        rule attribute <literal>lock-on-active</literal> prevents a rule from
        creating new activations when a set of facts change, the first rule
        fails to reactivate. Though the set of facts have not changed, the use
        of <literal>from</literal> returns a new fact for all intents and
        purposes each time it is evaluated.</para>

        <para>First, it's important to review why you would use the above
        pattern. You may have many rules across different rule-flow groups.
        When rules modify working memory and other rules downstream of your
        RuleFlow (in different rule-flow groups) need to be reevaluated, the
        use of <literal>modify</literal> is critical. You don't, however, want
        other rules in the same rule-flow group to place activations on one
        another recursively. In this case, the <literal>no-loop</literal>
        attribute is ineffective, as it would only prevent a rule from
        activating itself recursively. Hence, you resort to
        <literal>lock-on-active</literal>.</para>

        <para>There are several ways to address this issue:</para>

        <itemizedlist>
          <listitem>
            <para>Avoid the use of <literal>from</literal> when you can assert
            all facts into working memory or use nested object references in
            your constraint expressions (shown below).</para>
          </listitem>

          <listitem>
            <para>Place the variable assigned used in the modify block as the
            last sentence in your condition (LHS).</para>
          </listitem>

          <listitem>
            <para>Avoid the use of <literal>lock-on-active</literal> when you
            can explicitly manage how rules within the same rule-flow group
            place activations on one another (explained below).</para>
          </listitem>
        </itemizedlist>

        <para>The preferred solution is to minimize use of
        <literal>from</literal> when you can assert all your facts into
        working memory directly. In the example above, both the Person and
        Address instance can be asserted into working memory. In this case,
        because the graph is fairly simple, an even easier solution is to
        modify your rules as follows:</para>

        <programlisting>rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person(address.state == "NC" )  
then
    modify ($p) {} // Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person(address.city == "Raleigh" )  
then
    modify ($p) {} //Apply discount to person in a modify block
end</programlisting>

        <para>Now, you will find that both rules fire as expected. However, it
        is not always possible to access nested facts as above. Consider an
        example where a Person holds one or more Addresses and you wish to use
        an existential quantifier to match people with at least one address
        that meets certain conditions. In this case, you would have to resort
        to the use of <literal>from</literal> to reason over the
        collection.</para>

        <para>There are several ways to use <literal>from</literal> to achieve
        this and not all of them exhibit an issue with the use of
        <literal>lock-on-active</literal>. For example, the following use of
        <literal>from</literal> causes both rules to fire as expected:</para>

        <programlisting>rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person($addresses : addresses)
    exists (Address(state == "NC") from $addresses)  
then
    modify ($p) {} // Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person($addresses : addresses)
    exists (Address(city == "Raleigh") from $addresses)  
then
    modify ($p) {} // Apply discount to person in a modify block
end</programlisting>

        <para>However, the following slightly different approach does exhibit
        the problem:</para>

        <programlisting>rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $assessment : Assessment()
    $p : Person()
    $addresses : List() from $p.addresses
    exists (Address( state == "NC") from $addresses) 
then
    modify ($assessment) {} // Modify assessment in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $assessment : Assessment()
    $p : Person()
    $addresses : List() from $p.addresses 
    exists (Address( city == "Raleigh") from $addresses)
then
    modify ($assessment) {} // Modify assessment in a modify block
end</programlisting>

        <para>In the above example, the $addresses variable is returned from
        the use of <literal>from</literal>. The example also introduces a new
        object, assessment, to highlight one possible solution in this case.
        If the $assessment variable assigned in the condition (LHS) is moved
        to the last condition in each rule, both rules fire as
        expected.</para>

        <para>Though the above examples demonstrate how to combine the use of
        <literal>from</literal> with <literal>lock-on-active</literal> where
        no loss of rule activations occurs, they carry the drawback of placing
        a dependency on the order of conditions on the LHS. In addition, the
        solutions present greater complexity for the rule author in terms of
        keeping track of which conditions may create issues.</para>

        <para>A better alternative is to assert more facts into working
        memory. In this case, a person's addresses may be asserted into
        working memory and the use of <literal>from</literal> would not be
        necessary.</para>

        <para>There are cases, however, where asserting all data into working
        memory is not practical and we need to find other solutions. Another
        option is to reevaluate the need for
        <literal>lock-on-active</literal>. An alternative to
        <literal>lock-on-active</literal> is to directly manage how rules
        within the same rule-flow group activate one another by including
        conditions in each rule that prevent rules from activating each other
        recursively when working memory is modified. For example, in the case
        above where a discount is applied to citizens of Raleigh, a condition
        may be added to the rule that checks whether the discount has already
        been applied. If so, the rule does not activate.</para>
      </section>

      <section>
        <title>Conditional Element <literal>collect</literal></title>

        <figure>
          <title>collect</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="images/Chapter-Rule_Language/collect.png"
                         format="PNG"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>The Conditional Element <literal>collect</literal> allows rules
        to reason over a collection of objects obtained from the given source
        or from the working memory. In First Oder Logic terms this is the
        cardinality quantifier. A simple example:</para>

        <programlisting>import java.util.ArrayList

rule "Raise priority if system has more than 3 pending alarms"
when
    $system : System()
    $alarms : ArrayList( size &gt;= 3 )
              from collect( Alarm( system == $system, status == 'pending' ) )
then
    // Raise priority, because system $system has
    // 3 or more alarms pending. The pending alarms
    // are $alarms.
end</programlisting>

        <para>In the above example, the rule will look for all pending alarms
        in the working memory for each given system and group them in
        ArrayLists. If 3 or more alarms are found for a given system, the rule
        will fire.</para>

        <para>The result pattern of <literal>collect</literal> can be any
        concrete class that implements the <code>java.util.Collection</code>
        interface and provides a default no-arg public constructor. This means
        that you can use Java collections like ArrayList, LinkedList, HashSet,
        etc., or your own class, as long as it implements the
        <code>java.util.Collection</code> interface and provide a default
        no-arg public constructor.</para>

        <para>Both source and result patterns can be constrained as any other
        pattern.</para>

        <para>Variables bound before the <literal>collect</literal> CE are in
        the scope of both source and result patterns and therefore you can use
        them to constrain both your source and result patterns. But note that
        <literal>collect</literal> is a scope delimiter for bindings, so that
        any binding made inside of it is not available for use outside of
        it.</para>

        <para>Collect accepts nested <literal>from</literal> CEs. The
        following example is a valid use of "collect":</para>

        <programlisting>import java.util.LinkedList;

rule "Send a message to all mothers"
when
    $town : Town( name == 'Paris' )
    $mothers : LinkedList() 
               from collect( Person( gender == 'F', children &gt; 0 ) 
                             from $town.getPeople() 
                           )
then
    // send a message to all mothers
end</programlisting>
      </section>

      <section>
        <title>Conditional Element <literal>accumulate</literal></title>

        <figure>
          <title>accumulate</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="images/Chapter-Rule_Language/accumulate.png"
                         format="PNG"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>The Conditional Element <literal>accumulate</literal> is a more
        flexible and powerful form of <literal>collect</literal>, in the sense
        that it can be used to do what <literal>collect</literal> does and
        also achieve results that the CE <literal>collect</literal> is not
        capable of doing. Basically, what it does is that it allows a rule to
        iterate over a collection of objects, executing custom actions for
        each of the elements, and at the end it returns a result
        object.</para>

        <para>Accumulate supports both the use of pre-defined accumulate
        functions, or the use of inline custom code. Inline custom code should
        be avoided though, as it is harder for rule authors to maintain, and
        frequently leads to code duplication. Accumulate functions are easier
        to test and reuse.</para>

        <para>The Accumulate CE also supports multiple different syntaxes. The
        preferred syntax is the top level accumulate, as noted bellow, but all
        other syntaxes are supported for backward compatibility.</para>

        <section>
          <title>Accumulate CE (preferred syntax)</title>

          <para>The top level accumulate syntax is the most compact and
          flexible syntax. The simplified syntax is as follows:</para>

          <programlisting><literal>accumulate( </literal><replaceable>&lt;source pattern&gt;</replaceable><literal>; </literal><replaceable>&lt;functions&gt;</replaceable><literal> [;</literal><replaceable>&lt;constraints&gt;</replaceable><literal>] )</literal>
</programlisting>

          <para>For instance, a rule to calculate the minimum, maximum and
          average temperature reading for a given sensor and that raises an
          alarm if the minimum temperature is under 20C degrees and the
          average is over 70C degrees could be written in the following way,
          using Accumulate:</para>

          <programlisting>rule "Raise alarm"
when
    $s : Sensor()
    accumulate( Reading( sensor == $s, $temp : temperature );
                $min : min( $temp ),
                $max : max( $temp ),
                $avg : average( $temp );
                $min &lt; 20, $avg &gt; 70 )
then
    // raise the alarm
end</programlisting>

          <para>In the above example, min, max and average are Accumulate
          Functions and will calculate the minimum, maximum and average
          temperature values over all the readings for each sensor.</para>

          <para>Drools ships with several built-in accumulate functions,
          including:</para>

          <itemizedlist>
            <listitem>
              <para>average</para>
            </listitem>

            <listitem>
              <para>min</para>
            </listitem>

            <listitem>
              <para>max</para>
            </listitem>

            <listitem>
              <para>count</para>
            </listitem>

            <listitem>
              <para>sum</para>
            </listitem>

            <listitem>
              <para>collectList</para>
            </listitem>

            <listitem>
              <para>collectSet</para>
            </listitem>
          </itemizedlist>

          <para>These common functions accept any expression as input. For
          instance, if someone wants to calculate the average profit on all
          items of an order, a rule could be written using the average
          function:</para>

          <programlisting>rule "Average profit"
when
    $order : Order()
    accumulate( OrderItem( order == $order, $cost : cost, $price : price );
                $avgProfit : average( 1 - $cost / $price ) )
then
    // average profit for $order is $avgProfit
end</programlisting>

          <para>Accumulate Functions are all pluggable. That means that if
          needed, custom, domain specific functions can easily be added to the
          engine and rules can start to use them without any restrictions. To
          implement a new Accumulate Function all one needs to do is to create
          a Java class that implements the
          <code>org.kie.api.runtime.rule.AccumulateFunction</code>
          interface and add a line to the configuration file or set a system
          property to let the engine know about the new function. As an
          example of an Accumulate Function implementation, the following is
          the implementation of the <literal>average</literal>
          function:</para>

          <programlisting language="java">/**
 * An implementation of an accumulator capable of calculating average values
 */
public class AverageAccumulateFunction implements AccumulateFunction {

    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {

    }

    public void writeExternal(ObjectOutput out) throws IOException {

    }

    public static class AverageData implements Externalizable {
        public int    count = 0;
        public double total = 0;
        
        public AverageData() {}

        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
            count   = in.readInt();
            total   = in.readDouble();
        }

        public void writeExternal(ObjectOutput out) throws IOException {
            out.writeInt(count);
            out.writeDouble(total);
        }

    }

    /* (non-Javadoc)
     * @see org.kie.base.accumulators.AccumulateFunction#createContext()
     */
    public Serializable createContext() {
        return new AverageData();
    }

    /* (non-Javadoc)
     * @see org.kie.base.accumulators.AccumulateFunction#init(java.lang.Object)
     */
    public void init(Serializable context) throws Exception {
        AverageData data = (AverageData) context;
        data.count = 0;
        data.total = 0;
    }

    /* (non-Javadoc)
     * @see org.kie.base.accumulators.AccumulateFunction#accumulate(java.lang.Object, java.lang.Object)
     */
    public void accumulate(Serializable context,
                           Object value) {
        AverageData data = (AverageData) context;
        data.count++;
        data.total += ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.kie.base.accumulators.AccumulateFunction#reverse(java.lang.Object, java.lang.Object)
     */
    public void reverse(Serializable context,
                        Object value) throws Exception {
        AverageData data = (AverageData) context;
        data.count--;
        data.total -= ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.kie.base.accumulators.AccumulateFunction#getResult(java.lang.Object)
     */
    public Object getResult(Serializable context) throws Exception {
        AverageData data = (AverageData) context;
        return new Double( data.count == 0 ? 0 : data.total / data.count );
    }

    /* (non-Javadoc)
     * @see org.kie.base.accumulators.AccumulateFunction#supportsReverse()
     */
    public boolean supportsReverse() {
        return true;
    }

    /**
     * {@inheritDoc}
     */
    public Class&lt; ? &gt; getResultType() {
        return Number.class;
    }

}
</programlisting>

          <para>The code for the function is very simple, as we could expect,
          as all the "dirty" integration work is done by the engine. Finally,
          to plug the function into the engine, we added it to the
          configuration file:</para>

          <programlisting>drools.accumulate.function.average = org.drools.core.base.accumulators.AverageAccumulateFunction</programlisting>

          <para>Here, "drools.accumulate.function." is a prefix that must
            always be used, "average" is how the function will be used in the
            rule file, and
            "org.drools.core.base.accumulators.AverageAccumulateFunction" is the
            fully qualified name of the class that implements the function
            behavior.</para>
        </section>

        <section>
          <title>Alternate Syntax: single function with return type</title>

          <para>The accumulate syntax evolved over time with the goal of
          becoming more compact and expressive. Nevertheless, Drools still
          supports previous syntaxes for backward compatibility
          purposes.</para>

          <para>In case the rule is using a single accumulate function on a
          given accumulate, the author may add a pattern for the result object
          and use the "from" keyword to link it to the accumulate result.
          Example: a rule to apply a 10% discount on orders over $100 could be
          written in the following way:</para>

          <programlisting>rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              sum( $value ) )
then
    # apply discount to $order
end</programlisting>

          <para>In the above example, the accumulate element is using only one
          function (sum), and so, the rules author opted to explicitly write a
          pattern for the result type of the accumulate function (Number) and
          write the constraints inside it. There are no problems in using this
          syntax over the compact syntax presented before, except that is is a
          bit more verbose. Also note that it is not allowed to use both the
          return type and the functions binding in the same accumulate statement.</para>
        </section>

        <section>
          <title>Accumulate with inline custom code</title>

          <warning>
            <para>The use of accumulate with inline custom code is not a good
            practice for several reasons, including difficulties on maintaining
            and testing rules that use them, as well as the inability of
            reusing that code. Implementing your own accumulate functions is
            very simple and straightforward, they are easy to unit test and to
            use. This form of accumulate is supported for backward
            compatibility only.</para>
          </warning>

          <para>Another possible syntax for the accumulate is to define inline
          custom code, instead of using accumulate functions. As noted on the
          previous warned, this is discouraged though for the stated
          reasons.</para>

          <para>The general syntax of the <literal>accumulate</literal> CE
          with inline custom code is:</para>

          <programlisting><replaceable>&lt;result pattern&gt;</replaceable> <literal>from accumulate(</literal> <replaceable>&lt;source pattern&gt;</replaceable><literal>,</literal>
                                  <literal>init(</literal> <replaceable>&lt;init code&gt;</replaceable> <literal>),</literal>
                                  <literal>action(</literal> <replaceable>&lt;action code&gt;</replaceable> <literal>),</literal>
                                  <literal>reverse(</literal> <replaceable>&lt;reverse code&gt;</replaceable> <literal>),</literal>
                                  <literal>result(</literal> <replaceable>&lt;result expression&gt;</replaceable> <literal>) )</literal>
</programlisting>

          <para>The meaning of each of the elements is the following:</para>

          <itemizedlist>
            <listitem>
              <para><emphasis>&lt;source pattern&gt;</emphasis>: the source
              pattern is a regular pattern that the engine will try to match
              against each of the source objects.</para>
            </listitem>

            <listitem>
              <para><emphasis>&lt;init code&gt;</emphasis>: this is a semantic
              block of code in the selected dialect that will be executed once
              for each tuple, before iterating over the source objects.</para>
            </listitem>

            <listitem>
              <para><emphasis>&lt;action code&gt;</emphasis>: this is a
              semantic block of code in the selected dialect that will be
              executed for each of the source objects.</para>
            </listitem>

            <listitem>
              <para><emphasis>&lt;reverse code&gt;</emphasis>: this is an
              optional semantic block of code in the selected dialect that if
              present will be executed for each source object that no longer
              matches the source pattern. The objective of this code block is
              to undo any calculation done in the <emphasis>&lt;action
              code&gt;</emphasis> block, so that the engine can do decremental
              calculation when a source object is modified or retracted,
              hugely improving performance of these operations.</para>
            </listitem>

            <listitem>
              <para><emphasis>&lt;result expression&gt;</emphasis>: this is a
              semantic expression in the selected dialect that is executed
              after all source objects are iterated.</para>
            </listitem>

            <listitem>
              <para><emphasis>&lt;result pattern&gt;</emphasis>: this is a
              regular pattern that the engine tries to match against the
              object returned from the <emphasis>&lt;result
              expression&gt;</emphasis>. If it matches, the
              <literal>accumulate</literal> conditional element evaluates to
              <emphasis>true</emphasis> and the engine proceeds with the
              evaluation of the next CE in the rule. If it does not matches,
              the <literal>accumulate</literal> CE evaluates to
              <emphasis>false</emphasis> and the engine stops evaluating CEs
              for that rule.</para>
            </listitem>
          </itemizedlist>

          <para>It is easier to understand if we look at an example:</para>

          <programlisting>rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              init( double total = 0; ),
                              action( total += $value; ),
                              reverse( total -= $value; ),
                              result( total ) )
then
    # apply discount to $order
end</programlisting>

          <para>In the above example, for each <code>Order</code> in the
          Working Memory, the engine will execute the <emphasis>init
          code</emphasis> initializing the total variable to zero. Then it
          will iterate over all <code>OrderItem</code> objects for that order,
          executing the <emphasis>action</emphasis> for each one (in the
          example, it will sum the value of all items into the total
          variable). After iterating over all <code>OrderItem</code> objects,
          it will return the value corresponding to the <emphasis>result
          expression</emphasis> (in the above example, the value of variable
          <code>total</code>). Finally, the engine will try to match the
          result with the <code>Number</code> pattern, and if the double value
          is greater than 100, the rule will fire.</para>

          <para>The example used Java as the semantic dialect, and as such,
          note that the usage of the semicolon as statement delimiter is
          mandatory in the init, action and reverse code blocks. The result is
          an expression and, as such, it does not admit ';'. If the user uses
          any other dialect, he must comply to that dialect's specific
          syntax.</para>

          <para>As mentioned before, the <emphasis>reverse code</emphasis> is
          optional, but it is strongly recommended that the user writes it in
          order to benefit from the <emphasis>improved performance on update
          and retract</emphasis>.</para>

          <para>The <literal>accumulate</literal> CE can be used to execute
          any action on source objects. The following example instantiates and
          populates a custom object:</para>

          <programlisting>rule "Accumulate using custom objects"
when
    $person   : Person( $likes : likes )
    $cheesery : Cheesery( totalAmount &gt; 100 )
                from accumulate( $cheese : Cheese( type == $likes ),
                                 init( Cheesery cheesery = new Cheesery(); ),
                                 action( cheesery.addCheese( $cheese ); ),
                                 reverse( cheesery.removeCheese( $cheese ); ),
                                 result( cheesery ) );
then
    // do something
end</programlisting>
        </section>
      </section>
    </section>

    <section>
      <title>Conditional Element <literal>eval</literal></title>

      <figure>
        <title>eval</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="images/Chapter-Rule_Language/eval.png"
                       format="PNG" role=""></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The conditional element <literal>eval</literal> is essentially a
      catch-all which allows any semantic code (that returns a primitive
      boolean) to be executed. This code can refer to variables that were
      bound in the LHS of the rule, and functions in the rule package. Overuse
      of eval reduces the declarativeness of your rules and can result in a
      poorly performing engine. While <literal>eval</literal> can be used
      anywhere in the patterns, the best practice is to add it as the last
      conditional element in the LHS of a rule.</para>

      <para>Evals cannot be indexed and thus are not as efficient as Field
      Constraints. However this makes them ideal for being used when functions
      return values that change over time, which is not allowed within Field
      Constraints.</para>

      <para>For folks who are familiar with Drools 2.x lineage, the old Drools
      parameter and condition tags are equivalent to binding a variable to an
      appropriate type, and then using it in an eval node.</para>

      <programlisting>p1 : Parameter()
p2 : Parameter()
eval( p1.getList().containsKey( p2.getItem() ) )</programlisting>

      <programlisting>p1 : Parameter()
p2 : Parameter()
// call function isValid in the LHS
eval( isValid( p1, p2 ) )</programlisting>
    </section>

    <section>
      <title>Railroad diagrams</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/AccumulateAction.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/AccumulateClause.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/AccumulateFunction.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/AccumulateInit.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/AccumulateResult.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/AccumulateReverse.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/AccumulateSteps.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Accumulations.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/AdditiveExpr.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Annotation.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Arguments.svg,"
                     format="SVG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ArrayCreatorRest.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ArrayInitializer.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/AssignmentOperator.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/BindingPattern.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Block.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/BooleanLiteral.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/CompilationUnit.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ConditionalAnd.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ConditionalElementAccumulate.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ConditionalElementEval.svg,"
                     format="SVG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ConditionalElementExists.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ConditionalElementForall.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ConditionalElementNot.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ConditionalElement.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ConditionalExpr.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ConditionalOrExpr.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ConditionalOr.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Constraints.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/CreatedName.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Creator.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Definition.svg,"
                     format="SVG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Digit.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ExplicitGenericInvocationSuffix.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ExplicitGenericInvocation.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Exponent.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ExpressionList.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Expression.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Field.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Fraction.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/FromAccumulateClause.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/FromClause.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/FromCollectClause.svg,"
                     format="SVG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/FunctionDefinition.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/GlobalDefinition.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/IdentifierSuffix.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ImportDefinition.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/InExpr.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/InlineListExpr.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/InlineMapExpr.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/InnerCreator.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/InstanceOfExpr.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/IntLiteral.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Literal.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ModifyStatement.svg,"
                     format="SVG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/NonWildcardTypeArguments.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/OrRestriction.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/OverClause.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Parameters.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Pattern.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Placeholders.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Primary.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/PrimitiveType.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/QualifiedName.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/QueryDefinition.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/QueryOptions.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/RealLiteral.svg,"
                     format="SVG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/RealTypeSuffix.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/RelationalExpr.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/RelationalOperator.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/RhsStatement.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/RuleAttributes.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/RuleAttribute.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/RuleDefinition.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/RuleOptions.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Selector.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ShiftExpr.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/SingleRestriction.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/SourcePattern.svg,"
                     format="SVG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/StringId.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/SuperSuffix.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/ThenPart.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/TypeArguments.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/TypeArgument.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/TypeDefinition.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/TypeOptions.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Type.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/UnaryExprNotPlusMinus.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/UnaryExpr.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/Value.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/VariableInitializer.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Language_Reference/WhenPart.png"
                     format="PNG"></imagedata>
        </imageobject>
      </mediaobject>
    </section>
  </section>

  <section>
    <title>The Right Hand Side (then)</title>

    <section>
      <title>Usage</title>

      <para>The Right Hand Side (RHS) is a common name for the consequence or
      action part of the rule; this part should contain a list of actions to
      be executed. It is bad practice to use imperative or conditional code in
      the RHS of a rule; as a rule should be atomic in nature - "when this,
      then do this", not "when this, maybe do this". The RHS part of a rule
      should also be kept small, thus keeping it declarative and readable. If
      you find you need imperative and/or conditional code in the RHS, then
      maybe you should be breaking that rule down into multiple rules. The
      main purpose of the RHS is to insert, retractor modify working memory
      data. To assist with that there are a few convenience methods you can
      use to modify working memory; without having to first reference a
      working memory instance.</para>

      <para><literal>update(</literal><emphasis>object,
      handle</emphasis><literal>);</literal> will tell the engine that an
      object has changed (one that has been bound to something on the LHS) and
      rules may need to be reconsidered.</para>

      <para><literal>update(</literal><emphasis>object</emphasis><literal>);</literal>
      can also be used; here the Knowledge Helper will look up the facthandle
      for you, via an identity check, for the passed object. (Note that if you
      provide Property Change Listeners to your Java beans that you are
      inserting into the engine, you can avoid the need to call
      <code>update()</code> when the object changes.). After a fact's field
      values have changed you must call update before changing another fact,
      or you will cause problems with the indexing within the rule engine. The
      modify keyword avoids this problem.</para>

      <para><literal>insert(new</literal>
      <emphasis>Something</emphasis><literal>());</literal> will place a new
      object of your creation into the Working Memory.</para>

      <para><literal>insertLogical(new</literal>
      <emphasis>Something</emphasis><literal>());</literal> is similar to
      insert, but the object will be automatically retracted when there are no
      more facts to support the truth of the currently firing rule.</para>

      <para><literal>retract(</literal><emphasis>handle</emphasis><literal>);</literal>
      removes an object from Working Memory.</para>

      <para>These convenience methods are basically macros that provide short
      cuts to the <code>KnowledgeHelper</code> instance that lets you access
      your Working Memory from rules files. The predefined variable
      <code>drools</code> of type <code>KnowledgeHelper</code> lets you call
      several other useful methods. (Refer to the <code>KnowledgeHelper</code>
      interface documentation for more advanced operations).</para>

      <itemizedlist>
        <listitem>
          <para>The call <code>drools.halt()</code> terminates rule execution
          immediately. This is required for returning control to the point
          whence the current session was put to work with
          <code>fireUntilHalt()</code>.</para>
        </listitem>

        <listitem>
          <para>Methods <code>insert(Object o)</code>, <code>update(Object
          o)</code> and <code>retract(Object o)</code> can be called on
          <code>drools</code> as well, but due to their frequent use they can
          be called without the object reference.</para>
        </listitem>

        <listitem>
          <para><code>drools.getWorkingMemory()</code> returns the
          <code>WorkingMemory</code> object.</para>
        </listitem>

        <listitem>
          <para><code>drools.setFocus( String s)</code> sets the focus to the
          specified agenda group.</para>
        </listitem>

        <listitem>
          <para><code>drools.getRule().getName()</code>, called from a rule's
          RHS, returns the name of the rule.</para>
        </listitem>

        <listitem>
          <para><code>drools.getTuple()</code> returns the Tuple that matches
          the currently executing rule, and
          <code>drools.getActivation()</code> delivers the corresponding
          Activation. (These calls are useful for logging and debugging
          purposes.)</para>
        </listitem>
      </itemizedlist>

      <para>The full Knowledge Runtime API is exposed through another
      predefined variable, <code>kcontext</code>, of type
      <code>KnowledgeContext</code>. Its method
      <code>getKnowledgeRuntime()</code> delivers an object of type
      <code>KnowledgeRuntime</code>, which, in turn, provides access to a
      wealth of methods, many of which are quite useful for coding RHS
      logic.</para>

      <itemizedlist>
        <listitem>
          <para>The call <code>kcontext.getKnowledgeRuntime().halt()</code>
          terminates rule execution immediately.</para>
        </listitem>

        <listitem>
          <para>The accessor <code>getAgenda()</code> returns a reference to
          this session's <code>Agenda</code>, which in turn provides access to
          the various rule groups: activation groups, agenda groups, and rule
          flow groups. A fairly common paradigm is the activation of some
          agenda group, which could be done with the lengthy call:</para>

          <programlisting language="java">// give focus to the agenda group CleanUp
kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "CleanUp" ).setFocus();</programlisting>

          <para>(You can achieve the same using <code>drools.setFocus(
          "CleanUp" )</code>.)</para>
        </listitem>

        <listitem>
          <para>To run a query, you call <code>getQueryResults(String
          query)</code>, whereupon you may process the results, as explained
          in section <quote><link endterm="sec.query.title"
          linkend="sec.query"></link></quote>.</para>
        </listitem>

        <listitem>
          <para>A set of methods dealing with event management lets you, among
          other things, add and remove event listeners for the Working Memory
          and the Agenda.</para>
        </listitem>

        <listitem>
          <para>Method<code>getKnowledgeBase()</code> returns the
          <code>KnowledgeBase</code> object, the backbone of all the Knowledge
          in your system, and the originator of the current session.</para>
        </listitem>

        <listitem>
          <para>You can manage globals with <code>setGlobal(...)</code>,
          <code>getGlobal(...)</code> and <code>getGlobals()</code>.</para>
        </listitem>

        <listitem>
          <para>Method <code>getEnvironment()</code> returns the runtime's
          <code>Environment</code> which works much like what you know as your
          operating system's environment.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>The <literal>modify</literal> Statement</title>

      <para>This language extension provides a structured approach to fact
      updates. It combines the update operation with a number of setter calls
      to change the object's fields. This is the syntax schema for the
      <literal>modify</literal> statement:</para>

      <programlisting><literal>modify ( </literal><replaceable>&lt;fact-expression&gt;</replaceable><literal> ) {</literal>
    <replaceable>&lt;expression&gt;</replaceable> [ <literal>,</literal> <replaceable>&lt;expression&gt;</replaceable> ]*
<literal>}</literal></programlisting>

      <para>The parenthesized <emphasis>&lt;fact-expression&gt;</emphasis>
      must yield a fact object reference. The expression list in the block
      should consist of setter calls for the given object, to be written
      without the usual object reference, which is automatically prepended by
      the compiler.</para>

      <para>The example illustrates a simple fact modification.</para>

      <example>
        <title>A modify statement</title>

        <programlisting>rule "modify stilton"
when
    $stilton : Cheese(type == "stilton")
then
    modify( $stilton ){
        setPrice( 20 ),
        setAge( "overripe" )
    }
end</programlisting>
      </example>

      <para>The advantages in using the modify statment are particularly clear when
      used in conjuction with fine grained property change listeners.
      See the corresponding section for more details.</para>
    </section>
  </section>

  <section>
    <title>A Note on Auto-boxing and Primitive Types</title>

    <para>Drools attempts to preserve numbers in their primitive or object
    wrapper form, so a variable bound to an int primitive when used in a code
    block or expression will no longer need manual unboxing; unlike Drools 3.0
    where all primitives were autoboxed, requiring manual unboxing. A variable
    bound to an object wrapper will remain as an object; the existing JDK 1.5
    and JDK 5 rules to handle auto-boxing and unboxing apply in this case.
    When evaluating field constraints, the system attempts to coerce one of
    the values into a comparable format; so a primitive is comparable to an
    object wrapper.</para>
  </section>
</section>
