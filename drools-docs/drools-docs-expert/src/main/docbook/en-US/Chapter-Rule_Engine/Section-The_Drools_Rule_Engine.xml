<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="../" xmlns="http://docbook.org/ns/docbook" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:ns="http://docbook.org/ns/docbook">
  <title>The Drools Rule Engine</title>

  <section>
    <title>Overview</title>

    <para>Drools is split into two main parts: Authoring and Runtime.</para>

    <para>The authoring process involves the creation of DRL or XML files for
    rules which are fed into a parser - defined by an Antlr 3 grammar. The
    parser checks for correctly formed grammar and produces an intermediate
    structure for the "descr"; where the "descr" indicates the
    abstract syntax tree (AST) that
    "describes" the rules. The AST is then passed to the Package Builder which
    produces Packages. Package Builder also undertakes any code generation and
    compilation that is necessary for the creation of the Package. A Package
    object is self-contained and deployable, in that it is a serialized object
    consisting of one or more rules.</para>

    <figure>
      <title>Authoring Components</title>

      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/Authoring.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>A RuleBase is a runtime component which consists of one or more
    Packages. Packages can be added and removed from the RuleBase at any time.
    A RuleBase can instantiate one or more WorkingMemories at any time; a weak
    reference is maintained, unless configured otherwise. The Working Memory
    consists of a number of sub components, including Working Memory Event
    Support, Truth Maintenance System, Agenda and Agenda Event Support. Object
    insertion may result in the creation of one or more Activations. The
    Agenda is responsible for scheduling the execution of these
    Activations.</para>

    <figure>
      <title>Runtime Components</title>

      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/Runtime.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>
  </section>

  <section>
    <title>Authoring</title>

    <figure>
      <title>PackageBuilder</title>

      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/PackageBuilder.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Four classes are used for authoring: <code>DrlParser</code>, <code>XmlParser</code>,
    <code>ProcessBuilder</code> and <code>PackageBuilder</code>. The two parser classes produce "descr"
    (description) AST models from a provided Reader instance. ProcessBuilder
    reads in an xstream serialization, i.e., a representation of the Rule Flow.
    PackageBuilder provides convenience APIs so that you can mostly forget
    about those classes. The three convenience methods are
    <code>addPackageFromDrl</code>, <code>addPackageFromXml</code> and <code>addRuleFlow</code> - all take an
    instance of Reader as an argument. The example below shows how to build a
    package that includes both XML and DRL rule files and a ruleflow file,
    which are in the classpath. Note that all added package sources must be of
    the same package namespace for the current <code>PackageBuilder</code> instance!</para>

    <example>
      <title>Building a Package from Multiple Sources</title>

      <programlisting role="JAVA">PackageBuilder builder = new PackageBuilder();
builder.addPackageFromDrl( new InputStreamReader( getClass().getResourceAsStream( "package1.drl" ) ) );
builder.addPackageFromXml( new InputStreamReader( getClass().getResourceAsStream( "package2.xml" ) ) );
builder.addRuleFlow( new InputStreamReader( getClass().getResourceAsStream( "ruleflow.rfm" ) ) );
Package pkg = builder.getPackage();      </programlisting>
    </example>

    <para>It is essential that you always check your PackageBuilder for errors
    before attempting to use it. While the ruleBase does throw an
    InvalidRulePackage when a broken Package is added, the detailed error
    information is stripped and only a toString() equivalent is available. If
    you interrogate the PackageBuilder itself much more information is
    available.</para>

    <example>
      <title>Checking the PackageBuilder for errors</title>

      <programlisting role="JAVA">PackageBuilder builder = new PackageBuilder();
builder.addPackageFromDrl( new InputStreamReader( getClass().getResourceAsStream( "package1.drl" ) ) );
PackageBuilderErrors errors = builder.getErrors();</programlisting>
    </example>

    <para>PackageBuilder is configurable by using the PackageBuilderConfiguration
    class.</para>

    <figure>
      <title>PackageBuilderConfiguration</title>
      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/PackageBuilderConfiguration.png"
                     format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The configuration has default values that can be overridden programmatically via
    setters, or on first use via property settings. At the heart of the
    settings is the <code>ChainedProperties</code> class which searches a number of
    locations looking for <code>drools.packagebuilder.conf</code> files; as it finds them
    it adds the properties to the master properties list; this provides a
    level precedence. In order of precedence those locations are: System
    Properties, user defined file in System Properties, user home directory,
    working directory, various <code>META-INF</code> locations. Further to this the
    <code>drools-compiler</code> jar has the default settings in its <code>META-INF</code>
    directory.</para>

    <para>Currently the <code>PackageBuilderConfiguration</code> handles the registry of
    Accumulate functions, the registry of Dialects and the main
    ClassLoader.</para>

    <para>Drools has a pluggable Dialect system, which allows other languages
    to compile and execute expressions and blocks. The two currently
    supported dialects are Java and MVEL. Each has its own
    <code>DialectConfiguration</code> Implementation; the javadocs provide details for each
    setter and getter, and the property names used to configure them.</para>

    <figure>
      <title><code>JavaDialectConfiguration</code></title>

      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/JavaDialectConfiguration.png"
                     format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The <code>JavaDialectConfiguration</code> allows the compiler and language levels
    to be supported. You can override by setting the
    <code>drools.dialect.java.compiler</code> property in a <code>packagebuilder.conf</code> file that
    the <code>ChainedProperties</code> instance will find, or you can do it at runtime as
    shown below.</para>

    <example>
      <title>Configuring the <code>JavaDialectConfiguration</code> to use JANINO via a
      setter</title>

      <programlisting role="JAVA">PackageBuilderConfiguration cfg = new PackageBuilderConfiguration( );
JavaDialectConfiguration javaConf = (JavaDialectConfiguration) cfg.getDialectConfiguration( "java" );
javaConf.setCompiler( JavaDialectConfiguration.JANINO );            </programlisting>
    </example>

    <para>if you do not have Eclipse JDT Core in your classpath you must
    override the compiler setting before you instantiate this <code>PackageBuilder</code>,
    you can either do that with a <code>packagebuilder</code> properties file the
    <code>ChainedProperties</code> class will find, or you can do it programmatically as
    shown below. Note that this time I use properties to inject the value for
    startup.</para>

    <example>
      <title>Configuring the <code>JavaDialectConfiguration</code> to use JANINO</title>

      <programlisting role="JAVA">Properties properties = new Properties();
properties.setProperty( "drools.dialect.java.compiler",
                        "JANINO" );
PackageBuilderConfiguration cfg = new PackageBuilderConfiguration( properties );
JavaDialectConfiguration javaConf = (JavaDialectConfiguration) cfg.getDialectConfiguration( "java" );
assertEquals( JavaDialectConfiguration.JANINO,
              javaConf.getCompiler() ); // demonstrate that the compiler is correctly configured            </programlisting>
    </example>

    <para>Currently it allows alternative compilers (Janino, Eclipse JDT) to
    be specified, different JDK source levels ("1.4" and "1.5") and a parent
    class loader. The default compiler is Eclipse JDT Core at source level
    "1.4" with the parent class loader set to
    <code>Thread.currentThread().getContextClassLoader()</code>.</para>

    <para>The following lines show how to specify the JANINO compiler
    programmatically:</para>

    <example>
      <title>Configuring the <code>PackageBuilder</code> to use JANINO via a
      property</title>

      <programlisting role="JAVA">PackageBuilderConfiguration conf = new PackageBuilderConfiguration();
conf.setCompiler( PackageBuilderConfiguration.JANINO );
PackageBuilder builder = new PackageBuilder( conf );</programlisting>
    </example>

    <para>The <code>MVELDialectConfiguration</code> is much simpler and only allows strict
    mode to be turned on and off. By default strict is true, which means that all
    method calls must be type safe either by inference or by explicit
    typing.</para>

    <figure>
      <title><code>MvelDialectConfiguration</code></title>

      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/MVELDialectConfiguration.png"
                     format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>
  </section>

  <section>
    <title>RuleBase</title>

    <figure>
      <title><code>RuleBaseFactory</code></title>

      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/RuleBaseFactory.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>A <code>RuleBase</code> is instantiated using the <code>RuleBaseFactory</code>, by default
    this returns a ReteOO <code>RuleBase</code>. Packages are added, in turn, using the
    <code>addPackage</code> method. You may specify packages of any namespace, and multiple
    packages of the same namespace may be added.</para>

    <example>
      <title>Adding a Package to a new RuleBase</title>

      <programlisting role="JAVA">RuleBase ruleBase  = RuleBaseFactory.newRuleBase();
ruleBase.addPackage( pkg  );        </programlisting>
    </example>

    <figure>
      <title>RuleBase</title>

      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/RuleBase.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>A <code>RuleBase</code> contains one or more more packages of rules, ready to be
    used, i.e., they have been validated and compiled, etc. A <code>RuleBase</code> is
    serializable so it can be deployed to JNDI or other such services.
    Typically, a rulebase would be generated and cached on first use, to
    avoid the repeated regeneration of the <code>RuleBase</code>, which is
    expensive.</para>

    <para>A <code>RuleBase</code> instance is thread safe, in the sense that you can have
    the one instance shared across threads in your application, which may be a
    web application, for instance. The most common operation on a rulebase is
    to create a new rule session; either stateful or stateless.</para>

    <para>The <code>RuleBase</code> also holds references to any stateful session that it
    has spawned, so that if rules are changing (or being added and removed)
    in a long running session, they can be updated with the latest rules
    without having to restart the session. You can specify not
    to maintain a reference, but only do so if you know the <code>RuleBase</code> will not
    be updated. References are not stored for stateless sessions.</para>

    <programlisting role="JAVA">ruleBase.newStatefulSession();  // maintains a reference.
ruleBase.newStatefulSession( false ); // do not maintain a reference    </programlisting>

    <para>Packages can be added and removed at any time, and all changes will be
    propagated to the existing stateful sessions, but don't forget to call
    <code>fireAllRules()</code> for resulting Activations to fire.</para>

    <programlisting role="JAVA">ruleBase.addPackage( pkg );  // Add a package instance
ruleBase.removePackage( "org.com.sample" );  // remove a package, and all its parts, by its namespace
ruleBase.removeRule( "org.com.sample", "my rule" ); // remove a specific rule from a namespace         </programlisting>

    <para>While there is a method to remove an indivual rule, there is no
    method to add an individual rule. To achieve this, just add a new package
    with a single rule in it.</para>

    <para><code>RuleBaseConfigurator</code> can be used to specify additional behavior of
    the <code>RuleBase</code>. <code>RuleBaseConfiguration</code> is set to immutable after it has been
    added to a <code>RuleBase</code>. Nearly all the engine optimizations can be turned on
    and off from here, and also the execution behavior can be set. Users will
    generally be concerned with insertion behavior (identity or equality) and
    cross product behavior (remove or keep identity equals across
    products).</para>

    <programlisting role="JAVA">RuleBaseConfiguration conf = new RuleBaseConfiguration();
conf.setAssertBehaviour( AssertBehaviour.IDENTITY );
conf.setRemoveIdentities( true );
RuleBase ruleBase = RuleBaseFactory.newRuleBase( conf );</programlisting>

    <figure>
      <title>RuleBaseConfiguration</title>

      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/RuleBaseConfiguration.png"
                     format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>
  </section>

  <section>
    <title>WorkingMemory, Stateful and Stateless Sessions</title>

    <figure>
      <title>WorkingMemory</title>

      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/WorkingMemory.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The Working Memory holds references to all data that has been "inserted" into it and not yet retracted,
                      and it is the place where the interaction with your
    application occurs. Working memories are stateful objects. They may be
    short-lived or long-lived.</para>

    <section>
      <title>Facts</title>

      <para>Facts are objects (beans) from your application that you insert
      into the working memory. Facts are any Java objects which the rules can
      access. The rule engine does not "clone" facts at all, it is all
      references (or pointers) at the end of the day. Facts are the data of your application.
      Strings and other classes without getters and setters are not
      valid Facts and can't be used with Field Constraints which rely on the
      JavaBean standard of getters and setters to interact with the
      object.</para>
    </section>

    <section>
      <title>Insertion</title>

      <para>"Insert" is the act of telling the <code>WorkingMemory</code> about a fact, which you do
      by <code>wm.insert(yourObject)</code>, for example. When you insert a fact, it
      is examined for matches against the rules. This means <emphasis>all</emphasis> of the
      work for deciding about firing or not firing a rule is done during
      insertion; no rule, however, is executed until you
      call <code>fireAllRules()</code>, which you call <code>fireAllRules()</code> after you
      have finished inserting your facts. It is a common misunderstanding for
      people to think the condition evaluation happens when you call <code>fireAllRules()</code>. Expert
      systems typically use the term <code>assert</code> or <code>assertion</code> to refer to facts
      made available to the system. However due to the <code>assert</code> being a keyword
      in most languages we have moved to use the <code>insert</code> keyword; so expect
      to hear the two used interchangeably.</para>

      <!-- FIXME - I think we might want to add this sentence to the previous paragraph.
        However, when the rules are executed, they can assert new objects 
        thus causing new work to be needed. 
      -->

      <para>When an Object is inserted it returns a <code>FactHandle</code>. This <code>FactHandle</code>
      is the token used to represent your inserted object within the
      <code>WorkingMemory</code>. It is also used for interactions with the <code>WorkingMemory</code>
      when you wish to retract or modify an object.</para>

      <programlisting role="JAVA">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = session.insert( stilton );      </programlisting>

      <para>As mentioned in the Rule Base section a Working Memory may operate
      in two assertion modes, i.e., equality or identity, with identity being
      default.</para>

      <para><emphasis>Identity</emphasis> means that the Working Memory uses an <code>IdentityHashMap</code> to store
      all asserted objects. New instance assertions always result in the
      return of a new <code>FactHandle</code>, but if an instance is asserted again then it
      returns the original fact handle, i.e., it ignores repeated insertions
      for the same fact.</para>

      <para><emphasis>Equality</emphasis> means that the Working Memory uses a <code>HashMap</code> to store all
      asserted Objects. New instance assertions will only return a new
      <code>FactHandle</code> if no equal objects have been asserted.</para>
    </section>

    <section>
      <title>Retraction</title>

      <para>"Retraction" is the removal of a fact from the Working Memory,
      which means it will no longer track and match that fact, and any rules
      that are activated and dependent on that fact will be cancelled. Note
      that it is possible to have rules that depend on the nonexistence of
      a fact, in which case retracting a fact may cause a rule to activate
      (see the <code>not</code> and <code>exist</code> keywords). Retraction is done using the
      <code>FactHandle</code> that was returned during the assert.</para>

      <programlisting role="JAVA">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = session.insert( stilton );
...
session.retract( stiltonHandle );            </programlisting>
    </section>

    <section>
      <title>Update</title>

      <para>The Rule Engine must be notified of modified Facts, so that they can
      be reprocessed. Internally, modification is actually a retract and then an
      insert; so it removes the fact from the <code>WorkingMemory</code> and then
      inserts it again. You must use the <code>update</code> method to notify the
      <code>WorkingMemory</code> of changed objects for those objects that are 
      not able to notify the <code>WorkingMemory</code> themselves.
      Notice that <code>update</code> always takes the modified object as a second
      parameter, which allows you to specify new instances for immutable
      objects. The <code>update</code> method can only be used with objects that have
      shadow proxies turned on. If you do not use shadow proxies then you must
      call <code>wm.modifyRetract()</code> before making your changes and
      <code>wm.modifyInsert()</code> after the changes.</para>

      <programlisting role="JAVA">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = workingMemory.insert( stilton );
...
stilton.setPrice( 100 );
workingMemory.update( stiltonHandle, stilton );              </programlisting>
    </section>

    <section>
      <title>Globals</title>

      <para>Globals are named objects that can be passed in to the rule
      engine, without needing to insert them. Most often these are used for
      static information, or for services that are used in the RHS of a rule, or
      perhaps as a means to return objects from the rule engine. If you use a
      global on the LHS of a rule, make sure it is immutable. A global must
      first be declared in a rules file before it can be set on the session.</para>

      <programlisting>global java.util.List list</programlisting>

      <para>With the Rule Base now aware of the global identifier and its type,
      it is now possible to call <code>session.setGlobal</code> for any session.      Failure to declare
      the global type and identifier first will result in an exception being
      thrown. To set the global on the session use <code>session.setGlobal(identifier, value)</code>:</para>

      <programlisting role="JAVA">List list = new ArrayList();
session.setGlobal("list", list);           </programlisting>

      <para>If a rule evaluates on a global before you set it you will get a
      <code>NullPointerException</code>.</para>
    </section>

    <section>
      <title>Shadow Facts</title>

      <para>A shadow fact is a shallow copy of an asserted object. Shadow
      facts are cached copies of objects asserted to the working memory. The
      term "shadow fact" is commonly known as a feature of JESS (Java Expert
      System Shell).</para>

      <para>The origin of shadow facts traces back to the concept of truth
      maintenance. The basic idea is that an expert system should guarantee
      that the derived conclusions are accurate. A running system may alter a fact
      during evaluation. When this occurs, the rule engine must know a
      modification occurred and handle the change appropriately. There's
      generally two ways to guarantee truthfulness. The first is to lock all
      the facts during the inference process. The second is to make a cache
      copy of an object and force all modifications to go through the rule
      engine. This way, the changes are processed in an orderly fashion.
      Shadow facts are particularly important in multi-threaded environments,
      where an engine is shared by multiple sessions. Without truth
      maintenance, a system has a difficult time proving the results are
      accurate. The primary benefit of shadow facts is that they make development
      easier. When developers are forced to keep track of fact modifications,
      it can lead to errors which are difficult to debug. Building a
      moderately complex system using a rule engine is hard enough without
      adding the burden of tracking changes to facts and when they should
      notify the rule engine.</para>

      <para>Drools 4.0 has full support for Shadow Facts implemented as
      transparent lazy proxies. Shadow facts are enable by default and are not
      visible from external code, not even inside code blocks on rules.</para>

      <important><para>Since Drools
      implements Shadow Facts as Proxies, the fact classes must <emphasis>either be immutable</emphasis> or <emphasis>should not be final</emphasis>, nor have final methods. If a
      fact class is final or has final methods and is still a mutable class,
      the engine is not able to create a proper shadow fact for it which results
      in unpredictable behavior.</para></important> 

      <para>Although shadow facts are a great way of ensuring the engine's
      integrity, they add some overhead to the the reasoning process. Therefore,
      Drools 4.0 supports fine-grained control over them with the ability to
      enable or disable them for each individual class. </para>

       <section>
        <title>When is it possible to disable Shadow Facts?</title>

        <para>It is possible to disable shadow facts for your classes if you
        meet the following requirements:

        <orderedlist>

        <listitem><para><emphasis role="bold">Immutable classes are safe.</emphasis>
        If a class is immutable it does not require shadow facts. Just to
        clarify, a class is immutable from the engine perspective if once an
        instance is asserted into the working memory, no attribute will change
        until it is retracted.</para></listitem>

        <listitem>
        <para><emphasis role="bold">Inside your rules, attributes are only
        changed using modify() blocks.</emphasis> Both Drools dialects (MVEL
        and Java) have the modify block construct. If all attribute value
        changes for a given class happen inside modify() blocks, you can
        disable shadow facts for that class.</para>
        <example>
          <title>modify() block using Java dialect</title>

          <programlisting>rule "Eat Cheese"
when
  $p: Person( status == "hungry" )
  $c: Cheese( )
then
  retract( $c );
  modify( $p ) {
      setStatus( "full" ),
      setAge( $p.getAge() + 1 )
  }
end</programlisting>
        </example>

        <example>
          <title>modify() block using MVEL dialect</title>

          <programlisting>rule "Eat Cheese"
  dialect "mvel"
when
  $p: Person( status == "hungry" )
  $c: Cheese( )
then
  retract( $c );
  modify( $p ) {
      status = "full",
      age = $p.age + 1
  }
end</programlisting>
        </example>
        </listitem>
        <listitem><para><emphasis role="bold">In your application, attributes are
        only changed between calls to modifyRetract() and
        modifyInsert().</emphasis> This way, the engine becomes aware that
        attributes will be changed and can prepare itself for them.</para>
        <example>
          <title>Safely modifying attributes in the application
          code</title>
          <programlisting role="JAVA">         // create session
         StatefulSession session = ruleBase.newStatefulSession();

         // get facts
         Person person = new Person( "Bob", 30 );
         person.setLikes( "cheese" );

         // insert facts
         FactHandle handle = session.insert( person );

         // do application stuff and/or fire rules
         session.fireAllRules();

         // wants to change attributes?
         session.modifyRetract( handle ); // call modifyRetract() before doing changes
         person.setAge( 31 );
         person.setLikes( "chocolate" );
         session.modifyInsert( handle, person ); // call modifyInsert() after the changes
</programlisting>
        </example></listitem>
        </orderedlist></para>
      </section>

      <section>
        <title>How to disable Shadow Facts</title>

        <para>To disable shadow facts for all classes set the following
        property in a configuration file of system property:</para>

        <programlisting>drools.shadowProxy = false</programlisting>

        <para>Alternatively, it is possible to disable shadow facts through an API
        call:</para>

        <programlisting role="JAVA">RuleBaseConfiguration conf = new RuleBaseConfiguration();
conf.setShadowProxy( false );
...
RuleBase ruleBase = RuleBaseFactory.newRuleBase( conf );
</programlisting>

        <para>To disable the shadow proxy for a list of classes only, use the
        following property instead, or the equivalent API:</para>

        <programlisting>drools.shadowproxy.exclude = org.domainy.* org.domainx.ClassZ</programlisting>

        <para>As shown above, a space separated list is used to specify more
        than one class, and '*' is used as a wild card.</para>
      </section>
    </section>

    <section>
      <title>Property Change Listener</title>

      <para>If your fact objects are Java Beans, you can implement a property
      change listener for them, and then tell the rule engine about it. This
      means that the engine will automatically know when a fact has changed,
      and behave accordingly, without you having to tell it that the fact is modified.
      There are proxy libraries that can help automate this. (A future version
      of Drools will bundle some to make it easier.) To use an object in
      dynamic mode specify true for the second assertObject parameter.</para>

      <programlisting role="JAVA">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = workingMemory.insert( stilton, true );  //specifies that this is a dynamic fact            </programlisting>

      <para>To make a JavaBean dynamic add a <code>PropertyChangeSupport</code> field
      along with an add and a remove method, and make sure that each setter
      calls the <code>PropertyChangeSupport</code> instance with
      <code>firePropertyChange</code>.</para>

      <programlisting role="JAVA">private final PropertyChangeSupport changes = new PropertyChangeSupport( this );
...
public void addPropertyChangeListener(final PropertyChangeListener l) {
    this.changes.addPropertyChangeListener( l );
}

public void removePropertyChangeListener(final PropertyChangeListener l) {
    this.changes.removePropertyChangeListener( l );
}
...

public void setState(final String newState) {
    String oldState = this.state;
    this.state = newState;
    this.changes.firePropertyChange( "state",
                                      oldState,
                                      newState );
}              </programlisting>
    </section>

    <section>
      <title>Initial Fact</title>

      <para>To support conditional elements like <code>not</code> (which will be covered
      later on), there is a need to "seed" the engine with something known as
      the "Initial Fact". This fact is a special fact that is not intended to
      be seen by the user.</para>

      <para>On the first working memory action (<code>assert</code>, <code>fireAllRules</code>) on a
      fresh working memory, the Initial Fact will be propagated through the
      RETE network. This lets you write rules that have an empty LHS, or do not use
      normal facts, such as rules that use <code>from</code> to pull data from an
      external source. For instance, if a new working memory is created, and
      no facts are asserted, calling the <code>fireAllRules</code> will cause the Initial
      Fact to propagate, possibly activating rules. If there were not even an
      initial fact, nothing at all would happen.</para>
    </section>
  </section>

  <section>
    <title>StatefulSession</title>

    <figure>
      <title>StatefulSession</title>

      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/StatefulSession.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The <code>StatefulSession</code> extends the <code>WorkingMemory</code> class. It simply adds
    async methods and a <code>dispose()</code> method. The <code>RuleBase</code> retains a reference to
    each <code>StatefulSession</code> it creates, so that it can update them when new rules
    are added. Thus, <code>dispose()</code> is needed to release the <code>StatefulSession</code> reference
    from the <code>RuleBase</code>, because without it you can get memory leaks.</para>

    <example>
      <title>Creating a <code>StatefulSession</code></title>
      <programlisting role="JAVA">StatefulSession session = ruleBase.newStatefulSession();</programlisting>
    </example>
  </section>

  <section>
    <title>Stateless Session</title>

    <figure>
      <title>StatelessSession</title>
      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/StatelessSession.png"
                     format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The <code>StatelessSession</code> wraps the <code>WorkingMemory</code>, instead of extending
    it. Its main focus is on decision service type scenarios.</para>

    <example>
      <title>Creating a <code>StatelessSession</code></title>
      <programlisting role="JAVA">StatelessSession session = ruleBase.newStatelessSession();
session.execute( new Cheese( "cheddar" ) );</programlisting>
    </example>

    <para>The API is reduced to the problem domain and is thus much simpler.
    This, in turn, can make maintenance of those services easier. The <code>RuleBase</code>
    never retains a reference to the <code>StatelessSession</code>, thus <code>dispose()</code> is not
    needed. The class only has an overloaded set of <code>execute()</code>
    methods, accepting either a single object, an  array of objects or a 
    collection of objects, but there are no <code>insert</code> and
    <code>fireAllRules</code> methods. The <code>execute()</code> method 
    iterates over the objects, inserting each into the 
    <code>WorkingMemory</code>, and calls <code>fireAllRules()</code> at the 
    end, after which the session is finished.  Should the session
    need access to any result information you can use the <code>executeWithResults</code>
    method, which returns a <code>StatelessSessionResult</code>. The reason for this is in
    remote situations where you do not always want the return payload, so this way
    it is optional.</para>

    <para><code>setAgendaFilter</code>, <code>setGlobal</code> and <code>setGlobalResolver</code> share their state
    across sessions; so each call to <code>execute()</code> will use the set <code>AgendaFilter</code>,
    see any previously set globals, etc.</para>

    <para><code>StatelessSession</code>s do not currently support
    <code>PropertyChangeListener</code>s.</para>

    <para>Async versions of the <code>execute</code> method are supported. Remember to
    override the <code>ExecutorService</code> implementation when in special managed thread
    environments such as JEE.</para>

    <para><code>StatelessSession</code>s also supports sequential mode, which is a special
    optimized mode that uses less memory and executes faster; please see the
    <link xlink:href="#sequential">Sequential</link> section for more details.</para>

    <figure>
      <title>StatelessSessionResult</title>

      <mediaobject>

        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/StatelessSessionResult.png"
                     format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para><code>StatelessSession.executeWithResults()</code> returns an
    object from a class providing a minimal API to
    examine the session's data. You may iterate over inserted objects,
    execute queries and retrieve globals. Once the
    <code>StatelessSessionResult</code> is serialized it loses the reference to the
    underlying <code>WorkingMemory</code> and <code>RuleBase</code>, so queries can no longer be
    executed; it is, however, still possible to retrieve globals and ti
    iterate over objects. To
    retrieve globals they must be exported from the <code>StatelessSession</code>; the
    <code>GlobalExporter</code> strategy is set with <code>StatelessSession.setGlobalExporter(
    GlobalExporter globalExporter )</code>. Two implementations of <code>GlobalExporter</code> are
    available, and users may implement their own strategies.
    <code>CopyIdentifiersGlobalExporter</code> copies named identifiers into a new
    <code>GlobalResolver</code> that is passed to the <code>StatelessSessionResult</code>; its
    constructor takes a <code>String</code> array of identifiers, but if no identifiers are
    specified it copies all identifiers declared in the <code>RuleBase</code>.
    <code>ReferenceOriginalGlobalExporter</code> just passes a reference to the original
    <code>GlobalResolver</code>. The latter should be used with care as identifier
    instances can be changed at any time by the <code>StatelessSession</code> and the
    <code>GlobalResolver</code> may not be serializable-friendly.</para>

    <example>
      <title><code>GlobalExporter</code> with <code>StatelessSession</code>s</title>

      <programlisting role="JAVA">StatelessSession session = ruleBase.newStatelessSession();
session.setGlobalExporter( new CopyIdentifiersGlobalExporter( new String[]{"list"} ) );
StatelessSessionResult result = session.executeWithResults( new Cheese( "stilton" ) );
List list = ( List ) result.getGlobal( "list" );</programlisting>
    </example>
  </section>

  <section>
    <title>Agenda</title>

    <figure>
      <title>Agenda</title>

      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/Agenda.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The Agenda is a RETE feature. During actions on the <code>WorkingMemory</code>,
    rules
    may become fully matched and eligible for execution; a single Working
    Memory Action can result in multiple eligible rules. When a rule is fully
    matched an Activation is created, referencing the rule and the matched
    facts, and placed onto the Agenda. The Agenda controls the execution order
    of these Activations using a Conflict Resolution strategy.</para>

    <para>The engine cycles repeatedly through two phases:</para>

    <orderedlist>
      <listitem>
        <para>Working Memory Actions. This is where most of the work takes
        place, either in the <code>Consequence</code> (the RHS itself) or the main Java
        application process. Once the <code>Consequence</code> has finished or the main Java
        application process calls <code>fireAllRules()</code> the engine switches to the
        Agenda Evaluation phase.</para>
      </listitem>

      <listitem>
        <para>Agenda Evaluation. This attempts to select a rule to fire. If no rule
        is found it exits, otherwise it fires the found rule,
        switching the phase back to Working Memory Actions.</para>
      </listitem>
    </orderedlist>

    <figure>
      <title>Two Phase Execution</title>

      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/Two_Phase.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The process repeats until the agenda is clear, in which case
    control returns to the calling application. When Working Memory Actions
    are taking place, no rules are being fired.</para>

    <section>
      <title>Conflict Resolution</title>

      <para>Conflict resolution is required when there are multiple rules on
      the agenda. As firing a rule may have side effects on working memory,
      the rule engine needs to know in what order the rules should fire (for
      instance, firing ruleA may cause ruleB to be removed from the
      agenda).</para>

      <para>The default conflict resolution strategies employed by Drools are:
      Salience and LIFO (last in, first out).</para>

      <para>The most visible one is "salience" or priority, in which case a
      user can specify that a certain rule has a higher priority (by giving it
      a higher number) than other rules. In that case, the rule with higher salience
      will be preferred. LIFO priorities are based on the assigned
      Working Memory Action counter value, with all rules created during the
      same action receiving the same value. The execution order of a set
      of firings with the same priority value is arbitrary.</para>

      <para>As a general rule, it is a good idea not to count on the rules
      firing in any particular order, and to author the rules without
      worrying about a "flow".</para>

      <para>Custom conflict resolution strategies can be specified by setting
      the Class in the <code>RuleBaseConfiguration</code> method <code>setConflictResolver</code>, or
      by using the property <code>drools.conflictResolver</code>.</para>
    </section>

    <section>
      <title>Agenda Groups</title>

      <para>Agenda groups are a way to partition rules (activations, actually)
      on the agenda. At any one time, only one group has "focus" which means
      that activations for rules in that group only will take effect. You
      can also have rules with "auto focus" which means that the focus is
      taken for its agenda group when that rule's conditions are true.</para>

      <para>Agenda groups are known as "modules" in CLIPS terminology. They
      provide a handy way to create a "flow" between grouped rules. You can
      switch the group which has focus either from within the rule engine, or
      via the API. If your rules have a clear need for multiple "phases" or
      "sequences" of processing, consider using agenda-groups for this
      purpose.</para>

      <para>Each time <code>setFocus()</code> is called it pushes that Agenda Group onto
      a stack. When the focus group is empty it is popped from the stack and the
      focus group that is now on top evaluates. An Agenda Group can
      appear in multiple locations
      on the stack. The default Agenda Group is "MAIN", with all rules which do not
      specify an Agenda Group being in this group. It is also always the first
      group on the stack, given focus initially, by default.</para>
    </section>

    <section>
      <title>Agenda Filters</title>

      <figure>
        <title>AgendaFilters</title>
        <mediaobject>
          <imageobject>
		  <imagedata align="center" fileref="images/Chapter-Rule_Engine/AgendaFilter.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Filters are optional implementations of the filter interface
      which are used to allow or deny the firing of an activation. What you
      filter on is entirely up to the implementation. Drools provides the
      following convenience default implementations, all of which may be
      used for allowing and denying. By default, they accept rules where
      the name, or part of it, matches the first constructor parameter.</para>

      <itemizedlist>
        <listitem>
          <para><code>RuleNameEndsWithAgendaFilter</code></para>
        </listitem>

        <listitem>
          <para><code>RuleNameEqualsAgendaFilter</code></para>
        </listitem>

        <listitem>
          <para><code>RuleNameStartsWithAgendaFilter</code></para>
        </listitem>

        <listitem>
          <para><code>RuleNameMatchesAgendaFilter</code></para>
        </listitem>
      </itemizedlist>

      <para>To use a filter specify it while calling <code>FireAllRules</code>. The
      following example permits only rules ending in the string <emphasis>Test</emphasis>.
      All others will be filtered out.</para>
      <programlisting role="JAVA">workingMemory.fireAllRules( new RuleNameEndsWithAgendaFilter( "Test" ) );</programlisting>
    </section>
  </section>

  <section>
    <title>Truth Maintenance with <indexterm>
        <primary>Logical Object</primary>
      </indexterm> Logical Objects</title>

    <para>After regular inserts you have to retract facts explicitly. With
    <emphasis>logical</emphasis> assertions, the fact that was asserted will
    be automatically
    retracted when the conditions that asserted it in the first place are no
    longer true. Actually, it's even cleverer then that, because it will be
    retracted only if there isn't any single condition that supports the
    logical assertion.</para>

    <para>Normal insertions are said to be <emphasis>stated</emphasis>, i.e.,
    just like the intuitive meaning of "stating a fact" implies. Using a
    <code>HashMap</code> and a counter, we track how many times a particular
    equality is <emphasis>stated</emphasis>; this means we count how many
    different instances are equal.</para>

    <para>When we <emphasis>logically</emphasis> insert an object during a
    RHS execution we are said to <emphasis>justify</emphasis> it, and it is 
    considered to be justified by the firing rule. For each logical insertion
    there can only be one equal object, and each
    subsequent equal logical insertion increases the justification counter for
    this logical assertion. A justification is removed by the LHS of the
    creating rule becoming untrue, and the counter is decreased accordingly.
    As soon as we have no more justifications the logical object is
    automatically retracted.</para>

    <para>If we try to <emphasis>logically</emphasis> insert an object when
    there is an equal <emphasis>stated</emphasis> object, this will fail and
    return null. If  we <emphasis>state</emphasis> an object that has an
    existing equal object that is <emphasis>justified</emphasis> we override
    the Fact; how this override works depends on the configuration setting
    <code>WM_BEHAVIOR_PRESERVE</code>. When the property is set to discard we use the
    existing handle and replace the existing instance with the new Object,
    which is the default behavior; otherwise we override it to
    <emphasis>stated</emphasis> but we create an new <code>FactHandle</code>.</para>

    <para>This can be confusing on a first read, so hopefully the flow charts
    below help. When it says that it returns a new <code>FactHandle</code>, this also
    indicates the <code>Object</code> was propagated through the network.

    <figure>
      <title>Stated Insertion</title>
      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/Stated_Assertion.png"
                     format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <figure>
      <title>Logical Insertion</title>
      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/Logical_Assertion.png"
                     format="PNG" />
        </imageobject>
      </mediaobject>
    </figure></para>

    <section>
      <title>Example Scenario</title>

      <para>An example may make things clearer. Imagine a credit card
      processing application, processing transactions for a given account and
      we have a working memory accumulating knowledge about a single account
      transaction. The rule engine is doing its best to decide whether
      transactions are possibly fraudulent or not. Imagine that this rule base
      basically has rules that kick in when there is "reason to be suspicious"
      and when "everything is normal".</para>

      <para>Of course there are many rules that operate no matter what,
      performing standard calculations, etc.  Now there are possibly many
      reasons as to what could trigger a "reason to be suspicious": someone
      notifying the bank, a sequence of large transactions, transactions for
      geographically disparate locations, or even reports of credit card theft.
      Rather then smattering all the little conditions in lots of rules,
      imagine there is a fact class called "SuspiciousAccount".</para>

      <para>Then there can be a series of rules whose job is to look for
      things that may raise suspicion, and if they fire, they
      <emphasis>logically</emphasis> insert a
      new SuspiciousAccount() instance. All the other rules just have
      conditions like "not SuspiciousAccount()" or "SuspiciousAccount()"
      depending on their needs. Note that this has the advantage of allowing
      there to be many rules around raising suspicion, without touching the
      other rules. After all the facts causing the SuspiciousAccount()
      insertion are removed, the account handling reverts to a normal
      mode of operation where, for instance, a rule with 
      "not SuspiciousAccount()" may kick in, which flushes through any
      blocked transactions.</para>

      <para>If you have followed this far, you will note that truth
      maintenance, like logical assertions, allows rules to behave a little
      like a human would, and can certainly make the rules more
      manageable.</para>
    </section>

    <section>
      <title>Important note: Equality for Java objects</title>

      <para>It is important to note that for Truth Maintenance (and logical
      assertions) to work at all, your Fact objects (which may be JavaBeans)
      must override equals and hashCode methods (from java.lang.Object) correctly.
      As the truth maintenance system needs to know when two different physical
      objects are equal in value, 
      <emphasis>both</emphasis> equals and hashCode must be overridden
      correctly, as per the Java standard.</para>

      <para>Two objects are equal if and only if their equals methods return
      true for each other and if their hashCode methods return the same
      values. See the Java API for more details (but do keep in mind you
      <emphasis>MUST</emphasis> override both equals and hashCode).</para>
    </section>
  </section>

  <section>
    <title>Event Model</title>

    <para>The event package provides means to be notified of rule engine
    events, including rules firing, objects being asserted, etc. This allows
    you, for instance, to separate logging and auditing activities from the 
    main part of your application (and the rules).</para>

    <para><code>WorkingMemoryEventListener</code>,
    <code>AgendaEventListener</code> and <code>RuleFlowEventListener</code>
    represent the three types of event listeners:</para>

    <figure>
      <title>WorkingMemoryEventListener</title>

      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/WorkingMemoryEventListener.png"
                     format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <figure>
      <title>AgendaEventListener</title>

      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/AgendaEventListener.png"
                     format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <figure>
      <title>RuleFlowEventListener</title>

      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/RuleFlowEventListener.png"
                     format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Both stateful and stateless sessions implement the EventManager
    interface, which allows event listeners to be added to the session.</para>

    <figure>
      <title>EventManager</title>

      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Engine/EventManager.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>All EventListeners have default implementations that implement each
    method, but do nothing; these are convienience classes that you can
    inherit from to avoid having to implement each method. The default classes
    are <code>DefaultAgendaEventListener</code>,
    <code>DefaultWorkingMemoryEventListener</code> and
    <code>DefaultRuleFlowEventListener</code>. The following code snippet
    shows how to extend <code>DefaultAgendaEventListener</code> and add an
    instance to the session. It prints events resulting from rules being 
    fired.</para>

    <programlisting role="JAVA">session.addEventListener( new DefaultAgendaEventListener() {
   public void afterActivationFired(AfterActivationFiredEvent event) {
       super.afterActivationFired( event );
       System.out.println( event );
   }
});       </programlisting>

    <para>Drools also provides <code>DebugWorkingMemoryEventListener</code>,
    <code>DebugAgendaEventListener</code> and
    <code>DebugRuleFlowEventListener</code> which implement
    each method with a debug print statement. To print all Working
    Memory events, you add a listener like this:</para>

    <programlisting role="JAVA">session.addEventListener( new DebugWorkingMemoryEventListener() );        </programlisting>

    <para>The Eclipse-based Rule IDE also provides an audit logger and
    graphical viewer, so that the rule engine can log events for later
    viewing, and auditing.</para>
  </section>

  <section>
    <title><link linkend="sequential">Sequential Mode</link></title>

    <para>With Rete you have a stateful session where objects can be asserted
    and modified over time, and where rules can also be added and removed.
    Now what
    happens if we assume a stateless session, where after the initial data set
    no more data can be asserted or modified and rules cannot be added or
    removed? Certainly it won't be necessary to re-evaluate rules,
    and the engine will be able to operate in a simplified way.</para>

    <orderedlist>
      <listitem>
        <para>Order the Rules by salience and position in the ruleset (by
        setting a sequence attribute on the rule terminal node).</para>
      </listitem>

      <listitem>
        <para>Create an array, one element for each possible rule activation;
        element position indicates firing order.</para>
      </listitem>

      <listitem>
        <para>Turn off all node memories, except the right-input Object
        memory.</para>
      </listitem>

      <listitem>
        <para>Disconnect the LeftInputAdapterNode propagation, and let the
        Object plus the Node be referenced in a Command object, which is added to
        a list on the WorkingMemory for later execution.</para>
      </listitem>

      <listitem>
        <para>Assert all objects, and, when all assertions are finished and thus
        right-input node memories are populated, check the Command list and
        execute each in turn.</para>
      </listitem>

      <listitem>
        <para>All resulting Activations should be placed in the array, based
        upon the determined sequence number of the Rule. Record the first and
        last populated elements, to reduce the iteration range.</para>
      </listitem>

      <listitem>
        <para>Iterate the array of Activations, executing populated element in
        turn.</para>
      </listitem>

      <listitem>
        <para>If we have a maximum number of allowed rule executions, we can
        exit our network evaluations early to fire all the rules in the
        array.</para>
      </listitem>
    </orderedlist>

    <para>The LeftInputAdapterNode no longer creates a Tuple, adding the
    Object, and then propagate the Tuple  instead a Command Object is created
    and added to a list in the Working Memory. This Command Object holds a
    reference to the LeftInputAdapterNode and the propagated Object. This
    stops any left-input propagations at insertion time, so that we know that
    a right-input propagation will never need to attempt a join with the
    left-inputs (removing the need for left-input memory). All nodes have
    their memory turned off, including the left-input Tuple memory but
    excluding the right-input Object memory, which means that the only node
    remembering an insertion propagation is the right-input Object memory. Once
    all the assertions are finished and all right-input memories populated,
    we can then iterate the list of LeftInputAdatperNode Command objects
    calling each in turn; they will propagate down the network attempting to
    join with the right-input objects; not being remembered in the left input,
    as we know there will be no further object assertions and thus
    propagations into the right-input memory.</para>

    <para>There is no longer an Agenda, with a priority queue to schedule the
    Tuples, instead there is simply an array for the number of rules. The
    sequence number of the RuleTerminalNode indicates the element with the
    array to place the Activation. Once all Command Objects have finished we
    can iterate our array checking each element in turn and firing the
    Activations if they exist. To improve performance in the array we remember
    the first and last populated cells. The network is constructed
    where each RuleTerminalNode is given a sequence number, based on a
    salience number and its order of being added to the network.</para>

    <para>Typically the right-input node memories are HashMaps, for fast
    Object retraction; here, as we know there will be no Object retractions,
    we can
    use a list when the values of the Object are not indexed. For larger
    numbers of Objects indexed HashMaps provide a performance increase; if we
    know an Object type has a low number of instances then indexing is
    probably not of an advantage and an Object list can be used.</para>

    <para>Sequential mode can only be used with a StatelessSession and is off
    by default. To turn on either set the RuleBaseConfiguration.setSequential
    to true or set the rulebase.conf property drools.sequential to true.
    Sequential mode can fall back to a dynamic agenda with setSequentialAgenda
    to either SequentialAgenda.SEQUENTIAL or SequentialAgenda.DYNAMIC
    set by a call or via the "drools.sequential.agenda" property.</para>
  </section>
</section>
