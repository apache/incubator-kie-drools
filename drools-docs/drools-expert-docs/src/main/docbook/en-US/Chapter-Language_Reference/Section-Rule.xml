<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="../" xmlns="http://docbook.org/ns/docbook" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:ns="http://docbook.org/ns/docbook">
  <title>Rule</title>

  <figure>
    <title>rule</title>

    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="images/Chapter-Rule_Language/rule.png" format="PNG" role=""></imagedata>
      </imageobject>
    </mediaobject>
  </figure>

  <para>A rule specifies that <emphasis>when</emphasis> a particular set of conditions occur, specified in the Left Hand
  Side (LHS), <emphasis>then</emphasis> do what is specified as a list of actions in the Right Hand Side (RHS). A common
  question from users is "Why use when instead of if?" "When" was chosen over "if" because "if" is normally part of a
  procedural execution flow, where, at a specific point in time, a condition is to be checked. In contrast, "when"
  indicates that the condition evaluation is not tied to a specific evaluation sequence or point in time, but that it
  happens continually, at any time during the life time of the engine; whenever the condition is met, the actions are
  executed.</para>

  <para>A rule must have a name, unique within its rule package. If you define a rule twice in the same DRL it produces
  an error while loading. If you add a DRL that includes a rule name already in the package, it replaces the previous
  rule. If a rule name is to have spaces, then it will need to be enclosed in double quotes (it is best to always use
  double quotes).</para>

  <para>Attributes - described below - are optional. They are best written one per line.</para>

  <para>The LHS of the rule follows the <literal>when</literal> keyword (ideally on a new line), similarly the RHS
  follows the <literal>then</literal> keyword (again, ideally on a newline). The rule is terminated by the keyword
  <literal>end</literal>. Rules cannot be nested.</para>

  <example>
    <title>Rule Syntax Overview</title>

    <programlisting>rule "&lt;name&gt;"
    &lt;attribute&gt;*
when
    &lt;conditional element&gt;*
then
    &lt;action&gt;*
end</programlisting>
  </example>

  <example>
    <title>A simple rule</title>

    <programlisting>rule "Approve if not rejected"
  salience -100 
  agenda-group "approval"
    when
        not Rejection() 
        p : Policy(approved == false, policyState:status)
        exists Driver(age &gt; 25)
        Process(status == policyState)
    then
        log("APPROVED: due to no objections."); 
        p.setApproved(true);
end</programlisting>
  </example>

  <section>
    <title>Rule Attributes</title>

    <para>Rule attributes provide a declarative way to influence the behavior of the rule. Some are quite simple, while
    others are part of complex subsystems such as ruleflow. To get the most from Drools you should make sure you have a
    proper understanding of each attribute.</para>

    <figure>
      <title>rule attributes</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="images/Chapter-Rule_Language/rule_attributes.png" format="PNG"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <variablelist>
      <varlistentry>
        <term><literal>no-loop</literal></term>

        <listitem>
          <para>default value: false</para>

          <para>type: Boolean</para>

          <para>When a rule's consequence modifies a fact it may cause the
          rule to activate again, causing an infinite loop. Setting no-loop
          to true will skip the creation of another Activation for the rule
          with the current set of facts.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>ruleflow-group</literal></term>

        <listitem>
          <para>default value: N/A</para>

          <para>type: String</para>

          <para>Ruleflow is a Drools feature that lets you exercise control over the firing of rules. Rules that are
          assembled by the same ruleflow-group identifier fire only when their group is active.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>lock-on-active</literal></term>

        <listitem>
          <para>default value: false</para>

          <para>type: Boolean</para>

          <para>Whenever a ruleflow-group becomes active or an agenda-group receives the focus, any rule within that
          group that has lock-on-active set to true will not be activated any more; irrespective of the origin of the
          update, the activation of a matching rule is discarded. This is a stronger version of no-loop, because the
          change could now be caused not only by the rule itself. It's ideal for calculation rules where you have a
          number of rules that modify a fact and you don't want any rule re-matching and firing again. Only when the
          ruleflow-group is no longer active or the agenda-group loses the focus those rules with lock-on-active set to
          true become eligible again for their activations to be placed onto the agenda.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>salience</literal></term>

        <listitem>
          <para>default value: 0</para>

          <para>type: integer</para>

          <para>Each rule has an integer salience attribute which defaults
          to zero and can be negative or positive. Salience is a form of
          priority where rules with higher
          salience values are given higher priority when ordered in the
          Activation queue.</para>
          <para>Drools also supports dynamic salience where you can use
          an expression involving bound variables.</para>
          
          <example>
            <title>Dynamic Salience</title>

            <programlisting>rule "Fire in rank order 1,2,.."
          salience( -$rank )
          when
              Element( $rank : rank,... )
          then
              ...
        end</programlisting>
          </example>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>agenda-group</literal></term>

        <listitem>
          <para>default value: MAIN</para>

          <para>type: String</para>

          <para>Agenda groups allow the user to partition the Agenda providing more execution control. Only rules in the
          agenda group that has acquired the focus are allowed to fire.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>auto-focus</literal></term>

        <listitem>
          <para>default value: false</para>

          <para>type: Boolean</para>

          <para>When a rule is activated where the <code>auto-focus</code> value is true and the rule's agenda group
          does not have focus yet, then it is given focus, allowing the rule to potentially fire.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>activation-group</literal></term>

        <listitem>
          <para>default value: N/A</para>

          <para>type: String</para>

          <para>Rules that belong to the same activation-group, identified by this attribute's string value, will only
          fire exclusively. In other words, the first rule in an activation-group to fire will cancel the other rules'
          activations, i.e., stop them from firing.</para>

          <para>Note: This used to be called Xor group, but technically it's not quite an Xor. You may still hear people
          mention Xor group; just swap that term in your mind with activation-group.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>dialect</literal></term>

        <listitem>
          <para>default value: as specified by the package</para>

          <para>type: String</para>

          <para>possible values: "java" or "mvel"</para>

          <para>The dialect species the language to be used for any code expressions in the LHS or the RHS code block.
          Currently two dialects are available, Java and MVEL. While the dialect can be specified at the package level,
          this attribute allows the package definition to be overridden for a rule.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>date-effective</literal></term>

        <listitem>
          <para>default value: N/A</para>

          <para>type: String, containing a date and time definition</para>

          <para>A rule can only activate if the current date and time is after date-effective attribute.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>date-expires</literal></term>

        <listitem>
          <para>default value: N/A</para>

          <para>type: String, containing a date and time definition</para>

          <para>A rule cannot activate if the current date and time is after the date-expires attribute.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>duration</literal></term>

        <listitem>
          <para>default value: no default value</para>

          <para>type: long</para>

          <para>The duration dictates that the rule will fire after a specified duration, if it is still true.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <example>
      <title>Some attribute examples</title>

      <programlisting>rule "my rule"
  salience 42
  agenda-group "number 1"
    when ...
</programlisting>
    </example>
  </section>

  <section>
    <title>Timers and Calendars</title>

    <para>Rules now suport both interval and cron based timers, which replace
    the now deprecated duration attribute.</para>

    <example>
      <title>Sample timer attribute uses</title>

      <programlisting language="java">timer ( int: &lt;initial delay&gt; &lt;repeat interval&gt;? )
timer ( int: 30s )
timer ( int: 30s 5m )
 
timer ( cron: &lt;cron expression&gt; )
timer ( cron:* 0/15 * * * ? )</programlisting>
    </example>

    <para>Interval (indicated by "int:") timers follow the semantics
    of java.util.Timer objects, with an initial delay and an optional
    repeat interval. Cron (indicated by "cron:") timers follow
    standard Unix cron expressions:</para>

    <example>
      <title>A Cron Example</title>

      <programlisting language="java">rule "Send SMS every 15 minutes"
    timer (cron:* 0/15 * * * ?)
when
    $a : Alarm( on == true )
then
    channels[ "sms" ].insert( new Sms( $a.mobileNumber, "The alarm is still on" );
end</programlisting>
    </example>

    <para>Calendars are used to control when rules can fire. The Calendar API is
    modelled on <link xlink:href="http://www.quartz-scheduler.org/">Quartz
    http://www.quartz-scheduler.org/</link> :</para>

    <example>
      <title>Adapting a Quartz Calendar</title>

      <programlisting language="java">Calendar weekDayCal = QuartzHelper.quartzCalendarAdapter(org.quartz.Calendar quartzCal)</programlisting>
    </example>

    <para>Calendars are registered with the StatefulKnowledgeSession:</para>

    <example>
      <title>Registering a Calendar</title>

      <programlisting language="java">ksession.getCalendars().set( "weekday", weekDayCal );</programlisting>
    </example>

    <para>They can be used in conjunction with normal rules and rules
    including timers. The rule attribute "calendars" may contain one or
    more comma-separated calendar names written as string literals.</para>

    <example>
      <title>Using Calendars and Timers together</title>

      <programlisting language="java">rule "weekdays are high priority"
   calendars "weekday"
   timer (int:0 1h)
when 
    Alarm()
then
    send( "priority high - we have an alarm” );
end 

rule "weekend are low priority"
   calendars "weekend"
   timer (int:0 4h)
when 
    Alarm()
then
    send( "priority low - we have an alarm” );
end</programlisting>
    </example>
  </section>

  <section>
    <title>Left Hand Side (when) Conditional Elements</title>

    <para>The Left Hand Side (LHS) is a common name for the conditional part of the rule. It consists of zero or more
    Conditional Elements. If the LHS is left empty, it is re-written as <code>eval(true)</code>, which means that the
    rule's condition is always true. It will be activated, once, when a new Working Memory session is created.</para>

    <figure>
      <title>Left Hand Side</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="images/Chapter-Rule_Language/lhs.png" format="PNG" role="" />
        </imageobject>
      </mediaobject>
    </figure>

    <example>
      <title>Rule without a Conditional Element</title>

      <programlisting>rule "no CEs"
when
then
    &lt;action&gt;*
end

# The above rule is internally rewritten as:

rule "eval(true)"
when
    eval( true )
then
    &lt;action&gt;*
end</programlisting>
    </example>

    <para>Conditional elements work on one or more <emphasis>patterns</emphasis> (which are described below). The most
    common one is <literal>and</literal>, which is implicit when you have multiple patterns in the LHS of a rule that
    are not connected in any way. Note that an <literal>and</literal> cannot have a leading declaration binding like
    <literal>or</literal>. This is obvious, since a declaration can only reference a single fact, and when the
    <literal>and</literal> is satisfied it matches more than one fact - so which fact would the declaration bind
    to?</para>

    <section>
      <title>Pattern</title>

      <para>The pattern element is the most important Conditional Element. The entity relationship diagram below
      provides an overview of the various parts that make up the pattern's constraints and how they work together; each
      is then covered in more detail with railroad diagrams and examples.</para>

      <figure>
        <title>Pattern Entity Relationship Diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/Chapter-Rule_Language/patternER.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>At the top of the ER diagram you can see that the pattern consists of zero or more constraints and has an
      optional pattern binding. The railroad diagram below shows the syntax for this.</para>

      <figure>
        <title>Pattern</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/Chapter-Rule_Language/pattern.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>In its simplest form, with no constraints, a pattern matches against a fact of the given type. In the
      following case the type is <code>Cheese</code>, which means that the pattern will match against all
      <code>Cheese</code> objects in the Working Memory.</para>

      <para>Notice that the type need not be the actual class of some fact object. Patterns may refer to superclasses or
      even interfaces, thereby potentially matching facts from many different classes.</para>

      <example>
        <title>Simple Pattern</title>

        <programlisting>Cheese()</programlisting>
      </example>

      <para>For referring to the matched object, use a pattern binding variable such as <code>$c</code>. The prefixed
      dollar symbol ('$') is optional; it can be useful in complex rules where it helps to more easily differentiate
      between variables and fields.</para>

      <example>
        <title>Pattern with a binding variable</title>

        <programlisting>$c : Cheese()</programlisting>
      </example>

      <para>Inside of the pattern parenthesis is where all the action happens. A constraint can be either a Field
      Constraint, Inline Eval, or a Constraint Group. Constraints can be separated by the following symbols: ',',
      '&amp;&amp;' or '||'.</para>

      <figure>
        <title>Constraints</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/Chapter-Rule_Language/constraints.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>Constraint</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/Chapter-Rule_Language/constraint.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>constraintGroup</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/Chapter-Rule_Language/constraintGroup.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The comma character (',') is used to separate constraint groups. It has implicit and connective
      semantics.<example>
          <title>Constraint Group connective ','</title>

          <programlisting># Cheese type is stilton and price &lt; 10 and age is mature.
Cheese( type == "stilton", price &lt; 10, age == "mature" )</programlisting>
        </example>The above example has three constraint groups, each with a single constraint:</para>

      <itemizedlist>
        <listitem>
          <para>Group 1 - <code>type == "stilton"</code> requires that the type is stilton.</para>
        </listitem>

        <listitem>
          <para>Group 2 - <code>price &lt; 10</code> demands a price less than 10.</para>
        </listitem>

        <listitem>
          <para>Group 3 - <code>age == "mature"</code> accepts only mature cheese.</para>
        </listitem>
      </itemizedlist>

      <para>The '&amp;&amp;' (and) and '||' (or) constraint connectives allow constraint groups to have multiple
      constraints. Example:</para>

      <example>
        <title>&amp;&amp; and || Constraint Connectives</title>

        <programlisting>// Cheese type is "stilton" and price &lt; 10, and age is mature
Cheese( type == "stilton" &amp;&amp; price &lt; 10, age == "mature" )
// Cheese type is "stilton" or price &lt; 10, and age is mature
Cheese( type == "stilton" || price &lt; 10, age == "mature" )</programlisting>
      </example>

      <para>The above example has two constraint groups. The first has two constraints and the second has one
      constraint.</para>

      <para>The connectives are evaluated in the following order, from first to last:</para>

      <orderedlist>
        <listitem>
          <para>
            <literal>&amp;&amp;</literal>
          </para>
        </listitem>

        <listitem>
          <para>
            <literal>||</literal>
          </para>
        </listitem>

        <listitem>
          <para>
            <literal>,</literal>
          </para>
        </listitem>
      </orderedlist>

      <para>It is possible to change the evaluation priority by using parentheses, as in any logic or mathematical
      expression. Example:</para>

      <example>
        <title>Using parentheses to change evaluation priority</title>

        <programlisting># Cheese type is stilton and ( price is less than 20 or age is mature ).
Cheese( type == "stilton" &amp;&amp; ( price &lt; 20 || age == "mature" ) ) </programlisting>
      </example>

      <para>In the above example, the use of parentheses evaluates the connective '<literal>||</literal>' before the
      connective '<literal>&amp;&amp;</literal>'.</para>

      <para>Also, it is important to note that besides having the same semantics, the connectives
      '<literal>&amp;&amp;</literal>' and '<literal>,</literal>' are resolved with different priorities. Also,
      '<literal>,</literal>' cannot be embedded in a composite constraint expression.</para>

      <example>
        <title>Not Equivalent connectives</title>

        <programlisting>// invalid as ',' cannot be embedded in an expression:
Cheese( ( type == "stilton", price &lt; 10 ) || age == "mature" )
// valid as '&amp;&amp;' can be embedded in an expression:
Cheese( ( type == "stilton" &amp;&amp; price &lt; 10 ) || age == "mature")</programlisting>
      </example>

      <section>
        <title>Field Constraints</title>

        <para>A Field constraint specifies a restriction to be used on a named field; the field name can have an
        optional variable binding.</para>

        <figure>
          <title>fieldConstraint</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="images/Chapter-Rule_Language/fieldConstraint.png" format="PNG" role="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>There are three types of restrictions: Single Value Restriction, Compound Value Restriction, and Multi
        Restriction.</para>

        <figure>
          <title>restriction</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="images/Chapter-Rule_Language/restriction.png" format="PNG" role="" />
            </imageobject>
          </mediaobject>
        </figure>

        <section>
          <title>JavaBeans as facts</title>

          <para>A field is derived from an accessible method of the object. If your model objects follow the Java Bean
          pattern, then fields are exposed using "getXXX" or "isXXX" methods, where these methods take no arguments, and
          return something. Within patterns, fields can be accessed using the bean naming convention, so that "getType"
          would be accessed as "type". Drools uses the standard JDK <literal>Introspector</literal> class to do this
          mapping.</para>

          <para>For example, referring to our Cheese class, the pattern <code>Cheese(type == "brie")</code> applies the
          <literal>getType()</literal> method to a Cheese instance. If a field name cannot be found, the compiler will
          resort to using the name as a method without arguments. Thus, the method <code>toString()</code> is called due
          to a constraint <code>Cheese(toString == "cheddar")</code>. In this case, you use the full name of the method
          with correct capitalization, but still without parentheses. Do please make sure that you are accessing methods
          that take no parameters, and that are in fact <emphasis>accessors</emphasis> which don't change the state of
          the object in a way that may effect the rules. Remember that the rule engine effectively caches the results of
          its matching in between invocations to make it faster.</para>
        </section>

        <section>
          <title>Values</title>

          <para>The field constraints can take a number of values; including literal, qualifiedIdentifier (enum),
          variable and returnValue.</para>

          <figure>
            <title>literal</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="images/Chapter-Rule_Language/literal.png" format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <figure>
            <title>qualifiedIdentifier</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="images/Chapter-Rule_Language/qualifiedIdentifier.png" format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <figure>
            <title>variable</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="images/Chapter-Rule_Language/identifier.png" format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <figure>
            <title>returnValue</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="images/Chapter-Rule_Language/returnValue.png" format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>You can do checks against fields that are or may be null, using '==' and '!=' as you would expect, and
          the literal <literal>null</literal> keyword, as in <code>Cheese(type != null)</code>, where the evaluator will
          not throw an exception and return true if the value is null. Type coercion is always attempted if the field
          and the value are of different types; exceptions will be thrown if a bad coercion is attempted. For instance,
          if "ten" is provided as a string in a numeric evaluator, an exception is thrown, whereas "10" would coerce to
          a numeric 10. Coercion is always in favor of the field type and not the value type.</para>
        </section>

        <section>
          <title>Single Value Restriction</title>

          <figure>
            <title>singleValueRestriction</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="images/Chapter-Rule_Language/singleValueRestriction.png" format="PNG"
                           role="" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>A Single Value Restriction is a binary relation, applying a binary operator to the field value and
          another value, which may be a literal, a variable, a parenthesized expression ("return value"), or a qualified
          identifier, i.e., an enum constant.</para>

          <section>
            <title>Operators</title>

            <figure>
              <title>Operators</title>

              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="images/Chapter-Rule_Language/operator.png" format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <para>The operators '==' and '!=' are valid for all types. Other relational operators may be used whenever
            the type values are ordered; for date fields, '&lt;' means "before". The pair <literal>matches</literal> and
            <literal>not matches</literal> is only applicable to string fields, <literal>contains</literal> and
            <literal>not contains</literal> require the field to be of some Collection type. Coercion to the correct
            value for the evaluator and the field will be attempted, as mentioned in the "Values" section.</para>

            <simplesect>
              <title>The Operator <literal>matches</literal></title>

              <para>Matches a field against any valid Java <indexterm>
                  <primary>regular expression</primary>
                </indexterm>Regular Expression. Typically that regexp is a string literal, but variables that resolve to
              a valid regexp are also allowed. It is important to note that, <emphasis>different from Java</emphasis>,
              within regular expressions written as string literals <emphasis>you don't need to escape '\'</emphasis>.
              Example:</para>

              <example>
                <title>Regular Expression Constraint</title>

                <programlisting>Cheese( type matches "(Buffalo)?\S*Mozarella" )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>The Operator <literal>not matches</literal></title>

              <para>The operator returns true if the string does not match the regular expression. The same rules apply
              as for the <literal>matches</literal> operator. Example:</para>

              <example>
                <title>Regular Expression Constraint</title>

                <programlisting>Cheese( type not matches "(Buffulo)?\S*Mozarella" )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>The Operator <literal>contains</literal></title>

              <para>The operator <literal>contains</literal> is used to check whether a field that is a <indexterm>
                  <primary>Collection</primary>
                </indexterm>Collection or array contains the specified value.</para>

              <example>
                <title>Contains with Collections</title>

                <programlisting>CheeseCounter( cheeses contains "stilton" ) // contains with a String literal
CheeseCounter( cheeses contains $var ) // contains with a variable</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>The Operator <literal>not contains</literal></title>

              <para>The operator <literal>not contains</literal> is used to check whether a field that is a <indexterm>
                  <primary>Collection</primary>
                </indexterm>Collection or array does <emphasis>not</emphasis> contain the specified value.</para>

              <example>
                <title>Literal Constraint with Collections</title>

                <programlisting>CheeseCounter( cheeses not contains "cheddar" ) // not contains with a String literal
CheeseCounter( cheeses not contains $var ) // not contains with a variable</programlisting>
              </example>

              <blockquote>
                <note>
                  <para>For backward compatibility, the <literal>excludes</literal> operator is supported as a synonym
                  for <literal>not contains</literal>.</para>
                </note>
              </blockquote>
            </simplesect>

            <simplesect>
              <title>The Operator <literal>memberOf</literal></title>

              <para>The operator <literal>memberOf</literal> is used to check whether a field is a member of a
              collection or array; that collection must be a variable.</para>

              <example>
                <title>Literal Constraint with Collections</title>

                <programlisting>CheeseCounter( cheese memberOf $matureCheeses )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>The Operator <literal>not memberOf</literal></title>

              <para>The operator <literal>not memberOf</literal> is used to check whether a field is not a member of a
              collection or array; that collection must be a variable.</para>

              <example>
                <title>Literal Constraint with Collections</title>

                <programlisting>CheeseCounter( cheese not memberOf $matureCheeses )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>The Operator <literal>soundslike</literal></title>

              <para>This operator is similar to <literal>matches</literal>, but it checks whether a word has almost the
              same sound (using English pronunciation) as the given value. This is based on the Soundex algorithm (see
              <code>http://en.wikipedia.org/wiki/Soundex</code>).</para>

              <example>
                <title>Test with soundslike</title>

                <programlisting>// match cheese "fubar" or "foobar"
Cheese( name soundslike 'foobar' )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>The Operator <literal>str</literal></title>

              <para>This operator <literal>str</literal> is used to check whether a field that is a <indexterm>
                  <primary>String</primary>
                </indexterm>String starts with or ends with a certain value. It can also be used to check the length of
              the String. <example>
                  <title>Test with str</title>

                  <programlisting>$m : Message( routingValue str[startsWith] "R1" )
                        $m : Message( routingValue str[endsWith] "R2" )
                        $m : Message( routingValue str[length] 17 )</programlisting>
                </example></para>
            </simplesect>
          </section>

          <section>
            <title>Literal Restrictions</title>

            <para>Literal restrictions are the simplest form of restrictions and evaluate a field against a specified
            literal, which may be numeric or a date, a string or a boolean.</para>

            <figure>
              <title>literalRestriction</title>

              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="images/Chapter-Rule_Language/literalRestriction.png" format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <para>Literal Restrictions using the operator '==' provide for faster execution as we can index using
            hashing to improve performance.</para>

            <simplesect>
              <title>Numeric</title>

              <para>All standard Java numeric primitives are supported.</para>

              <example>
                <title>Numeric Literal Restriction</title>

                <programlisting>Cheese( quantity == 5 )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>Date</title>

              <para>The date format "dd-mmm-yyyy" is supported by default. You can customize this by providing an
              alternative date format mask as the System property named <code>drools.dateformat</code>. If more control
              is required, use the inline-eval constraint.</para>

              <example>
                <title>Date Literal Restriction</title>

                <programlisting>Cheese( bestBefore &lt; "27-Oct-2009" )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>String</title>

              <para>Any valid Java String is allowed.</para>

              <example>
                <title>String Literal Restriction</title>

                <programlisting>Cheese( type == "stilton" )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>Boolean</title>

              <para>Only <code>true</code> or <code>false</code> can be used; 0 and 1 are not acceptable. A boolean
              field alone (as in <code>Cheese( smelly )</code> is not permitted; you must compare this to a boolean
              literal.</para>

              <example>
                <title>Boolean Literal Restriction</title>

                <programlisting>Cheese( smelly == true )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>Qualified Identifier</title>

              <para>Enums can be used as well, both JDK 1.4 and 5 style enums are supported. For the latter you must be
              executing on a JDK 5 environment.</para>

              <example>
                <title>Boolean Literal Restriction</title>

                <programlisting>Cheese( smelly == SomeClass.TRUE )</programlisting>
              </example>
            </simplesect>
          </section>

          <section>
            <title>Bound Variable Restriction</title>

            <figure>
              <title>variableRestriction</title>

              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="images/Chapter-Rule_Language/variableRestriction.png" format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <para>Variables can be bound to facts and their fields and then used in subsequent Field Constraints. A
            bound variable is called a <indexterm>
                <primary>declaration</primary>
              </indexterm>Declaration. Valid operators are determined by the type of the field being constrained;
            coercion will be attempted where possible. Bound Variable Restrictions using the operator '==' provide for
            very fast execution as we can use hashing to improve performance.</para>

            <example>
              <title>Bound Field using the operator '=='</title>

              <programlisting>Person( likes : favouriteCheese )
Cheese( type == likes )</programlisting>
            </example>

            <para>Here, <code>likes</code> is the variable that is bound in its declaration to the field
            <code>favouriteCheese</code> of any matching Person instance. It is then used to constrain the type of
            Cheese in the following pattern. Any valid Java variable name can be used, and it may be prefixed with a
            '$', which you will often see used to help differentiate declarations from fields. The example below shows a
            declaration for <code>$stilton</code>, bound to the object matching the first pattern and used with a
            <code>contains</code> operator. - Note the optional use of '$'.</para>

            <example>
              <title>Bound Fact using 'contains' operator</title>

              <programlisting>$stilton : Cheese( type == "stilton" )
Cheesery( cheeses contains $stilton )</programlisting>
            </example>
          </section>

          <section>
            <title>Return Value Restriction</title>

            <figure>
              <title>returnValueRestriction</title>

              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="images/Chapter-Rule_Language/returnValueRestriction.png"
                             format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <para>A <indexterm>
                <primary>Return Value</primary>
              </indexterm>Return Value restriction is a parenthesized expression composed from literals, any valid Java
            primitive or object, previously bound variables, function calls, and operators. Functions used in a Return
            Value must return results that do not depend on time.</para>

            <example>
              <title>Return Value Restriction</title>

              <programlisting>Person( girlAge : age, sex == "F" )
Person( age == ( girlAge + 2) ), sex == 'M' )</programlisting>
            </example>
          </section>
        </section>

        <section>
          <title>Compound Value Restriction</title>

          <para>The compound value restriction is used where there is more than one possible value to match. Currently
          only the <literal>in</literal> and <literal>not in</literal> evaluators support this. The second operand of
          this operator must be a comma-separated list of values, enclosed in parentheses. Values may be given as
          variables, literals, return values or qualified identifiers. Both evaluators are actually "syntactic sugar",
          internally rewritten as a list of multiple restrictions using the operators '!=' and '=='.</para>

          <figure>
            <title>compoundValueRestriction</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="images/Chapter-Rule_Language/compoundValueRestriction.png"
                           format="PNG" role="" />
              </imageobject>
            </mediaobject>
          </figure>

          <example>
            <title>Compound Restriction using "in"</title>

            <programlisting>Person( $cheese : favouriteCheese )
Cheese( type in ( "stilton", "cheddar", $cheese )</programlisting>
          </example>
        </section>

        <section>
          <title>Multi Restriction</title>

          <para>Multi restriction allows you to place more than one restriction on a field using the restriction
          connectives '&amp;&amp;' or '||'. Grouping via parentheses is permitted, resulting in a recursive syntax
          pattern.</para>

          <figure>
            <title>multiRestriction</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="images/Chapter-Rule_Language/multiRestriction.png" format="PNG"
                           role="" />
              </imageobject>
            </mediaobject>
          </figure>

          <figure>
            <title>restrictionGroup</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="images/Chapter-Rule_Language/restrictionGroup.png" format="PNG"
                           role="" />
              </imageobject>
            </mediaobject>
          </figure>

          <example>
            <title>Multi Restriction</title>

            <programlisting>// Simple multi restriction using a single &amp;&amp;
Person( age &gt; 30 &amp;&amp; &lt; 40 )
// Complex multi restriction using groupings of multi restrictions
Person( age ( (&gt; 30 &amp;&amp; &lt; 40) ||
              (&gt; 20 &amp;&amp; &lt; 25) ) )
// Mixing muti restrictions with constraint connectives
Person( age &gt; 30 &amp;&amp; &lt; 40 || location == "london" )</programlisting>
          </example>
        </section>
      </section>

      <section>
        <title>Inline Eval Constraints</title>

        <figure>
          <title>Inline Eval Expression</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="images/Chapter-Rule_Language/inlineEvalConstraint.png" format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>An <indexterm>
            <primary>Predicate</primary>
          </indexterm>inline eval constraint can use any valid dialect expression as long as it results to a primitive
        boolean. The expression must be constant over time. Any previously bound variable, from the current or previous
        pattern, can be used; autovivification is also used to auto-create field binding variables. When an identifier
        is found that is not a current variable, the builder looks to see if the identifier is a field on the current
        object type, if it is, the field binding is auto-created as a variable of the same name. This is called
        autovivification of field variables inside of inline evals.</para>

        <para>This example will find all male-female pairs where the male is 2 years older than the female; the variable
        <code>age</code> is auto-created in the second pattern by the autovivification process.</para>

        <example>
          <title>Return Value operator</title>

          <programlisting>Person( girlAge : age, sex = "F" )
Person( eval( age == girlAge + 2 ), sex = 'M' )
</programlisting>
        </example>
      </section>

      <section>
        <title>Nested Accessors</title>

        <para>Drools permits <emphasis>nested accessors</emphasis> in the field constraints using the MVEL accessor
        graph notation. Field constraints involving nested accessors are actually re-written as an MVEL dialect
        inline-eval. Care should be taken when using nested accessors as the Working Memory is not aware of any of the
        nested values, and does not know when they change; they should be considered immutable while any of their parent
        references are inserted into the Working Memory. If you wish to modify a nested value you should remove the
        parent objects first and re-assert afterwards. If you only have a single parent at the root of the graph, when
        in the MVEL dialect, you can use the <literal>modify</literal> construct and its block setters to write the
        nested accessor assignments while retracting and inserting the root parent object as required. Nested accessors
        can be used on either side of the operator symbol.</para>

        <example>
          <title>Nested Accessors</title>

          <programlisting>// Find a pet older than its owners first-born child
$p : Person( ) 
Pet( owner == $p, age &gt; $p.children[0].age )</programlisting>

          <para>This is internally rewritten as an MVEL inline eval:</para>

          <programlisting>// Find a pet older than its owners first-born child
$p : Person( ) 
Pet( owner == $p, eval( age &gt; $p.children[0].age ) ) </programlisting>
        </example>

        <note>
          <para>Nested accessors have a much greater performance cost than direct
          field accesses, so use them carefully.</para>
        </note>
      </section>
    </section>

    <section>
      <title>Conditional Element <literal>and</literal></title>

      <para>The Conditional Element <literal>and</literal> is used to group other Conditional Elements into a logical
      conjunction. The root element of the LHS is an implicit prefix <literal>and</literal> and doesn't need to be
      specified. Drools supports both prefix <literal>and</literal> and infix <literal>and</literal>, but prefix is the
      preferred option as its implicit grouping avoids confusion.</para>

      <figure>
        <title>prefixAnd</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/Chapter-Rule_Language/prefixAnd.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <example>
        <title>prefixAnd</title>

        <programlisting>(and Cheese( cheeseType : type )
     Person( favouriteCheese == cheeseType ) )
</programlisting>
      </example>

      <example>
        <title>implicit root prefixAnd</title>

        <programlisting>when
     Cheese( cheeseType : type )
     Person( favouriteCheese == cheeseType )</programlisting>
      </example>

      <para>Infix <literal>and</literal> is supported along with explicit grouping with parentheses, should it be
      needed. The symbol '&amp;&amp;', as an alternative to <literal>and</literal>, is deprecated although it is still
      supported in the syntax for legacy support reasons.</para>

      <figure>
        <title>infixAnd</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/Chapter-Rule_Language/infixAnd.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <example>
        <title>infixAnd</title>

        <programlisting>//infixAnd
Cheese( cheeseType : type ) and Person( favouriteCheese == cheeseType )
//infixAnd with grouping
( Cheese( cheeseType : type ) and
  ( Person( favouriteCheese == cheeseType ) or 
    Person( favouriteCheese == cheeseType ) )</programlisting>
      </example>
    </section>

    <section>
      <title>Conditional Element <literal>or</literal></title>

      <para>The Conditional Element <literal>or</literal> is used to group other Conditional Elements into a logical
      disjunction. Drools supports both prefix <literal>or</literal> and infix <literal>or</literal>, but prefix is the
      preferred option as its implicit grouping avoids confusion. The behavior of the Conditional Element
      <literal>or</literal> is different from the connective '||' for constraints and restrictions in field constraints.
      The engine actually has no understanding of the Conditional Element <literal>or</literal>; instead, via a number
      of different logic transformations, a rule with <literal>or</literal> is rewritten as a number of subrules. This
      process ultimately results in a rule that has a single <literal>or</literal> as the root node and one subrule for
      each of its CEs. Each subrule can activate and fire like any normal rule; there is no special behavior or
      interaction between these subrules. - This can be most confusing to new rule authors.</para>

      <figure>
        <title>prefixOr</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/Chapter-Rule_Language/prefixOr.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <example>
        <title>prefixOr</title>

        <programlisting>(or Person( sex == "f", age &gt; 60 )
    Person( sex == "m", age &gt; 65 )
</programlisting>
      </example>

      <para>Infix <literal>or</literal> is supported along with explicit grouping with parentheses, should it be needed.
      The symbol '||', as an alternative to <literal>or</literal>, is deprecated although it is still supported in the
      syntax for legacy support reasons.</para>

      <figure>
        <title>infixOr</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/Chapter-Rule_Language/infixOr.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <example>
        <title>infixOr</title>

        <programlisting>//infixOr
Cheese( cheeseType : type ) or Person( favouriteCheese == cheeseType )
//infixOr with grouping
( Cheese( cheeseType : type ) or
  ( Person( favouriteCheese == cheeseType ) and
    Person( favouriteCheese == cheeseType ) )</programlisting>
      </example>

      <para>The Conditional Element <literal>or</literal> also allows for optional pattern binding. This means that each
      resulting subrule will bind its pattern to the pattern binding. Each pattern must be bound separately, using
      eponymous variables:</para>

      <example>
        <title>or with binding</title>

        <programlisting>(or pensioner : Person( sex == "f", age &gt; 60 ) 
    pensioner : Person( sex == "m", age &gt; 65 ) )</programlisting>
      </example>

      <para>Since the conditional element <literal>or</literal> results in multiple subrule generation, one for each
      possible logically outcome, the example above would result in the internal generation of two rules. These two
      rules work independently within the Working Memory, which means both can match, activate and fire - there is no
      shortcutting.</para>

      <para>The best way to think of the conditional element <literal>or</literal> is as a shortcut for generating two
      or more similar rules. When you think of it that way, it's clear that for a single rule there could be multiple
      activations if two or more terms of the disjunction are true.</para>
    </section>

    <section>
      <title>Conditional Element <literal>eval</literal></title>

      <figure>
        <title>eval</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/Chapter-Rule_Language/eval.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The CE <literal>eval</literal> is essentially a catch-all which allows any semantic code (that returns a
      primitive boolean) to be executed. This code can refer to variables that were bound in the LHS of the rule, and
      functions in the rule package. Overuse of eval reduces the declarativeness of your rules and can result in a
      poorly performing engine. While <literal>eval</literal> can be used anywhere in the patterns, the best practice is
      to add it as the last conditional element in the LHS of a rule.</para>

      <para>Evals cannot be indexed and thus are not as efficient as Field Constraints. However this makes them ideal
      for being used when functions return values that change over time, which is not allowed within Field
      Constraints.</para>

      <para>For folks who are familiar with Drools 2.x lineage, the old Drools parameter and condition tags are
      equivalent to binding a variable to an appropriate type, and then using it in an eval node.</para>

      <example>
        <title>eval</title>

        <programlisting>p1 : Parameter() 
p2 : Parameter()
eval( p1.getList().containsKey(p2.getItem()) )
// call function isValid in the LHS
eval( isValid(p1, p2) )</programlisting>
      </example>
    </section>

    <section>
      <title>Conditional Element <literal>not</literal></title>

      <figure>
        <title>not</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/Chapter-Rule_Language/not.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The CE <literal>not</literal> is first order logic's non-existential quantifier and checks for the
      non-existence of something in the Working Memory. Think of "not" as meaning "there must be none of...".</para>

      <para>The keyword <literal>not</literal> be followed by parentheses around the CEs that it applies to. In the
      simplest case of a single pattern (like below) you may optionally omit the parentheses.</para>

      <example>
        <title>No Busses</title>

        <programlisting>not Bus()</programlisting>
      </example>

      <example>
        <title>No red Busses</title>

        <programlisting>// Brackets are optional:
not Bus(color == "red")
// Brackets are optional:
not ( Bus(color == "red", number == 42) )
// "not" with nested infix <literal>and</literal> - two patterns,
// brackets are requires:
not ( Bus(color == "red") and
      Bus(color == "blue") )</programlisting>
      </example>
    </section>

    <section>
      <title>Conditional Element <literal>exists</literal></title>

      <figure>
        <title>exists</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/Chapter-Rule_Language/exists.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The CE <literal>exists</literal> is first order logic's existential quantifier and checks for the existence
      of something in the Working Memory. Think of "exists" as meaning "there is at least one..". It is different from
      just having the pattern on its own, which is more like saying "for each one of...". If you use
      <literal>exists</literal> with a pattern, the rule will only activate at most once, regardless of how much data
      there is in working memory that matches the condition inside of the <literal>exists</literal> pattern. Since only
      the existence matters, no bindings will be established.</para>

      <para>The keyword <literal>exists</literal> must be followed by parentheses around the CEs that it applies to. In
      the simplest case of a single pattern (like below) you may omit the parentheses.</para>

      <example>
        <title>At least one Bus</title>

        <programlisting>exists Bus()</programlisting>
      </example>

      <example>
        <title>At least one red Bus</title>

        <programlisting>exists Bus(color == "red")
// brackets are optional:
exists ( Bus(color == "red", number == 42) )
// "exists" with nested infix <literal>and</literal>,
// brackets are required:
exists ( Bus(color == "red") and
         Bus(color == "blue") )</programlisting>
      </example>
    </section>

    <section>
      <title>Conditional Element <literal>forall</literal></title>

      <figure>
        <title>forall</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/Chapter-Rule_Language/forall.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The Conditional Element <literal>forall</literal> completes the First Order Logic support in Drools. The
      Conditional Element <literal>forall</literal> evaluates to true when all facts that match the first pattern match
      all the remaining patterns. Example:</para>

      <programlisting>rule "All English buses are red"
when
    forall( $bus : Bus( type == 'english') 
                   Bus( this == $bus, color = 'red' ) )
then
    # all english buses are red
end
</programlisting>

      <para>In the above rule, we "select" all Bus objects whose type is "english". Then, for each fact that matches
      this pattern we evaluate the following patterns and if they match, the forall CE will evaluate to true.</para>

      <para>To state that all facts of a given type in the working memory must match a set of constraints,
      <literal>forall</literal> can be written with a single pattern for simplicity. Example:</para>

      <example>
        <title>Single Pattern Forall</title>

        <programlisting>rule "All Buses are Red"
when
    forall( Bus( color == 'red' ) )
then
    # all asserted Bus facts are red
end
</programlisting>
      </example>

      <para>Another example shows multiple patterns inside the <literal>forall</literal>:</para>

      <example>
        <title>Multi-Pattern Forall</title>

        <programlisting>rule "all employees have health and dental care programs"
when
    forall( $emp : Employee()
            HealthCare( employee == $emp )
            DentalCare( employee == $emp )
          )
then
    # all employees have health and dental care
end
</programlisting>
      </example>

      <para>Forall can be nested inside other CEs. For instance, <literal>forall</literal> can be used inside a
      <literal>not</literal> CE. Note that only single patterns have optional parentheses, so that with a nested
      <literal>forall</literal> parentheses must be used:</para>

      <example>
        <title>Combining Forall with Not CE</title>

        <programlisting>rule "not all employees have health and dental care"
when 
    not ( forall( $emp : Employee()
                  HealthCare( employee == $emp )
                  DentalCare( employee == $emp ) ) 
        )
then
    # not all employees have health and dental care
end
</programlisting>
      </example>

      <para>As a side note, <code>forall( p1 p2 p3...)</code> is equivalent to writing:</para>

      <programlisting>not(p1 and not(and p2 p3...))</programlisting>

      <para>Also, it is important to note that <literal>forall</literal> is a <emphasis>scope delimiter</emphasis>.
      Therefore, it can use any previously bound variable, but no variable bound inside it will be available for use
      outside of it.</para>
    </section>

    <section>
      <title>Conditional Element <literal>from</literal></title>

      <figure>
        <title>from</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/Chapter-Rule_Language/from.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The Conditional Element <literal>from</literal> enables users to specify an arbitrary source for data to be
      matched by LHS patterns. This allows the engine to reason over data not in the Working Memory. The data source
      could be a sub-field on a bound variable or the results of a method call. It is a powerful construction that
      allows out of the box integration with other application components and frameworks. One common example is the
      integration with data retrieved on-demand from databases using hibernate named queries.</para>

      <para>The expression used to define the object source is any expression that follows regular MVEL syntax.
      Therefore, it allows you to easily use object property navigation, execute method calls and access maps and
      collections elements.</para>

      <para>Here is a simple example of reasoning and binding on another pattern sub-field:</para>

      <programlisting>rule "validate zipcode"
when
    Person( $personAddress : address ) 
    Address( zipcode == "23920W") from $personAddress 
then
    # zip code is ok
end
</programlisting>

      <para>With all the flexibility from the new expressiveness in the Drools engine you can slice and dice this
      problem many ways. This is the same but shows how you can use a graph notation with the 'from':</para>

      <programlisting>rule "validate zipcode"
when
    $p : Person( ) 
    $a : Address( zipcode == "23920W") from $p.address 
then
    # zip code is ok
end
</programlisting>

      <para>Previous examples were evaluations using a single pattern. The CE <literal>from</literal> also support
      object sources that return a collection of objects. In that case, <literal>from</literal> will iterate over all
      objects in the collection and try to match each of them individually. For instance, if we want a rule that applies
      10% discount to each item in an order, we could do:</para>

      <programlisting>rule "apply 10% discount to all items over US$ 100,00 in an order"
when
    $order : Order()
    $item  : OrderItem( value &gt; 100 ) from $order.items
then
    # apply discount to $item
end
</programlisting>

      <para>The above example will cause the rule to fire once for each item whose value is greater than 100 for each
      given order.</para>

      <para>You must take caution, however, when using <literal>from</literal>, especially in conjunction with the
      <literal>lock-on-active</literal> rule attribute as it may produce unexpected results. Consider the example
      provided earlier, but now slightly modified as follows:</para>

      <programlisting>rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person( ) 
    $a : Address( state == "NC") from $p.address 
then
    modify ($p) {} #Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person( ) 
    $a : Address( city == "Raleigh") from $p.address 
then
    modify ($p) {} #Apply discount to person in a modify block
end
</programlisting>

      <para>In the above example, persons in Raleigh, NC should be assigned to sales region 1 and receive a discount;
      i.e., you would expect both rules to activate and fire. Instead you will find that only the second rule
      fires.</para>

      <para>If you were to turn on the audit log, you would also see that when the second rule fires, it deactivates the
      first rule. Since the rule attribute <literal>lock-on-active</literal> prevents a rule from creating new
      activations when a set of facts change, the first rule fails to reactivate. Though the set of facts have not
      changed, the use of <literal>from</literal> returns a new fact for all intents and purposes each time it is
      evaluated.</para>

      <para>First, it's important to review why you would use the above pattern. You may have many rules across
      different rule-flow groups. When rules modify working memory and other rules downstream of your RuleFlow (in
      different rule-flow groups) need to be reevaluated, the use of <literal>modify</literal> is critical. You don't,
      however, want other rules in the same rule-flow group to place activations on one another recursively. In this
      case, the <literal>no-loop</literal> attribute is ineffective, as it would only prevent a rule from activating
      itself recursively. Hence, you resort to <literal>lock-on-active</literal>.</para>

      <para>There are several ways to address this issue:</para>

      <itemizedlist>
        <listitem>
          <para>Avoid the use of <literal>from</literal> when you can assert all facts into working memory or use nested
          object references in your constraint expressions (shown below).</para>
        </listitem>

        <listitem>
          <para>Place the variable assigned used in the modify block as the last sentence in your condition
          (LHS).</para>
        </listitem>

        <listitem>
          <para>Avoid the use of <literal>lock-on-active</literal> when you can explicitly manage how rules within the
          same rule-flow group place activations on one another (explained below).</para>
        </listitem>
      </itemizedlist>

      <para>The preferred solution is to minimize use of <literal>from</literal> when you can assert all your facts into
      working memory directly. In the example above, both the Person and Address instance can be asserted into working
      memory. In this case, because the graph is fairly simple, an even easier solution is to modify your rules as
      follows:</para>

      <programlisting>rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person(address.state == "NC" )  
then
    modify ($p) {} #Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person(address.city == "Raleigh" )  
then
    modify ($p) {} #Apply discount to person in a modify block
end
</programlisting>

      <para>Now, you will find that both rules fire as expected. However, it is not always possible to access nested
      facts as above. Consider an example where a Person holds one or more Addresses and you wish to use an existential
      quantifier to match people with at least one address that meets certain conditions. In this case, you would have
      to resort to the use of <literal>from</literal> to reason over the collection.</para>

      <para>There are several ways to use <literal>from</literal> to achieve this and not all of them exhibit an issue
      with the use of <literal>lock-on-active</literal>. For example, the following use of <literal>from</literal>
      causes both rules to fire as expected:</para>

      <programlisting>rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person($addresses : addresses)
    exists (Address(state == "NC") from $addresses)  
then
    modify ($p) {} #Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person($addresses : addresses)
    exists (Address(city == "Raleigh") from $addresses)  
then
    modify ($p) {} #Apply discount to person in a modify block
end
</programlisting>

      <para>However, the following slightly different approach does exhibit the problem:</para>

      <programlisting>rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $assessment : Assessment()
    $p : Person()
    $addresses : List() from $p.addresses
    exists (Address( state == "NC") from $addresses) 
then
    modify ($assessment) {} #Modify assessment in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $assessment : Assessment()
    $p : Person()
    $addresses : List() from $p.addresses 
    exists (Address( city == "Raleigh") from $addresses)
then
    modify ($assessment) {} #Modify assessment in a modify block
end</programlisting>

      <para>In the above example, the $addresses variable is returned from the use of <literal>from</literal>. The
      example also introduces a new object, assessment, to highlight one possible solution in this case. If the
      $assessment variable assigned in the condition (LHS) is moved to the last condition in each rule, both rules fire
      as expected.</para>

      <para>Though the above examples demonstrate how to combine the use of <literal>from</literal> with
      <literal>lock-on-active</literal> where no loss of rule activations occurs, they carry the drawback of placing a
      dependency on the order of conditions on the LHS. In addition, the solutions present greater complexity for the
      rule author in terms of keeping track of which conditions may create issues.</para>

      <para>A better alternative is to assert more facts into working memory. In this case, a person's addresses may be
      asserted into working memory and the use of <literal>from</literal> would not be necessary.</para>

      <para>There are cases, however, where asserting all data into working memory is not practical and we need to find
      other solutions. Another option is to reevaluate the need for <literal>lock-on-active</literal>. An alternative to
      <literal>lock-on-active</literal> is to directly manage how rules within the same rule-flow group activate one
      another by including conditions in each rule that prevent rules from activating each other recursively when
      working memory is modified. For example, in the case above where a discount is applied to citizens of Raleigh, a
      condition may be added to the rule that checks whether the discount has already been applied. If so, the rule does
      not activate.</para>
    </section>

    <section>
      <title>Conditional Element <literal>collect</literal></title>

      <figure>
        <title>collect</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/Chapter-Rule_Language/collect.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The Conditional Element <literal>collect</literal> allows rules to reason over a collection of objects
      obtained from the given source or from the working memory. In First Oder Logic terms this is the cardinality
      quantifier. A simple example:</para>

      <programlisting>import java.util.ArrayList

rule "Raise priority if system has more than 3 pending alarms"
when
    $system : System()
    $alarms : ArrayList( size &gt;= 3 )
              from collect( Alarm( system == $system, status == 'pending' ) )
then
    # Raise priority, because system $system has
    # 3 or more alarms pending. The pending alarms
    # are $alarms.
end
</programlisting>

      <para>In the above example, the rule will look for all pending alarms in the working memory for each given system
      and group them in ArrayLists. If 3 or more alarms are found for a given system, the rule will fire.</para>

      <para>The result pattern of <literal>collect</literal> can be any concrete class that implements the
      <code>java.util.Collection</code> interface and provides a default no-arg public constructor. This means that you
      can use Java collections like ArrayList, LinkedList, HashSet, etc., or your own class, as long as it implements
      the <code>java.util.Collection</code> interface and provide a default no-arg public constructor.</para>

      <para>Both source and result patterns can be constrained as any other pattern.</para>

      <para>Variables bound before the <literal>collect</literal> CE are in the scope of both source and result patterns
      and therefore you can use them to constrain both your source and result patterns. But note that
      <literal>collect</literal> is a scope delimiter for bindings, so that any binding made inside of it is not
      available for use outside of it.</para>

      <para>Collect accepts nested <literal>from</literal> CEs. The following example is a valid use of
      "collect":</para>

      <programlisting>import java.util.LinkedList;

rule "Send a message to all mothers"
when
    $town : Town( name == 'Paris' )
    $mothers : LinkedList() 
               from collect( Person( gender == 'F', children &gt; 0 ) 
                             from $town.getPeople() 
                           )
then
    # send a message to all mothers
end
</programlisting>
    </section>

    <section>
      <title>Conditional Element <literal>accumulate</literal></title>

      <figure>
        <title>accumulate</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/Chapter-Rule_Language/accumulate.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The Conditional Element <literal>accumulate</literal> is a more flexible and powerful form of
      <literal>collect</literal>, the sense that it can be used to do what <literal>collect</literal> does and also
      achieve things that the CE <literal>collect</literal> is not capable of doing. Basically, what it does is that it
      allows a rule to iterate over a collection of objects, executing custom actions for each of the elements, and at
      the end it returns a result object.</para>

      <para>The general syntax of the <literal>accumulate</literal> CE is:</para>

      <programlisting><replaceable>&lt;result pattern&gt;</replaceable> <literal>from accumulate(</literal> <replaceable>&lt;source pattern&gt;</replaceable><literal>,</literal>
                                  <literal>init(</literal> <replaceable>&lt;init code&gt;</replaceable> <literal>),</literal>
                                  <literal>action(</literal> <replaceable>&lt;action code&gt;</replaceable> <literal>),</literal>
                                  <literal>reverse(</literal> <replaceable>&lt;reverse code&gt;</replaceable> <literal>),</literal>
                                  <literal>result(</literal> <replaceable>&lt;result expression&gt;</replaceable> <literal>) )</literal>
</programlisting>

      <para>The meaning of each of the elements is the following:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>&lt;source pattern&gt;</emphasis>: the source pattern is a regular pattern that the engine
          will try to match against each of the source objects.</para>
        </listitem>

        <listitem>
          <para><emphasis>&lt;init code&gt;</emphasis>: this is a semantic block of code in the selected dialect that
          will be executed once for each tuple, before iterating over the source objects.</para>
        </listitem>

        <listitem>
          <para><emphasis>&lt;action code&gt;</emphasis>: this is a semantic block of code in the selected dialect that
          will be executed for each of the source objects.</para>
        </listitem>

        <listitem>
          <para><emphasis>&lt;reverse code&gt;</emphasis>: this is an optional semantic block of code in the selected
          dialect that if present will be executed for each source object that no longer matches the source pattern. The
          objective of this code block is to undo any calculation done in the <emphasis>&lt;action code&gt;</emphasis>
          block, so that the engine can do decremental calculation when a source object is modified or retracted, hugely
          improving performance of these operations.</para>
        </listitem>

        <listitem>
          <para><emphasis>&lt;result expression&gt;</emphasis>: this is a semantic expression in the selected dialect
          that is executed after all source objects are iterated.</para>
        </listitem>

        <listitem>
          <para><emphasis>&lt;result pattern&gt;</emphasis>: this is a regular pattern that the engine tries to match
          against the object returned from the <emphasis>&lt;result expression&gt;</emphasis>. If it matches, the
          <literal>accumulate</literal> conditional element evaluates to <emphasis>true</emphasis> and the engine
          proceeds with the evaluation of the next CE in the rule. If it does not matches, the
          <literal>accumulate</literal> CE evaluates to <emphasis>false</emphasis> and the engine stops evaluating CEs
          for that rule.</para>
        </listitem>
      </itemizedlist>

      <para>It is easier to understand if we look at an example:</para>

      <programlisting>rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              init( double total = 0; ),
                              action( total += $value; ),
                              reverse( total -= $value; ),
                              result( total ) )
then
    # apply discount to $order
end
</programlisting>

      <para>In the above example, for each <code>Order</code> in the Working Memory, the engine will execute the
      <emphasis>init code</emphasis> initializing the total variable to zero. Then it will iterate over all
      <code>OrderItem</code> objects for that order, executing the <emphasis>action</emphasis> for each one (in the
      example, it will sum the value of all items into the total variable). After iterating over all
      <code>OrderItem</code> objects, it will return the value corresponding to the <emphasis>result
      expression</emphasis> (in the above example, the value of variable <code>total</code>). Finally, the engine will
      try to match the result with the <code>Number</code> pattern, and if the double value is greater than 100, the
      rule will fire.</para>

      <para>The example used Java as the semantic dialect, and as such, note that the usage of the semicolon as
      statement delimiter is mandatory in the init, action and reverse code blocks. The result is an expression and, as
      such, it does not admit ';'. If the user uses any other dialect, he must comply to that dialect's specific
      syntax.</para>

      <para>As mentioned before, the <emphasis>reverse code</emphasis> is optional, but it is strongly recommended that
      the user writes it in order to benefit from the <emphasis>improved performance on update and
      retract</emphasis>.</para>

      <para>The <literal>accumulate</literal> CE can be used to execute any action on source objects. The following
      example instantiates and populates a custom object:</para>

      <programlisting>rule "Accumulate using custom objects"
when
    $person   : Person( $likes : likes )
    $cheesery : Cheesery( totalAmount &gt; 100 )
                from accumulate( $cheese : Cheese( type == $likes ),
                                 init( Cheesery cheesery = new Cheesery(); ),
                                 action( cheesery.addCheese( $cheese ); ),
                                 reverse( cheesery.removeCheese( $cheese ); ),
                                 result( cheesery ) );
then
    // do something
end</programlisting>

      <section>
        <title>Accumulate Functions</title>

        <para>The accumulate CE is a very powerful CE, but it gets real declarative and easy to use when using
        predefined functions that are known as Accumulate Functions. They work exactly like accumulate, but instead of
        explicitly writing custom code in every accumulate CE, the user can use predefined code for common
        operations.</para>

        <para>For instance, the rule to apply discount on orders written in the previous section, could be written in
        the following way, using Accumulate Functions:</para>

        <programlisting>rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              sum( $value ) )
then
    # apply discount to $order
end
</programlisting>

        <para>In the above example, sum is an Accumulate Function and will sum the $value of all OrderItems and return
        the result.</para>

        <para>Drools ships with the following built-in accumulate functions:</para>

        <itemizedlist>
          <listitem>
            <para>average</para>
          </listitem>

          <listitem>
            <para>min</para>
          </listitem>

          <listitem>
            <para>max</para>
          </listitem>

          <listitem>
            <para>count</para>
          </listitem>

          <listitem>
            <para>sum</para>
          </listitem>
        </itemizedlist>

        <para>These common functions accept any expression as input. For instance, if someone wants to calculate the
        average profit on all items of an order, a rule could be written using the average function:</para>

        <programlisting>rule "Average profit"
when
    $order : Order()
    $profit : Number() 
              from accumulate( OrderItem( order == $order, $cost : cost, $price : price )
                               average( 1 - $cost / $price ) )
then
    # average profit for $order is $profit
end
</programlisting>

        <para>Accumulate Functions are all pluggable. That means that if needed, custom, domain specific functions can
        easily be added to the engine and rules can start to use them without any restrictions. To implement a new
        Accumulate Functions all one needs to do is to create a Java class that implements the
        <code>org.drools.base.acumulators.AccumulateFunction</code> interface and add a line to the configuration file
        or set a system property to let the engine know about the new function. As an example of an Accumulate Function
        implementation, the following is the implementation of the <literal>average</literal> function:</para>

        <programlisting language="java">/*
 * Copyright 2007 JBoss Inc
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created on Jun 21, 2007
 */
package org.drools.base.accumulators;


/**
 * An implementation of an accumulator capable of calculating average values
 */
public class AverageAccumulateFunction implements AccumulateFunction {

    protected static class AverageData {
        public int    count = 0;
        public double total = 0;
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#createContext()
     */
    public Object createContext() {
        return new AverageData();
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#init(java.lang.Object)
     */
    public void init(Object context) throws Exception {
        AverageData data = (AverageData) context;
        data.count = 0;
        data.total = 0;
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#accumulate(java.lang.Object,
     * java.lang.Object)
     */
    public void accumulate(Object context,
                           Object value) {
        AverageData data = (AverageData) context;
        data.count++;
        data.total += ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#reverse(java.lang.Object,
     * java.lang.Object)
     */
    public void reverse(Object context,
                        Object value) throws Exception {
        AverageData data = (AverageData) context;
        data.count--;
        data.total -= ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#getResult(java.lang.Object)
     */
    public Object getResult(Object context) throws Exception {
        AverageData data = (AverageData) context;
        return new Double( data.count == 0 ? 0 : data.total / data.count );
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#supportsReverse()
     */
    public boolean supportsReverse() {
        return true;
    }

}
</programlisting>

        <para>The code for the function is very simple, as we could expect, as all the "dirty" integration work is done
        by the engine. Finally, to plug the function into the engine, we added it to the configuration file:</para>

        <programlisting>drools.accumulate.function.average =
   org.drools.base.accumulators.AverageAccumulateFunction
</programlisting>

        <para>Here, "drools.accumulate.function." is a prefix that must always be used, "average" is how the function
        will be used in the rule file, and "org.drools.base.accumulators.AverageAccumulateFunction" is the fully
        qualified name of the class that implements the function behavior.</para>
      </section>
    </section>
  </section>

  <section>
    <title>The Right Hand Side (then)</title>

    <section>
      <title>Usage</title>

      <para>The Right Hand Side (RHS) is a common name for the consequence or action part of the rule; this part should
      contain a list of actions to be executed. It is bad practice to use imperative or conditional code in the RHS of a
      rule; as a rule should be atomic in nature - "when this, then do this", not "when this, maybe do this". The RHS
      part of a rule should also be kept small, thus keeping it declarative and readable. If you find you need
      imperative and/or conditional code in the RHS, then maybe you should be breaking that rule down into multiple
      rules. The main purpose of the RHS is to insert, retractor modify working memory data. To assist with that there
      are a few convenience methods you can use to modify working memory; without having to first reference a working
      memory instance.</para>

      <para><literal>update(</literal><emphasis>object, handle</emphasis><literal>);</literal> will tell the engine that
      an object has changed (one that has been bound to something on the LHS) and rules may need to be
      reconsidered.</para>

      <para><literal>update(</literal><emphasis>object</emphasis><literal>);</literal> can also be used; here the
      Knowledge Helper will look up the facthandle for you, via an identity check, for the passed object. (Note that if
      you provide Property Change Listeners to your Java beans that you are inserting into the engine, you can avoid the
      need to call <code>update()</code> when the object changes.)</para>

      <para><literal>insert(new</literal> <emphasis>Something</emphasis><literal>());</literal> will place a new object
      of your creation into the Working Memory.</para>

      <para><literal>insertLogical(new</literal> <emphasis>Something</emphasis><literal>());</literal> is similar to
      insert, but the object will be automatically retracted when there are no more facts to support the truth of the
      currently firing rule.</para>

      <para><literal>retract(</literal><emphasis>handle</emphasis><literal>);</literal> removes an object from Working
      Memory.</para>

      <para>These convenience methods are basically macros that provide short cuts to the <code>KnowledgeHelper</code>
      instance that lets you access your Working Memory from rules files. The predefined variable <code>drools</code> of
      type <code>KnowledgeHelper</code> lets you call several other useful methods. (Refer to the
      <code>KnowledgeHelper</code> interface documentation for more advanced operations).</para>

      <itemizedlist>
        <listitem>
          <para>The call <code>drools.halt()</code> terminates rule execution immediately. This is required for
          returning control to the point whence the current session was put to work with
          <code>fireUntilHalt()</code>.</para>
        </listitem>

        <listitem>
          <para>Methods <code>insert(Object o)</code>, <code>update(Object o)</code> and <code>retract(Object o)</code>
          can be called on <code>drools</code> as well, but due to their frequent use they can be called without the
          object reference.</para>
        </listitem>

        <listitem>
          <para><code>drools.getWorkingMemory()</code> returns the <code>WorkingMemory</code> object.</para>
        </listitem>

        <listitem>
          <para><code>drools.setFocus( String s)</code> sets the focus to the specified agenda group.</para>
        </listitem>

        <listitem>
          <para><code>drools.getRule().getName()</code>, called from a rule's RHS, returns the name of the rule.</para>
        </listitem>

        <listitem>
          <para><code>drools.getTuple()</code> returns the Tuple that matches the currently executing rule, and
          <code>drools.getActivation()</code> delivers the corresponding Activation. (These calls are useful for logging
          and debugging purposes.)</para>
        </listitem>
      </itemizedlist>

      <para>The full Knowledge Runtime API is exposed through another predefined variable, <code>kcontext</code>, of
      type <code>KnowledgeContext</code>. Its method <code>getKnowledgeRuntime()</code> delivers an object of type
      <code>KnowledgeRuntime</code>, which, in turn, provides access to a wealth of methods, many of which are quite
      useful for coding RHS logic.</para>

      <itemizedlist>
        <listitem>
          <para>The call <code>kcontext.getKnowledgeRuntime().halt()</code> terminates rule execution
          immediately.</para>
        </listitem>

        <listitem>
          <para>The accessor <code>getAgenda()</code> returns a reference to this session's <code>Agenda</code>, which
          in turn provides access to the various rule groups: activation groups, agenda groups, and rule flow groups. A
          fairly common paradigm is the activation of some agenda group, which could be done with the lengthy
          call:</para>

          <programlisting language="java">
// give focus to the agenda group CleanUp
kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "CleanUp" ).setFocus();</programlisting>

          <para>(You can achieve the same using <code>drools.setFocus( "CleanUp" )</code>.)</para>
        </listitem>

        <listitem>
          <para>To run a query, you call <code>getQueryResults(String query)</code>, whereupon you may process the
          results, as explained in section <quote><link endterm="sec.query.title"
          linkend="sec.query"></link></quote>.</para>
        </listitem>

        <listitem>
          <para>A set of methods dealing with event management lets you, among other things, add and remove event
          listeners for the Working Memory and the Agenda.</para>
        </listitem>

        <listitem>
          <para>Method<code>getKnowledgeBase()</code> returns the <code>KnowledgeBase</code> object, the backbone of all
          the Knowledge in your system, and the originator of the current session.</para>
        </listitem>

        <listitem>
          <para>You can manage globals with <code>setGlobal(...)</code>, <code>getGlobal(...)</code> and
          <code>getGlobals()</code>.</para>
        </listitem>

        <listitem>
          <para>Method <code>getEnvironment()</code> returns the runtime's <code>Environment</code> which works much
          like what you know as your operating system's environment.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>The <literal>modify</literal> Statement</title>

      <para>This language extension provides a structured approach to fact updates. It combines the update operation
      with a number of setter calls to change the object's fields. This is the syntax schema for the
      <literal>modify</literal> statement:</para>

      <programlisting><literal>modify ( </literal><replaceable>&lt;fact-expression&gt;</replaceable><literal> ) {</literal>
    <replaceable>&lt;expression&gt;</replaceable> [ <literal>,</literal> <replaceable>&lt;expression&gt;</replaceable> ]*
<literal>}</literal></programlisting>

      <para>The parenthesized <emphasis>&lt;fact-expression&gt;</emphasis> must yield a fact object reference. The
      expression list in the block should consist of setter calls for the given object, to be written without the usual
      object reference, which is automatically prepended by the compiler.</para>

      <para>The example illustrates a simple fact modification.</para>

      <example>
        <title>A modify statement</title>

        <programlisting>rule "modify stilton"
when
    $stilton : Cheese(type == "stilton")
then
    modify( $stilton ){
        setPrice( 20 ),
        setAge( "overripe" )
    }
end</programlisting>
      </example>
    </section>
  </section>

  <section>
    <title>A Note on Auto-boxing and Primitive Types</title>

    <para>Drools attempts to preserve numbers in their primitive or object wrapper form, so a variable bound to an int
    primitive when used in a code block or expression will no longer need manual unboxing; unlike Drools 3.0 where all
    primitives were autoboxed, requiring manual unboxing. A variable bound to an object wrapper will remain as an
    object; the existing JDK 1.5 and JDK 5 rules to handle auto-boxing and unboxing apply in this case. When evaluating
    field constraints, the system attempts to coerce one of the values into a comparable format; so a primitive is
    comparable to an object wrapper.</para>
  </section>
</section>
