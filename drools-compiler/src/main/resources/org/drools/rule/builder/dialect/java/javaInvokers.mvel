@declare{"getMethodBytecode"}
    public java.util.List getMethodBytecode() {
        return org.drools.rule.Rule.getMethodBytecode(getClass(), "@{ruleClassName}", "@{package}", "@{methodName}", "@{ (package + '.' + ruleClassName).replace( '.', '/' ) + '.class' }" );
    }
@end{}


@declare{"equals"}
    public boolean equals(Object object) {
        if ( object == null || !(object instanceof  org.drools.spi.CompiledInvoker) ) {
            return false;
        }
        return org.drools.core.util.asm.MethodComparator.compareBytecode( getMethodBytecode(), (( org.drools.spi.CompiledInvoker ) object).getMethodBytecode() );
    }
@end{}

@declare{"hashCode"}
    public int hashCode() {
        return @{hashCode};
    }
@end{}

@declare{"replaceDeclaration"}
    public void replaceDeclaration(org.drools.rule.Declaration declaration,
                                   org.drools.rule.Declaration resolved) { 
        // this class does not cache declarations
    }
@end{}


@declare{"returnValueInvoker"}
package @{package};

public class @{invokerClassName} implements org.drools.spi.ReturnValueExpression, org.drools.spi.CompiledInvoker
{
    private static final long serialVersionUID  = 510l;

    public Object createContext() { return null; }

    public org.drools.spi.FieldValue evaluate(java.lang.Object object,
                            org.drools.spi.Tuple tuple,
                            org.drools.rule.Declaration[] previousDeclarations,
                            org.drools.rule.Declaration[] localDeclarations,
                            org.drools.WorkingMemory workingMemory,
                            Object context ) throws Exception {

        @code{i0=0}@foreach{declr : declarations} @{declr.typeName} @{declr.identifier} = ( @{declr.boxedTypeName} ) previousDeclarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) tuple.get( previousDeclarations[@{i0}] ) ).getObject() );
        @code{i0++}
        @end{}
        @if{readLocalsFromTuple}
          @code{i0=0}@foreach{declr : localDeclarations} @{declr.typeName} @{declr.identifier} = ( @{declr.boxedTypeName} ) localDeclarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) tuple.get( localDeclarations[@{i0}] ) ).getObject() );
          @code{i0++}
          @end{}
        @else{}
          @code{i0=0}@foreach{declr : localDeclarations} @{declr.typeName} @{declr.identifier} = ( @{declr.boxedTypeName} ) localDeclarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, object );
          @code{i0++}
          @end{}
        @end{}
        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( "@{identifier}" );
        @end{}

        return @{ruleClassName}.@{methodName}(
            @foreach{declr : declarations} @{declr.identifier}
            @end{","}  @if{localDeclarations != empty && declarations != empty},@end{}
            @foreach{declr :localDeclarations} @{declr.identifier}
            @end{","}@if{globals != empty && (localDeclarations != empty || declarations != empty)},@end{}
            @foreach{identifier : globals}@{identifier}
            @end{","} );
    }

    @includeNamed{"replaceDeclaration"}

    @includeNamed{"hashCode"}

    @includeNamed{"getMethodBytecode"}

    @includeNamed{"equals"}
}
@end{}

@declare{"predicateInvoker"}
package @{package};

public class @{invokerClassName} implements org.drools.spi.PredicateExpression, org.drools.spi.CompiledInvoker
{
    private static final long serialVersionUID  = 510l;

    public Object createContext() { return null; }

    public boolean evaluate(java.lang.Object object,
                            org.drools.spi.Tuple tuple,
                            org.drools.rule.Declaration[] previousDeclarations,
                            org.drools.rule.Declaration[] localDeclarations,
                            org.drools.WorkingMemory workingMemory,
                            Object context ) throws Exception {

        @code{i0=0}@foreach{declr : declarations} @{declr.typeName} @{declr.identifier} = ( @{declr.boxedTypeName} ) previousDeclarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) tuple.get( previousDeclarations[@{i0}] ) ).getObject() );
          @code{i0++}
        @end{}
        @code{i0=0}@foreach{declr : localDeclarations} @{declr.typeName} @{declr.identifier} = ( @{declr.boxedTypeName} ) localDeclarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, object );
          @code{i0++}
        @end{}
        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( "@{identifier}" );
        @end{}

        return @{ruleClassName}.@{methodName}(
            @foreach{declr : declarations} @{declr.identifier}
            @end{","}  @if{localDeclarations != empty && declarations != empty},@end{}
            @foreach{declr : localDeclarations} @{declr.identifier}
            @end{","}@if{globals != empty && (localDeclarations != empty || declarations != empty)},@end{}
            @foreach{identifier : globals}@{identifier}
            @end{","} );
    }

    @includeNamed{"hashCode"}

    @includeNamed{"getMethodBytecode"}

    @includeNamed{"equals"}
}
@end{}

@declare{"evalInvoker"}
package @{package};

public class @{invokerClassName} implements org.drools.spi.EvalExpression, org.drools.spi.CompiledInvoker
{
    private static final long serialVersionUID  = 510l;
    
    // no need for context
    public Object createContext() { return null; }

    public boolean evaluate(org.drools.spi.Tuple tuple,
                            org.drools.rule.Declaration[] declarations,
                            org.drools.WorkingMemory workingMemory,
                            Object context ) throws Exception {

        @code{i0=0}@foreach{declr : declarations} @{declr.typeName} @{declr.identifier} = ( @{declr.boxedTypeName} ) declarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) tuple.get( declarations[@{i0}] ) ).getObject() );
            @code{i0++}
        @end{}
        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( "@{identifier}" );
        @end{}

        return @{ruleClassName}.@{methodName}(
            @foreach{declr : declarations} @{declr.identifier}
            @end{","} @if{globals != empty && declarations != empty},@end{}
            @foreach{identifier : globals}@{identifier}
            @end{","} );
    }
    
    public org.drools.spi.EvalExpression clone() {
        // this class is stateless, so no cloning needed
        return this;
    }
    
    @includeNamed{"replaceDeclaration"}

    @includeNamed{"hashCode"}

    @includeNamed{"getMethodBytecode"}

    @includeNamed{"equals"}
}
@end{}


@declare{"accumulateInvoker"}
package @{package};

import org.mvel2.asm.ClassReader;
import org.mvel2.asm.util.TraceMethodVisitor;
import org.drools.core.util.asm.MethodComparator.Tracer;
import java.util.Collections;
public class @{invokerClassName} implements org.drools.spi.Accumulator, org.drools.spi.CompiledInvoker
{
    private static final long serialVersionUID  = 510l;

    public java.io.Serializable createContext() {
        return new @{ruleClassName}.@{className}();
    }

    public void init(java.lang.Object workingMemoryContext,
                     java.lang.Object context,
                     org.drools.spi.Tuple leftTuple,
                     org.drools.rule.Declaration[] declarations,
                     org.drools.WorkingMemory workingMemory) throws Exception {
        @code{i0=0}@foreach{declr : declarations} @{declr.typeName} @{declr.identifier} = ( @{declr.boxedTypeName} ) declarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) leftTuple.get( declarations[@{i0}] ) ).getObject() );
            @code{i0++}
        @end{}
        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( "@{identifier}" );
        @end{}

        ((@{ruleClassName}.@{className})context).init(
            @foreach{declr : declarations} @{declr.identifier}@end{","}@if{globals != empty && declarations != empty},@end{}
            @foreach{identifier : globals} @{identifier}@end{","} );

    }

    public void accumulate(java.lang.Object workingMemoryContext,
                           java.lang.Object context,
                           org.drools.spi.Tuple leftTuple,
                           org.drools.common.InternalFactHandle handle,
                           org.drools.rule.Declaration[] declarations,
                           org.drools.rule.Declaration[] innerDeclarations,
                           org.drools.WorkingMemory workingMemory) throws Exception {
        @code{ i0 = 0 }@foreach{declr : declarations} @{declr.typeName} @{declr.identifier} = ( @{declr.boxedTypeName} ) declarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) leftTuple.get( declarations[@{i0}] ) ).getObject() );
            @code{ i0++ }
        @end{}
        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( "@{identifier}" );
        @end{}
        @if{isMultiPattern}
          @code{ i0 = 0 }@foreach{declr : innerDeclarations} @{declr.extractor.extractToClassName} @{declr.identifier} = (@{declr.extractor.extractToClassName}) innerDeclarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) leftTuple.get( innerDeclarations[@{i0}] ) ).getObject() );
            @code{ i0++ }
          @end{}
        @else{}
          @code{ i0 = 0 }@foreach{declr : innerDeclarations} @{declr.extractor.extractToClassName} @{declr.identifier} = (@{declr.extractor.extractToClassName}) innerDeclarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, handle.getObject() );
            @code{ i0++ }
          @end{}
        @end{}
        ((@{ruleClassName}.@{className})context).accumulate(
            workingMemory,
            handle,
            innerDeclarations,
            handle.getObject()@if{declarations != empty},@end{}
            @foreach{declr : declarations} @{declr.identifier}@end{","}@if{globals != empty},@end{}
            @foreach{identifier: globals} @{identifier}@end{","}@if{innerDeclarations != empty},@end{}
            @foreach{declr : innerDeclarations} @{declr.identifier}@end{","});
    }

    public void reverse(java.lang.Object workingMemoryContext,
                           java.lang.Object context,
                           org.drools.spi.Tuple leftTuple,
                           org.drools.common.InternalFactHandle handle,
                           org.drools.rule.Declaration[] declarations,
                           org.drools.rule.Declaration[] innerDeclarations,
                           org.drools.WorkingMemory workingMemory) throws Exception {
        @code{ i0 = 0 }@foreach{declr : declarations} @{declr.typeName} @{declr.identifier} = ( @{declr.boxedTypeName} ) declarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) leftTuple.get( declarations[@{i0}] ) ).getObject() );
            @code{ i0++ }
        @end{}
        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( "@{identifier}" );
        @end{}
        @if{isMultiPattern}
          @code{ i0 = 0}@foreach{declr : innerDeclarations} @{declr.extractor.extractToClassName} @{declr.identifier} = (@{declr.extractor.extractToClassName}) innerDeclarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) leftTuple.get( innerDeclarations[@{i0}] ) ).getObject() );
            @code{ i0++ }
          @end{}
        @else{}
          @code{ i0 = 0 }@foreach{declr : innerDeclarations} @{declr.extractor.extractToClassName} @{declr.identifier} = (@{declr.extractor.extractToClassName}) innerDeclarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, handle.getObject() );
            @code{ i0++ }
          @end{}
        @end{}

        ((@{ruleClassName}.@{className})context).reverse(
            workingMemory,
            handle,
            handle.getObject()@if{globals != empty},@end{}
            @foreach{identifier : globals} @{identifier}@end{","});
    }

    public Object getResult(java.lang.Object workingMemoryContext,
                            java.lang.Object context,
                            org.drools.spi.Tuple leftTuple,
                            org.drools.rule.Declaration[] declarations,
                            org.drools.WorkingMemory workingMemory) throws Exception {
        @code{ i0 = 0 }@foreach{declr : declarations} @{declr.typeName} @{declr.identifier} = ( @{declr.boxedTypeName} ) declarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) leftTuple.get( declarations[@{i0}] ) ).getObject() );
            @code{ i0++ }
        @end{}
        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( "@{identifier}" );
        @end{}

        return ((@{ruleClassName}.@{className})context).getResult(
            @foreach{declr : declarations} @{declr.identifier}@end{","}@if{globals != empty && declarations != empty},@end{}
            @foreach{identifier : globals} @{identifier}@end{","} );
    }

    public boolean supportsReverse() {
        return @{supportsReverse};
    }

    public Object createWorkingMemoryContext() {
        return null;
    }

    @includeNamed{"hashCode"}

    @includeNamed{"equals"}

    public java.util.List getMethodBytecode() {
        java.io.InputStream is = @{ruleClassName}.class.getClassLoader().getResourceAsStream( "@{package}.@{ruleClassName}".replace( '.', '/' ) + "@{'$'}@{className}" + ".class" );

        java.io.ByteArrayOutputStream bos = new java.io.ByteArrayOutputStream();
        byte[] data = new byte[1024];
        int byteCount;
        try {
            while ( (byteCount = is.read( data,
                                 0,
                                 1024 )) > -1 )
            {
                bos.write(data, 0, byteCount);
            }
        } catch ( java.io.IOException e ) {
            throw new org.drools.RuntimeDroolsException("Unable getResourceAsStream for Class '@{ruleClassName}@{'$'}@{className}' ");
        }
        return Collections.singletonList( bos );
    }
}
@end{}

@declare{"consequenceInvoker"}
package @{package};

public class @{invokerClassName} implements org.drools.spi.Consequence, org.drools.spi.CompiledInvoker
{
    private static final long serialVersionUID  = 510l;

    private final String consequenceName = "@{consequenceName}";

    public String getName() {
        return this.consequenceName;
    }

    public void evaluate(org.drools.spi.KnowledgeHelper knowledgeHelper,
                         org.drools.WorkingMemory workingMemory) throws Exception {
        org.drools.spi.Tuple tuple = knowledgeHelper.getTuple();
        org.drools.rule.Declaration[] declarations = ((org.drools.reteoo.RuleTerminalNode)knowledgeHelper.getMatch().getTuple().getLeftTupleSink()).getDeclarations(); 

        @foreach{declr : declarations, index : indexes, notPattern : notPatterns}
          org.drools.common.InternalFactHandle @{declr.identifier}__Handle__ = ( org.drools.common.InternalFactHandle ) tuple.get( declarations[@{index} ] );
          @{declr.typeName} @{declr.identifier} = ( @{declr.boxedTypeName} )  declarations[@{index}].@{declr.nativeReadMethod.name}((org.drools.common.InternalWorkingMemory) workingMemory, @{declr.identifier}__Handle__.getObject() );
          @if{notPattern}@{declr.identifier}__Handle__ =  (org.drools.common.InternalFactHandle) knowledgeHelper.getWorkingMemory().getFactHandle( @{declr.identifier} );@end{}
        @end{}        

        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( "@{identifier}" );
        @end{}

        @{ruleClassName}.@{methodName} (
            knowledgeHelper@if{declarations != empty},@end{}
            @foreach{declr : declarations} @{declr.identifier}, @{declr.identifier}__Handle__
            @end{","}@if{globals != empty},@end{}
            @foreach{identifier : globals} @{identifier}
            @end{","} );
    }
    

    @includeNamed{"hashCode"}

    @includeNamed{"getMethodBytecode"}

    @includeNamed{"equals"}
}
@end{}


@declare{"actionInvoker"}
package @{package};

public class @{invokerClassName} implements org.drools.spi.Action, org.drools.spi.CompiledInvoker
{
    private static final long serialVersionUID  = 510l;

    public void execute(org.drools.spi.KnowledgeHelper knowledgeHelper,
                        org.drools.WorkingMemory workingMemory) throws Exception {
        execute(knowledgeHelper, workingMemory, null);
    }

    public void execute(org.drools.spi.KnowledgeHelper knowledgeHelper,
                        org.drools.WorkingMemory workingMemory, org.drools.spi.ProcessContext context ) throws Exception {

        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( "@{identifier}" );
        @end{}

        @foreach{type : variableTypes, identifier : variables} @{type} @{identifier} = ( @{type} ) context.getVariable( "@{identifier}" );
        @end{}

        @{processClassName}.@{methodName} (
            knowledgeHelper@if{globals != empty},@end{}
            @foreach{identifier : globals} @{identifier}
            @end{","}@if{variables != empty},@end{}
            @foreach{identifier : variables} @{identifier}
            @end{","}, context );
    }
    
    public java.util.List getMethodBytecode() {
        return null;
    }    
}
@end{}

@declare{"returnValueEvaluatorInvoker"}
package @{package};

public class @{invokerClassName} implements org.drools.spi.ReturnValueEvaluator, org.drools.spi.CompiledInvoker
{
    private static final long serialVersionUID  = 510l;

    public Object evaluate(org.drools.WorkingMemory workingMemory, org.drools.spi.ProcessContext processContext) throws Exception {

        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( "@{identifier}" );
        @end{}

        @foreach{type : variableTypes, identifier : variables} @{type} @{identifier} = ( @{type} ) processContext.getVariable( "@{identifier}" );
        @end{}

        return @{processClassName}.@{methodName} (
            processContext@if{globals != empty},@end{}
            @foreach{identifier : globals} @{identifier}
            @end{","}@if{variables != empty},@end{}
            @foreach{identifier : variables} @{identifier}
            @end{","} );
    }
    
    public java.util.List getMethodBytecode() {
        return null;
    }
}
@end{}
