@Library('jenkins-pipeline-shared-libraries')_
import org.jenkinsci.plugins.workflow.libs.Library
import org.kie.jenkins.MavenCommand

String kieBenchmarksRepo = 'kie-benchmarks'

pipeline {
    agent {
        label 'kie-rhel7 && !master'
    }

    tools {
        maven env.BUILD_MAVEN_TOOL
        jdk env.BUILD_JDK_TOOL
    }

    options {
        timestamps()
        timeout(time: 120, unit: 'MINUTES')
        disableConcurrentBuilds(abortPrevious: true)
    }

    // parameters {
    // For parameters, check into .jenkins/dsl/jobs.groovy file
    // }

    environment {
        // Some generated env is also defined into .jenkins/dsl/jobs.groovy file
        DROOLS_CI_EMAIL_TO = credentials("${JENKINS_EMAIL_CREDS_ID}")
    }

    stages {
        stage('Initialization') {
            steps {
                script {
                    cleanWs()

                    // Verify version is set and if on right release branch
                    assert getProjectVersion()
                }
            }
        }
        // this step upgrades after a kogito release the <version.org.drools> in kiegroup/kie-benchmarks to the next SNAPSHOT
        stage('update Drools version in kie-benchmarks') {
            steps {
                script {
                    String commitMsg = 'bumped up Drools version to next SNAPSHOT'
                    String localBranch = 'kie-benchmarks-update'
                    String targetBranch = 'main'
                    dir(kieBenchmarksRepo){
                        checkoutRepo(kieBenchmarksRepo, targetBranch)
                        githubscm.createBranch(localBranch)
                        maven.mvnSetVersionProperty('version.org.drools', getNextMinorSnapshotVersion(getProjectVersion()))
                        // Add changed files, commit, open and merge PR
                        String prLink = commitAndCreatePR(commitMsg, { sh "git add --all" }, localBranch, targetBranch)
                        sh "git checkout ${targetBranch}"
                        mergeAndPush(prLink, targetBranch)
                        githubscm.removeRemoteBranch('origin', localBranch, getGitAuthorCredsId())
                    }
                }
            }
        }
    }
    post {
        unsuccessful {
            sendNotification()
        }
    }
}

void sendNotification() {
    mailer.sendMarkdownTestSummaryNotification('Post-release', "[${getBuildBranch()}] Drools", [env.DROOLS_CI_EMAIL_TO])
}

//////////////////////////////////////////////////////////////////////////////
// Getter / Setter
//////////////////////////////////////////////////////////////////////////////

String getProjectVersion() {
    return params.PROJECT_VERSION
}

String getBuildBranch() {
    return params.BUILD_BRANCH_NAME
}

String getNextMinorSnapshotVersion(String currentVersion) {
    return util.getNextVersion(currentVersion, 'minor')
}

String getGitAuthor() {
    return env.GIT_AUTHOR
}

String getGitAuthorCredsId() {
    return env.AUTHOR_CREDS_ID
}

//////////////////////////////////////////////////////////////////////////////
// Git
//////////////////////////////////////////////////////////////////////////////

void checkoutRepo(String repo, String branch) {
    deleteDir()
    checkout(githubscm.resolveRepository(repo, getGitAuthor(), branch, false, getGitAuthorCredsId()))
    // need to manually checkout branch since on a detached branch after checkout command
    sh "git checkout ${branch}"
}

void mergeAndPush(String prLink, String targetBranch) {
    if (prLink?.trim()) {
        githubscm.mergePR(prLink, getGitAuthorCredsId())
        githubscm.pushObject('origin', targetBranch, getGitAuthorCredsId())
    }
}

String commitAndCreatePR(String commitMsg, Closure precommit, String localBranch, String targetBranch) {
    def prBody = "Generated by build ${BUILD_TAG}: ${BUILD_URL}"
    githubscm.commitChanges(commitMsg, precommit)
    githubscm.pushObject('origin', localBranch, getGitAuthorCredsId())
    return githubscm.createPR(commitMsg, prBody, targetBranch, getGitAuthorCredsId())
}