package org.drools.marshalling.util;

import static junit.framework.Assert.*;
import static org.junit.Assert.fail;

import java.io.File;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.net.URL;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;
import java.util.HashMap;
import java.util.Properties;

import javax.persistence.Table;

@SuppressWarnings("rawtypes")
public class MarshallingDBUtil {


    protected static final String MARSHALLING_TEST_DB = "marshalling/testData";
    protected static final String MARSHALLING_BASE_DB = "marshalling/baseData";

    protected static boolean clearMarshallingTestDb = true;

    /**
     * This method is necessary in order to setup the infrastructure to save, retrieve and compare
     *  the marshalled data generated by Drools/jBPM. 
     * <p/>
     * This method does the following:<ul>
     * <li>Find the (absolute) path of the marshalling test database (which stores marshalled data generated during tests).</li>
     * <li>If this is the first time the test db is being used, delete and recreate the test db for this test run.</li>
     * </ul> 
     * <i>Note</i>: we find the database in src/test/resources -- NOT in target/test-classes/.. or whichever 
     * folder your IDE/build system might copy the database to.
     * <p/>
     * @param jdbcProps The JDBC (database) properties.
     * @param testClass The class of the test being run (that will generate marshalled data).
     * @return A Sting containing the URL (in src/test/resources) of the database.
     */
    public static String initializeTestDb(Properties jdbcProps, Class testClass) { 
        URL dbUrl = testClass.getResource("/" + MARSHALLING_TEST_DB + ".h2.db");
        String dbPath = generateJDBCUrl(testClass);
        
        if( clearMarshallingTestDb ) {
            clearMarshallingTestDb = false;
            deleteTestDatabase(dbUrl, dbPath);
            createMarshallingTestDatabase(dbPath, jdbcProps.getProperty("driverClassName"));
        }
               
        String jdbcURLBase = jdbcProps.getProperty("url");
        return jdbcURLBase + dbPath;
    }
   
    /**
     * This method constructs the path to the database and ensures that the 
     *  file that the path refers to exists.
     * @param testClass The class of the test doing this, in order to access the classLoader/resources.
     * @return A String containg the absolute URL/path of the test DB.
     */
    private static String generateJDBCUrl(Class testClass) { 
        URL classUrl = testClass.getResource(testClass.getSimpleName() + ".class");
        String projectPath = classUrl.getPath().replaceFirst("target.*", "");
        String resourcesPath = projectPath + "src/test/resources/";
        new File(resourcesPath).mkdirs();
        new File(resourcesPath + "marshalling").mkdir();
        String dbPath = resourcesPath + MARSHALLING_TEST_DB;
        return dbPath;
    }
    
    /**
     * This class quickly creates a H2 database containing a table for the MarshalledData entity. 
     * A direct JDBC connection is used for this.
     * <p/>
     * It does NOT matter that the MarshalledData entity table is made -- it was _an_ entity
     *  that was used to create and access the database.
     * <p/>
     * @param dbPath The path to the database.
     * @param driverClass The name of the JDBC driver class.
     */
    private static void createMarshallingTestDatabase(String dbPath, String driverClass) { 
        try { 
            Class.forName(driverClass);
            Connection conn = DriverManager.getConnection("jdbc:h2:"+dbPath);
            conn.setAutoCommit(true);
        
            Statement stat = conn.createStatement();
            String dropTableQuery = "drop table if exists " + getTableName(MarshalledData.class);
            stat.executeUpdate(dropTableQuery);
            
             String createTableQuery = generateH2QLCreateTableQuery(MarshalledData.class);
             stat.executeUpdate(createTableQuery);
            
            conn.close();
        }
        catch (Exception e) {
            e.printStackTrace();
            fail( "Unable to create marshalling database: " + dbPath);
        }
    }

    /**
     * This method deletes the test database file.
     * @param dbUrl 
     * @param dbPath
     */
    private static void deleteTestDatabase(URL dbUrl, String dbPath) { 
        if( dbUrl != null ) { 
            new File(dbUrl.getPath()).delete();
        }
        new File(dbPath + ".h2.db").delete();
    }
    
    
    private static HashMap<Class, String> _typeMapping = null;
   
    private static HashMap<Class, String> getTypeMapping() {
        if( _typeMapping == null ) { 
            _typeMapping = new HashMap<Class, String>();
            _typeMapping.put(Integer.class, "INT");
            _typeMapping.put(String.class, "VARCHAR(255)");
            _typeMapping.put((new byte [0]).getClass(), "BLOB");
        }
        return _typeMapping;
    }
    
    private static String getTableName(Class dataClass) { 
        String tableName = null;
        Annotation [] anno = dataClass.getDeclaredAnnotations();
        for( int i = 0; i < anno.length; ++i ) { 
            Class annoClass = anno[i].annotationType();
            if( annoClass.equals(Table.class) )  { 
                Method [] annoMethod = annoClass.getMethods();
                int a = 0;
                while( a < annoMethod.length && ! annoMethod[a].getName().equals("name") ) {
                  ++a; 
                }
                try { 
                    tableName = (String) annoMethod[a].invoke(anno[i]);
                }
                catch (Exception e) {
                    e.printStackTrace();
                    fail( "Unable to generate HQL query - could not get table name: " + e.getMessage() );
                }
            }
        }
        
        if( tableName == null ) { 
            tableName = dataClass.getName();
            tableName = tableName.substring(tableName.lastIndexOf('.')+1).toLowerCase();
        }
        return tableName;
    }
    
    public static String generateH2QLCreateTableQuery(Class dataClass) { 
        StringBuffer queryString = new StringBuffer("create table ");
   
        String tableName = getTableName(dataClass);
        queryString.append(tableName + "(");
       
        HashMap<Class, String> typeMapping = getTypeMapping();
        
        Field fields [] = dataClass.getDeclaredFields();
        for( int i = 0; i < fields.length; ++i ) { 
            String fieldName = fields[i].getName();
            Class fieldType = fields[i].getType();
            if( i > 0 ) { queryString.append(", "); }
            queryString.append(fieldName + " " + typeMapping.get(fieldType));
        }
        queryString.append(")");
        
        return queryString.toString(); 
    }
}
