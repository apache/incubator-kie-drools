<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">
<section>
  <title>Introduction</title>

  <para>The JBoss Rules workbench is delivered as an eclipse plugin, which
  allows you to author and manage rules from within Eclipse, as well as
  integrate rules with your application. This is an optional tool, and not all
  components are required to be used, you can use what components are relevant
  to you. Other flavours of the workbench will follow, which will be aimed at
  less technical rule management (such as allowing business analysts to review
  and manage rules) - all this is based on the Eclipse platform (hence the
  term "Workbench").</para>

  <para>This guide will cover some of the features of JBoss rules, in as far
  as the workbench touches on them (it is assumed that the reader has some
  familiarity with rule engines, and Drools in particular. It is important to
  note that none of the underlying features of the rule engine are dependent
  on Eclipse, and integrators are free to use their tools of choice, as always
  !</para>

  <para>Note you can get the plug in either as a zip to download, or from an
  update site (refer to the chapter on installation).</para>

  <figure>
    <title>Overview</title>

    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="all.jpg" format="JPG" scalefit="1" />
      </imageobject>
    </mediaobject>
  </figure>

  <section>
    <title>Features outline</title>

    <para>The rules workbench has the following features</para>

    <itemizedlist>
      <listitem>
        <para>Textual/graphical rule editor</para>

        <itemizedlist>
          <listitem>
            <para>An editor that is aware of DRL syntax, and provides content
            assistance (including an outline view)</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Wizards to accellerate and ...</para>

        <itemizedlist>
          <listitem>
            <para>Help you quickly create a new "rules" project</para>
          </listitem>

          <listitem>
            <para>Create a new rule resource</para>
          </listitem>

          <listitem>
            <para>Create a new Domain Specific language</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>A domain specific lanaguage editor</para>

        <itemizedlist>
          <listitem>
            <para>Create and manage mappings from your users language to the
            rule language</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Rule validation</para>

        <itemizedlist>
          <listitem>
            <para>As rules are entered, the rule is "built" in the background
            and errors reported via the problem "view" where possible</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>

    <para>You can see the above features make use of Eclipse infrastructure
    and features. All of the power of eclipse is available.</para>
  </section>

  <section>
    <title>Creating a Rule project</title>

    <para>The aim of the new project wizard is to setup an executable scaffold
    project to start using rules immediately. This will setup a basic
    structure, classpath and sample rules and test case to get you
    started.</para>

    <figure>
      <title>New rule project scaffolding</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="new_project1.jpg" format="JPG" />
        </imageobject>
      </mediaobject>
    </figure>

    <figure>
      <title>New rule project result</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="new_project2.png" format="JPG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The newly created project contains an example rule file (Sample.drl)
    in the src/rules dir and an example java file (DroolsTest.java) that can
    be used to execute the rules in a Drools engine in the folder src/java, in
    the com.sample package. All the others jars that are necessary during
    execution are also added to the classpath in a custom classpath container
    called Drools Library [3.0]. Rules do not have to be kept in "java"
    projects at all, this is just a convenience for people who are already
    using eclipse as their Java IDE.</para>

    <para>Important note: The Drools plug in adds a "Drools Builder"
    capability to your eclipse instance. This means you can enable a builder
    on any project that will build and validate your rules when resources
    change. This happens automatically with the Rule Project Wizard, but you
    can also enable it manually on any project. One downside of this is if you
    have rule files that have a large number of rules (&gt;500 rules per file)
    - as it means that the background builder may be doing a lot of work to
    build the rules on each change. An option here is to turn off the builder,
    or put the large rules into .rule files, where you can still use the rule
    editor, but it won't build them in the background - to fully validate the
    rules you will need to run them in a unit test of course.</para>
  </section>

  <section>
    <title>Creating a new rule and wizards</title>

    <para>You can create a rule simple as an empty text ".drl" file, or use
    the wizard to do so. The wizard menu can be invoked by Control+N, or
    choosing it from the toolbar (there will be a menu with the JBoss Rules
    icon).</para>

    <figure>
      <title>The wizard menu</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="wizards.jpg" format="JPG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The wizard will ask for some basic options for generating a rule
    resource. These are just hints, you can change your mind later !. In terms
    of location, typically you would create a top level /rules directory to
    store your rules if you are creating a rule project, and store it in a
    sutably named subdirectory. The package name is mandatory, and is similar
    to a package name in java (ie. its a namespace that groups like rules
    together).</para>

    <figure>
      <title>New rule wizard</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="new_rule.jpg" format="JPG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>This result of this wizard is to generate a rule skeleton to work
    from. As with all wizards, they are candy: you don't have to use them if
    you don't want !</para>
  </section>

  <section>
    <title>Rule editor</title>

    <para>The rule editor is where rule managers and developers will be
    spending most of their time. The rule editor follows the pattern of a
    normal text editor in eclipse, with all the normal features of a text
    editor. On top of this, the rule editor provides pop up content
    assistance. You invoke popup content assistance the "normal" way by
    pressing Control + Space at the same time.</para>

    <figure>
      <title>The rule editor in action</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="editor1.jpg" format="JPG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The rule editor works on files that have a .drl (or .rule)
    extension. Rules are generally grouped together as a "package" of rules
    (like the old ruleset construct). It will also be possible to have rules
    in individual files (grouped by being in the same package "namespace" if
    you like). These DRL files are plain text files.</para>

    <para>You can see from the example above that the package is using a
    domain specific language (note the expander keyword, which tells the rule
    compiler to look for a dsl file of that name, to resolve the rule
    language). Even with the domain specific language (DSL) the rules are
    still stored as plain text as you see on screen, which allows simpler
    management of rules and versions (comparing versions of rules for
    instance).</para>

    <para>The editor has an outline view that is kept in sync with the
    structure of the rules (updated on save). This provides a quick way of
    navigating around rules by name, in a file which may have hundreds of
    rules. The items are sorted alphabetically by default.</para>

    <figure>
      <title>The rule outline view</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="outline.jpg" format="JPG" />
        </imageobject>
      </mediaobject>
    </figure>
  </section>

  <section>
    <title>Views</title>

    <para>When debugging an application using a Drools engine, three new views
    can be used to check the state of the Drools engine itself: the Working
    Memory View, the Agenda View and the Global Data View. To be able to use
    these views, create breakpoints in your code invoking the working memory.
    For example, the line where you call workingMemory.fireAllRules() is a
    good candidate. If the debugger halts at that joinpoint, you should select
    the working memory variable in the debug variables view. The following
    rules can then be used to show the details of the selected working
    memory:</para>

    <itemizedlist>
      <listitem>
        <para>The Working Memory shows all elements in the working memory of
        the Drools working memory.</para>
      </listitem>

      <listitem>
        <para>The Agenda View shows all elements on the agenda. For each rule
        on the agenda, the rule name and bound variables are shown.</para>
      </listitem>

      <listitem>
        <para>The Global Data View shows all global data currently defined in
        the Drools working memory.</para>
      </listitem>
    </itemizedlist>

    <para>The Audit view can be used to show audit logs that contain events
    that were logged during the execution of a rules engine in a tree
    view.</para>

    <section>
      <title>The Working Memory View</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="workingMemory.png" />
        </imageobject>
      </mediaobject>

      <para>The Working Memory shows all elements in the working memory of the
      Drools engine.</para>

      <para>An action is added to the right of the view, to customize what is
      shown:</para>

      <itemizedlist>
        <listitem>
          <para>The Show Logical Structure toggles showing the logical
          structure of the elements in the working memory, or all their
          details. Logical structures allow for example visualizing sets of
          elements in a more obvious way.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>The Agenda View</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="agenda.png" />
        </imageobject>
      </mediaobject>

      <para>The Agenda View shows all elements on the agenda. For each rule on
      the agenda, the rule name and bound variables are shown.</para>

      <para>An action is added to the right of the view, to customize what is
      shown:</para>

      <itemizedlist>
        <listitem>
          <para>The Show Logical Structure toggles showing the logical
          structure of the agenda item, or all their details. Logical
          structures allow for example visualizing sets of elements in a more
          obvious way. The logical structure of AgendaItems shows the rule
          that is represented by the AgendaItem, and the values of all the
          parameters used in the rule.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>The Global Data View</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="globals.png" />
        </imageobject>
      </mediaobject>

      <para>The Global Data View shows all global data currently defined in
      the Drools engine.</para>

      <para>An action is added to the right of the view, to customize what is
      shown:</para>

      <itemizedlist>
        <listitem>
          <para>The Show Logical Structure toggles showing the logical
          structure of the elements in the working memory, or all their
          details. Logical structures allow for example visualizing sets of
          elements in a more obvious way.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>The Audit View</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="audit.jpg" scalefit="1" width="100%" />
        </imageobject>
      </mediaobject>

      <para>The audit view can be used to visualize an audit log that can be
      created when executing the rules engine. To create an audit log, use the
      following code:</para>

      <programlisting>    WorkingMemory workingMemory = ruleBase.newWorkingMemory();
    // create a new Working Memory Logger, that logs to file.
    WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger(workingMemory);
    // an event.log file is created in the log dir (which must exist)
    // in the working directory
    logger.setFileName("log/event");

    workingMemory.assertObject( ... );
    workingMemory.fireAllRules();

    // stop logging
    logger.writeToDisk();</programlisting>

      <para>Open the log by clicking the Open Log action (first action in the
      Audit View) and select the file. The Audit view now shows all events
      that where logged during the executing of the rules. There are five
      types of events (each with a different icon):</para>

      <itemizedlist>
        <listitem>
          <para>Object asserted (green square)</para>
        </listitem>

        <listitem>
          <para>Object modified (yellow square)</para>
        </listitem>

        <listitem>
          <para>Object retracted (red square)</para>
        </listitem>

        <listitem>
          <para>Activation created (arrow to the right)</para>
        </listitem>

        <listitem>
          <para>Activation cancelled (arrow to the left)</para>
        </listitem>

        <listitem>
          <para>Activation executed (blue diamond)</para>
        </listitem>
      </itemizedlist>

      <para>All these events show extra information concerning the event, like
      the id and toString representation of the object in case of working
      memory events (assert, modify and retract), the name of the rule and all
      the variables bound in the activation in case of an activation event
      (created, cancelled or executed). If an event occurs when executing an
      activation, it is shown as a child of the activation executed event. For
      some events, you can retrieve the "cause":</para>

      <itemizedlist>
        <listitem>
          <para>The cause of an object modified or retracted event is the last
          object event for that object. This is either the object asserted
          event, or the last object modified event for that object.</para>
        </listitem>

        <listitem>
          <para>The cause of an activation cancelled or executed event is the
          corresponding activation created event.</para>
        </listitem>
      </itemizedlist>

      <para>When selecting an event, the cause of that event is shown in green
      in the audit view (if visible of course). You can also right click the
      action and select the "Show Cause" menu item. This will scroll you to
      the cause of the selected event.</para>
    </section>
  </section>

  <section>
    <title>Domain Specific Languages</title>

    <para>Domain Specific Languages (dsl) allow you to create a language that
    allows your rules to look like, rules ! Most often the domain specific
    language reads like natural language. Typically you would look at how a
    business analyst would describe the rule, in their own words, and then map
    this to your object model via rule constructs. A side benefit of this is
    that it can provide an insulation layer between your domain objects, and
    the rules themselves (as we know you like to refactor !). A domain
    specific language will grow as the rules grow, and works best when there
    are common terms used over an over, with different parameters.</para>

    <para>To aid with this, the rule workbench provides an editor for domain
    specific lanaguages (they are stored in a plain text format, so you can
    use any editor of your choice - it uses a slightly enhanced version of the
    "Properties" file format, simply). The editor will be invoked on any files
    with a .dsl extension (there is also a wizard to create a sample
    DSL).</para>

    <section>
      <title>Editing languages</title>

      <figure>
        <title>The Domain Specific Language editor</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="dsl_editor.jpg" format="JPG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The DSL editor provides a table view of Language Expression to
      Rule Expression mapping. The Language expression is what is used in the
      rules. This also feeds the content assistance for the rule editor, so
      that it can suggest Language Expressions from the DSL configuration (the
      rule editor loads up the DSL configuration when the rule resource is
      loaded for editing). The Rule language mapping is the "code" for the
      rules - which the language expression will be compiled to by the rule
      engine compiler. For form of this Rule language depends if it is for a
      condition or action part of a rule (it may be a snippet of java, for
      instance). The "scope" item indicates where the expression is targeted:
      is it for the "when" part of the rule (LHS)? the "then" part (RHS)? Or
      anywhere?</para>

      <para>By selecting a mapping item (a row in the table) you can see the
      expression and mapping in the greyed out fields below. Double clicking
      or pressing the edit button will open the edit dialog. You can remove
      items, and add new ones (you should generally only remove when you know
      that expression is no longer in use).</para>

      <figure>
        <title>Language Mapping editor dialog</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="mapping_editor.jpg"
                       format="JPG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>How it works: the "Language expression" is used to parse the rule
      language, depending on what the "scope" is set to. When it is found in a
      rule, the values that are market by the curly braces {value} are
      extracted from the rule source. These values are then interpolated with
      the "Rule mapping" expression, based on the names between the curly
      braces. So in the example above, the natural language expression mapps
      to 2 contraints on a fact of type Person (ie the person object has the
      age field as less than {age}, and the location value is the string of
      {value}, where {age} and {value} are pulled out of the original rule
      source. The Rule mapping may be a java expression (such as if the scope
      was "then"). If you did not wish to use a language mapping for a
      particular rule in a drl, prefix the expression with &gt; and the
      compiler will not try to translate it according to the language
      definition. Also note that domain specific languages are optional. When
      the rule is compiled, the .dsl file will also need to be
      avilable.</para>
    </section>
  </section>

  <section>
    <title>The Rete View</title>

    <para>The Rete Tree View shows you the current Rete Network for your drl
    file. Just click on the tab "Rete Tree" below on the DRL Editor.
    Afterwards you can generate the current Rete Network visualisation. You
    can push and pull the nodes to arrange your optimal network overview. If
    you got hundreds of nodes, select some of them with a frame. Then you can
    pull groups of them. You can zoom in and out, in case not all nodes are
    shown in the current view. For this press the button "+" oder "-".</para>

    <para>There is no export function, which creates a gif or jpeg picture, in
    the current release. Please use ctrl + alt + print to create a copy of
    your current eclipse window and cut it off.</para>

    <mediaobject>
      <imageobject>
        <imagedata fileref="thereteview.jpg" />
      </imageobject>
    </mediaobject>

    <para>The graph is created with the Java Universal Network/Graph Framework
    (<ulink url="http://jung.sourceforge.net/">JUNG</ulink>). The Rete View is
    an advanced feature which is still in experimental state. It uses Swing
    inside eclipse. In future it will maybe improved using SWT or GEF.</para>

    <para>The Rete view works only in Drools Rule Projects, where the Drools
    Builder is set in the projectÂ´s properties.</para>

    <para>If you are using Drools in an other type of project, where you are
    not having a Drools Rule Project with the appropiate Drools Builder, you
    can create a little workaround:</para>

    <para>Set up a little Drools Rule Project next to it, putting needed
    libraries into it and the drls you want to inspect with the Rete View.
    Just click on the right tab below in the DRL Editor, followed by a click
    on "Generate Rete View".</para>
  </section>

  <section>
    <title>Large drl files</title>

    <para>Depending on the JDK you use, it may be necessary to increase the
    permanent generation max size. Both SUN and IBM jdk have a permanent
    generation, whereas BEA JRockit does not.</para>

    <para>To increase the permanent generation, start eclipse with
    -XX:MaxPermSize=###m</para>

    <para>Example: c:\eclipse\eclipse.exe -XX:MaxPermSize=128m</para>

    <para>Rulesets of 4,000 rules or greater should set the permanent
    generation to atleast 128Mb.</para>

    <para>(note that this may also apply to compiling large numbers of rules
    in general - as there is generally one or more classes per rule).</para>

    <para>As an alternative to the above, you may put rules in a file with the
    ".rule" extension, and the background builder will not try to compile them
    with each change, which may provide performance improvements if your IDE
    becomes sluggish with very large numbers of rules.</para>
  </section>
</section>