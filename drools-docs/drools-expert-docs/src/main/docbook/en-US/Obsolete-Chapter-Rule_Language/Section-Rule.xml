<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="../" xmlns="http://docbook.org/ns/docbook" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:ns="http://docbook.org/ns/docbook">
  <title>Rule</title>

  <figure>
    <title>rule</title>

    <mediaobject>
     <imageobject>
       <imagedata align="center" fileref="images/Chapter-Rule_Language/rule.png" format="PNG" role="" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>A rule specifies that "when" a particular set of conditions occur,
  specified in the Left Hand Side (LHS), then do this, which is specified as a
  list of actions in the Right Hand Side (RHS). A common question from users
  is "why use when instead of if". "when" was chosen over "if" because "if" is
  normally part of a procedural execution flow, where at a specific point in
  time it checks the condition. Where as "when" indicates it's not tied to a
  specific evaluation sequence or point in time, at any time during the life
  time of the engine "when" this occurs, do that Rule.</para>

  <para>A rule must have a name, unique within its rule package. If
  you define a rule twice in the same DRL it produces an error while loading.
  If you add a DRL that includes a rule name already in the package, it
  replaces the previous rule. If a rule name is to have spaces, then it
  will need to be enclosed in double quotes (it is best to always use double
  quotes).</para>

  <para>Attributes are optional, and are described below (they are best kept
  as one per line).</para>

  <para>The LHS of the rule follows the "when" keyword (ideally on a new
  line), similarly the RHS follows the "then" keyword (ideally on a newline).
  The rule is terminated by the keyword "end". Rules cannot be nested of
  course.</para>

  <example>
    <title>Rule Syntax Overview Example</title>

    <programlisting>rule "&lt;name&gt;"
    &lt;attribute&gt;*
when
    &lt;conditional element&gt;*
then
    &lt;action&gt;*
end</programlisting>
  </example>

  <example>
    <title>A rule example</title>

    <programlisting>rule "Approve if not rejected"
  salience -100 
  agenda-group "approval"
    when
        not Rejection() 
        p : Policy(approved == false, policyState:status)
        exists Driver(age &gt; 25)
        Process(status == policyState)
    then
        log("APPROVED: due to no objections."); 
        p.setApproved(true);
end</programlisting>
  </example>

  <section>
    <title>Rule Attributes</title>

    <para>Rule attributes provide a declarative way to influence the behavior
    of the rule. Some are quite simple, while others are part of complex sub
    systems such as ruleflow. To get the most from Drools you should make
    sure you have a proper understanding of each attribute.</para>

    <figure>
      <title>rule attributes</title>

      <mediaobject>
        <imageobject>
    <imagedata align="center" fileref="images/Chapter-Rule_Language/rule_attributes.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <variablelist>
      <varlistentry>
  <term>no-loop</term>

  <listitem>
    <para>default value: false</para>

    <para>type: Boolean</para>

    <para>When the Rule's consequence modifies a fact it may cause
      the Rule to activate again, causing recursion. Setting no-loop
      to true means the attempt to create the Activation for the
      current set of data will be ignored.</para>
  </listitem>

      </varlistentry>

      <varlistentry>
  <term>lock-on-active</term>

  <listitem>
    <para>default value: false</para>

    <para>type: Boolean</para>
    <para>Whenever a ruleflow-group becomes active or an
      agenda-group receives the focus, any rule within that
      group that has lock-on-active set to true will not be
      activated any more; irrespective of the origin of the
      update, the activation of a matching rule is discarded.
      This is a stronger version of no-loop, because the change
      could now be caused not only by the rule itself. It's
      ideal for calculation rules where you have a number of
      rules that modify a fact and you don't want any rule
      re-matching and firing again. Only when the ruleflow-group
      is no longer active or the agenda-group loses the focus
      those rules with lock-on-active set to true become
      eligible again for their activations to be placed onto
      the agenda.</para>
  </listitem>
      </varlistentry>

      <varlistentry>
  <term>salience</term>

  <listitem>
    <para>default value : 0</para>

    <para>type : integer</para>

    <para>Each rule has a salience attribute that can be assigned
      an Integer number, defaults to zero, the Integer and can be
      negative or positive. Salience is a form of priority where
      rules with higher salience values are given higher priority
      when ordered in the Activation queue.</para>
      <para>Drools also supports dynamic salience where you can use andexpression involving bound variables.</para>
          
          <example>
        <title>Dynamic Salience</title>
        <programlisting>rule "Fire in rank order 1,2,.."
          salience( -$rank )
          when
              Element( $rank : rank,... )
          then
              ...
        end</programlisting>
      </example>
  </listitem>
      </varlistentry>


      <varlistentry>
  <term>agenda-group</term>

  <listitem>
    <para>default value: MAIN</para>

    <para>type: String</para>

    <para>Agenda group's allow the user to partition the Agenda providing more execution control. Only rules in the focus group are allowed to fire.</para>
  </listitem>
      </varlistentry>

      <varlistentry>
  <term>auto-focus</term>

  <listitem>
    <para>default value: false</para>

    <para>type: Boolean</para>

    <para>When a rule is activated if the <literal>auto-focus value is true and the Rule's </literal> <literal>agenda-group</literal> does not have focus then it is given focus, allowing the rule to potentially fire.</para>
  </listitem>
      </varlistentry>

      <varlistentry>
  <term>activation-group</term>

  <listitem>
    <para>default value: N/A</para>

    <para>type: String</para>

    <para>Rules that belong to the same named activation-group will only fire exclusively. In other words, the first rule in an activation-group to fire will cancel the other rules activations (stop them from firing). The Activation group attribute is any string, as long as the string is identical for all the rules you need to be in the one group.</para>

    <para>NOTE: this used to be called Xor group, but technically its not quite an Xor, but you may hear people mention Xor group, just swap that term in your mind with activation-group.</para>
  </listitem>
      </varlistentry>

      <varlistentry>
  <term>dialect</term>

  <listitem>
    <para>default value : as specified by the package</para>

    <para>type : String</para>

    <para>possible values: "java" or "mvel"</para>

    <para>The dialect species the language to be used for any code
      expressions in the LHS or the RHS code block. Currently two dialects are available, Java and MVEL. While the dialect can be specified at the package level, this attribute allows the package definition to be overridden.</para>
  </listitem>
      </varlistentry>


      <varlistentry>
  <term>date-effective</term>

  <listitem>
    <para>default value: N/A</para>

    <para>type: String, which contains a date and time definition</para>

    <para>A rule can only activate if the current date and time is after date-effective attribute.</para>
  </listitem>
      </varlistentry>

      <varlistentry>
  <term>date-expires</term>

  <listitem>
    <para>default value: N/A</para>

    <para>type: String, which contains a date and time definition</para>

    <para>A rule cannot activate if the current date and time is after date-expires attribute.</para>
  </listitem>
      </varlistentry>

      <varlistentry>
  <term>duration</term>

  <listitem>
    <para>default value: no default value</para>

    <para>type: long</para>

    <para>The duration dictates that the rule will fire after a specified duration, if it is still true.</para>
  </listitem>
      </varlistentry>
    </variablelist>

    <example>
      <title>Some attribute examples</title>

      <programlisting>rule "my rule"
  salience 42
  agenda-group "number 1"
    when ...
</programlisting>
    </example>
    <section>
      <title>Timers and Calendars</title>

      <para>Rule's now suport both interval and cron based timers, which
      replace the now deprecated duration attribute.</para>

      <example>
        <title>Sample timer attribute uses</title>

        <programlisting language="java">timer ( int: &lt;initial delay&gt; &lt;repeat interval&gt;? )
timer ( int: 30s )
timer ( int: 30s 5m )
 
timer ( cron: &lt;cron expression&gt; )
timer ( cron:* 0/15 * * * ? )</programlisting>
      </example>

      <para>Interval "int:" timers follow the JDK semantics for initial delay
      optionally followed by a repeat interval. Cron "cron:" timers follow
      standard cron expressions:</para>

      <example>
        <title>A Cron Example</title>

        <programlisting language="java">rule "Send SMS every 15 minutes"
    timer (cron:* 0/15 * * * ?)
when
    $a : Alarm( on == true )
then
    channels[ "sms" ].insert( new Sms( $a.mobileNumber, "The alarm is still on" );
end</programlisting>
      </example>

      <para>Calendars can now controll when rules can fire. The Calendar api
      is modelled on <link
      xlink:href="http://www.quartz-scheduler.org/">Quartz
      http://www.quartz-scheduler.org/</link> :</para>

      <example>
        <title>Adapting a Quartz Calendar</title>

        <programlisting language="java">Calendar weekDayCal = QuartzHelper.quartzCalendarAdapter(org.quartz.Calendar quartzCal)</programlisting>
      </example>

      <para>Calendars are registered with the StatefulKnowledgeSession:</para>

      <example>
        <title>Registering a Calendar</title>

        <programlisting language="java">ksession.getCalendars().set( "week day", weekDayCal );</programlisting>
      </example>

      <para>They can be used in conjunction with normal rules and rules
      including timers. The rule calendar attribute can have one or more comma
      calendar names.</para>

      <example>
        <title>Using Calendars and Timers together</title>

        <programlisting language="java">rule "weekdays are high priority"
   calendars "weekday"
   timer (int:0 1h)
when 
    Alarm()
then
    send( "priority high - we have an alarm” );
end 

rule "weekend are low priority"
   calendars "weekend"
   timer (int:0 4h)
when 
    Alarm()
then
    send( "priority low - we have an alarm” );
end</programlisting>
      </example>
   </section>
   </section>

  <section id="RuleLanguage-ConditionalElements">
    <title>Left Hand Side (when) Conditional Elements</title>

    <para>The Left Hand Side (LHS) is a common name for the conditional part
    of the rule. It consists of zero or more Conditional Elements. If the LHS
    is left empty it is re-written as eval(true), which means the rule is
    always true, and will be activated when a new Working Memory session is
    created.</para>

    <figure>
      <title>Left Hand Side</title>

      <mediaobject>
        <imageobject>
    <imagedata align="center" fileref="images/Chapter-Rule_Language/lhs.png" format="PNG" role="" />
        </imageobject>
      </mediaobject>
    </figure>

    <example>
      <title>Rule without a Conditional Element</title>

      <programlisting>rule "no CEs"
when
then
    &lt;action&gt;*
end</programlisting>

      <para>Is internally re-written as:</para>

      <programlisting>rule "no CEs"
when
    eval( true )
then
    &lt;action&gt;*
end</programlisting>
    </example>

    <para>Conditional elements work on one or more <emphasis>patterns</emphasis> (which are
    described below). The most common one is "and" which is implicit when you
    have multiple patterns in the LHS of a rule that are not connected in
    any way. Note that an 'and' cannot have a leading declaration binding like
    'or'. This is obvious, since a declaration can only
    reference a single fact, and when the 'and' is satisfied it matches more than
    one fact - which fact would the declaration bind to?</para>

    <section>
      <title>Pattern</title>

      <para>The pattern element is the most important Conditional Element. The
      entity relationship diagram below provides an overview of the various
      parts that make up the pattern's constraints and how they work together;
      each is then covered in more detail with railroad diagrams and
      examples.</para>

      <figure>
        <title>Pattern Entity Relationship Diagram</title>

        <mediaobject>
          <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/patternER.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>At the top of the ER diagram you can see that the pattern consists
      of zero or more constraints and has an optional pattern binding. The
      railroad diagram below shows the syntax for this.</para>

      <figure>
        <title>Pattern</title>

        <mediaobject>
          <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/pattern.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>In its simplest form, with no constraints, it simply matches against a
      type. In the following case the type is "Cheese", which means that the pattern
      will match against all Cheese objects in the Working Memory.</para>

      <example>
        <title>Simple Pattern</title>

        <programlisting>Cheese( )</programlisting>
      </example>

      <para>To be able to refer to the matched object use a pattern binding
      variable such as '$c'. While this example variable is prefixed with a $
      symbol, it is optional, but can be useful in complex rules as it helps
      to more easily differentiation between variables and fields.</para>

      <example>
        <title>Pattern with a binding variable</title>

        <programlisting>$c : Cheese( )</programlisting>
      </example>

      <para>Inside of the pattern parenthesis is where all the action happens.
      A constraint can be either a Field Constraint, Inline Eval (called a
      predicate in 3.0) or a Constraint Group. Constraints can be separated by
      the following symbols: ',', '&amp;&amp;' or '||'.</para>

      <figure>
        <title>Constraints</title>

        <mediaobject>
          <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/constraints.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>Constraint</title>

        <mediaobject>
          <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/constraint.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>Group Constraint</title>

        <mediaobject>

          <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/constraintGroup.png"
                       format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The ',' (comma) character is used to separate constraint groups.
      It has implicit 'and' connective semantics.<example>
          <title>Constraint Group connective ','</title>

          <programlisting># Cheese type is stilton and price &lt; 10 and age is mature.
Cheese( type == "stilton", price &lt; 10, age == "mature" )</programlisting>
        </example>The above example has 3 constraint groups, each with a
      single constraint:</para>

      <itemizedlist>
        <listitem>
          <para>group 1: type is stilton -&gt; type == "stilton"</para>
        </listitem>

        <listitem>
          <para>group 2: price is less than 10 -&gt; price &lt; 10</para>
        </listitem>

        <listitem>
          <para>group 3: age is mature -&gt; age == "mature"</para>
        </listitem>
      </itemizedlist>

      <para>The '&amp;&amp;' (and) and '||' (or) constraint connectives allow
      constraint groups to have multiple constraints. Example:</para>

      <example>
        <title>&amp;&amp; and || Constraint Connectives</title>

        <programlisting>Cheese( type == "stilton" &amp;&amp; price &lt; 10, age == "mature" ) // Cheese type is "stilton" and price &lt; 10, and age is mature
Cheese( type == "stilton" || price &lt; 10, age == "mature" ) // Cheese type is "stilton" or price &lt; 10, and age is mature</programlisting>
      </example>

      <para>The above example has two constraint groups. The first has 2
      constraints and the second has one constraint.</para>

      <para>The connectives are evaluated in the following order, from first
      to last:</para>

      <orderedlist>
        <listitem>
          <para>&amp;&amp;</para>
        </listitem>

        <listitem>
          <para>||</para>
        </listitem>

        <listitem>
          <para>,</para>
        </listitem>
      </orderedlist>

      <para>It is possible to change the evaluation priority by using
      parenthesis, as in any logic or mathematical expression. Example:</para>

      <example>
          <title>Using parenthesis to change evaluation priority</title>

          <programlisting># Cheese type is stilton and ( price is less than 20 or age is mature ).
Cheese( type == "stilton" &amp;&amp; ( price &lt; 20 || age == "mature" ) ) </programlisting>
        </example>
      <para>In the above example, the use of parenthesis makes the ||
      connective be evaluated before the &amp;&amp; connective.</para>

      <para>Also, it is important to note that besides having the same
      semantics, the connectives '&amp;&amp;' and ',' are resolved with
      different priorities and ',' cannot be embedded in a composite
      constraint expression.</para>

      <example>
        <title>Not Equivalent connectives</title>

        <programlisting>Cheese( ( type == "stilton", price &lt; 10 ) || age == "mature" ) // invalid as ',' cannot be embedded in an expression
Cheese( ( type == "stilton" &amp;&amp; price &lt; 10 ) || age == "mature") // valid as '&amp;&amp;' can be embedded in an expression</programlisting>
      </example>

      <section>
        <title>Field Constraints</title>

        <para>A Field constraint specifies a restriction to be used on a field
        name; the field name can have an optional variable binding.</para>

        <figure>
          <title>fieldConstraint</title>

          <mediaobject>

            <imageobject>
        <imagedata align="center" fileref="images/Chapter-Rule_Language/fieldConstraint.png"
                         format="PNG" role="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>There are three types of restrictions; Single Value Restriction,
        Compound Value Restriction and Multi Restriction.</para>

        <figure>
          <title>restriction</title>

          <mediaobject>

            <imageobject>
        <imagedata align="center" fileref="images/Chapter-Rule_Language/restriction.png" format="PNG"
                         role="" />
            </imageobject>
          </mediaobject>
        </figure>

        <section>
          <title>JavaBeans as facts</title>

          <para>A field is an accessible method on the object. If your model
          objects follow the Java bean pattern, then fields are exposed using
          "getXXX" or "isXXX" methods (these are methods that take no
          arguments, and return something). You can access fields either by
          using the bean naming convention (so "getType" can be accessed as
          "type") - we use the standard jdk Introspector class to do this
          mapping.</para>

          <para>For example, referring to our Cheese class, the pattern
          Cheese(type == ...) applies the getType() method to a Cheese
          instance. If a field name cannot be found it will resort to calling
          the name as a no argument method; "toString()" on the Object for
          instance can be used with Cheese(toString == ..) - you use the full
          name of the method with correct capitalization, but without parentheses. Do
          please make sure that you are accessing methods that take no
          parameters, and are in-fact "accessors" which don't change
          the state of the object in a way that may effect the rules.
          Remember that the rule engine effectively caches the results of its
          matching in between invocations to make it faster.</para>
        </section>

        <section>
          <title>Values</title>

          <para>The field constraints can take a number of values; including
          literal, qualifiedIdentifier (enum), variable and
          returnValue.</para>

          <figure>
            <title>literal</title>

            <mediaobject>
              <imageobject>
          <imagedata align="center" fileref="images/Chapter-Rule_Language/literal.png" format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <figure>
            <title>qualifiedIdentifier</title>

            <mediaobject>
              <imageobject>
          <imagedata align="center" fileref="images/Chapter-Rule_Language/qualifiedIdentifier.png"
                           format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <figure>
            <title>variable</title>

            <mediaobject>

              <imageobject>
          <imagedata align="center" fileref="images/Chapter-Rule_Language/identifier.png"
                           format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <figure>
            <title>returnValue</title>

            <mediaobject>
              <imageobject>
          <imagedata align="center" fileref="images/Chapter-Rule_Language/returnValue.png"
                           format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>You can do checks against fields that are or may be null, using
          == and != as you would expect, and the literal "null" keyword, like:
          Cheese(type != null). If a field is null the evaluator will not
          throw an exception and will only return true if the value is null.
          Coercion is always attempted if the field and the value are
          of different types; exceptions will be thrown if bad coercions are
          attempted. For instance, if "ten" is provided as a string in a number
          evaluator an exception is thrown, whereas "10" would coerce to a
    numeric 10. Coercion is
          always in favor of the field type and not the value type.</para>
        </section>

        <section>
          <title>Single Value Restriction</title>

          <figure>
            <title>singleValueRestriction</title>

            <mediaobject>
              <imageobject>
          <imagedata align="center" fileref="images/Chapter-Rule_Language/singleValueRestriction.png"
                           format="PNG" role="" />
              </imageobject>
            </mediaobject>
          </figure>

          <section>
            <title>Operators</title>

            <figure>
              <title>Operators</title>

              <mediaobject>
                <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/operator.png"
                             format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <para>Valid operators are dependent on the field type. Generally
            they are self explanatory based on the type of data: for instance,
            for date fields, "&lt;" means "before". "Matches" is
            only applicable to string fields, "contains" and "not contains" is
            only applicable to Collection type fields. These operators can be
            used with any value and coercion to the correct value for the
            evaluator and field will be attempted, as mentioned in the "Values"
            section.</para>

            <simplesect>
              <title>Matches Operator</title>

              <para>Matches a field against any valid Java <indexterm>
                  <primary>regular expression</primary>
                </indexterm>Regular Expression. Typically that regexp is a
              String, but variables that resolve to a valid regexp are also
              allowed. It is important to note that, <emphasis>different from
              Java</emphasis>, if you write a String regexp directly on the
              source file, <emphasis>you don't need to escape '\'</emphasis>.
              Example:</para>

              <example>
                <title>Regular Expression Constraint</title>

                <programlisting>Cheese( type matches "(Buffalo)?\S*Mozerella" )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>Not Matches Operator</title>

              <para>Any valid Java <indexterm>
                  <primary>regular expression</primary>
                </indexterm>Regular Expression can be used to match String
              fields. This operator returns true when the match is false. Typically that
              regexp is a String, but variables that resolve to a valid regexp
              are also allowed. It is important to note that,
              <emphasis>different from Java</emphasis>, if you write a String
              regexp directly on the source file, <emphasis>you don't need to
              escape '\'</emphasis>. Example:</para>

              <example>
                <title>Regular Expression Constraint</title>

                <programlisting>Cheese( type not matches "(Buffulo)?\S*Mozerella" )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>Contains Operator</title>

              <para><literal>'contains'</literal> is used to check if a
              field's <indexterm>
                  <primary>Collection</primary>
                </indexterm>Collection or array contains the specified
              value.</para>

              <example>
                <title>Contains with Collections</title>

                <programlisting>CheeseCounter( cheeses contains "stilton" ) // contains with a String literal
CheeseCounter( cheeses contains $var ) // contains with a variable</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>not contains</title>

              <para><literal>'not contains'</literal> is used to check if a
              field's <indexterm>
                  <primary>Collection</primary>
                </indexterm>Collection or array does not contain an
              object.</para>

              <example>
                <title>Literal Constraints with Collections</title>

                <programlisting>CheeseCounter( cheeses not contains "cheddar" ) // not contains with a String literal
CheeseCounter( cheeses not contains $var ) // not contains with a variable</programlisting>
              </example>

              <blockquote>
                <para><emphasis role="bold">NOTE: </emphasis>for backward
                  compatibility, the '<emphasis
                  role="bold">excludes</emphasis>' operator is supported as a
                  synonym for '<emphasis role="bold">not
                  contains</emphasis>'.</para>
              </blockquote>
            </simplesect>

            <simplesect>
              <title>memberOf</title>

              <para><literal>'memberOf'</literal> is used to check if a field is a
              member of a collection or array; that collection must be be a
              variable.</para>

              <example>
                <title>Literal Constraints with Collections</title>

                <programlisting>CheeseCounter( cheese memberOf $matureCheeses )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>not memberOf</title>

              <para><literal>'not memberOf'</literal> is used to check if a field is not
              a member of a collection or array; that collection must be be a
              variable.</para>

              <example>
                <title>Literal Constraints with Collections</title>

                <programlisting>CheeseCounter( cheese not memberOf $matureCheeses )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>soundslike</title>

              <para>Similar to <literal>'matches'</literal>, but checks if a word has
              almost the same sound as the given value. Uses the
              <link xlink:href="http://en.wikipedia.org/wiki/Soundex">Soundex</link> algorithm.</para>

              <example>
                <title>Text with soundslike (Sounds Like)</title>

                <programlisting>Cheese( name soundslike 'foobar' )</programlisting>
              </example>
                <para>This will match a cheese with a name of "fubar"</para>
            </simplesect>
          </section>

          <section>
            <title>Literal Restrictions</title>

            <para>Literal restrictions are the simplest form of restrictions
            and evaluate a field against a specified literal; numeric, date,
            string or boolean.</para>

            <figure>
              <title>literalRestriction</title>

              <mediaobject>
                <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/literalRestriction.png"
                             format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <para>Literal Restrictions using the '==' operator, provide for
            faster execution as we can index using hashing to improve
            performance.</para>

            <simplesect>
              <title>Numeric</title>

              <para>All standard Java numeric primitives are supported.</para>

              <example>
                <title>Numeric Literal Restriction</title>

                <programlisting>Cheese( quantity == 5 )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>Date</title>

              <para>The date format "dd-mmm-yyyy" is supported by default. You
              can customize this by providing an alternative date format mask
              as a System property ("drools.dateformat" is the name of the
              property). If more control is required, use the inline-eval
              constraint.</para>

              <example>
                <title>Date Literal Restriction</title>

                <programlisting>Cheese( bestBefore &lt; "27-Oct-2007" )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>String</title>

              <para>Any valid Java String is allowed.</para>

              <example>
                <title>String Literal Restriction</title>

                <programlisting>Cheese( type == "stilton" )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>Boolean</title>

              <para>Only true or false can be used; 0 and 1 are not
              recognized. A Boolean field alone (as in
    <code>Cheese( smelly )</code> is not permitted.</para>

              <example>
                <title>Boolean Literal Restriction</title>

                <programlisting>Cheese( smelly == true )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>Qualified Identifier</title>

              <para>Enums can be used as well, both jdk1.4 and jdk5 style
              enums are supported. For the latter you must be executing on a
              jdk5 environment.</para>

              <example>
                <title>Boolean Literal Restriction</title>

                <programlisting>Cheese( smelly == SomeClass.TRUE )</programlisting>
              </example>
            </simplesect>
          </section>

          <section>
            <title>Bound Variable Restriction</title>

            <figure>
              <title>variableRestriction</title>

              <mediaobject>

                <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/variableRestriction.png"
                             format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <para>Variables can be bound to Facts and their Fields and then
            used in subsequent Field Constraints. A bound variable is called a
            <indexterm>
                <primary>declaration</primary>
              </indexterm>Declaration. Valid operators are determined by the
            type of the field being constrained; coercion will be attempted
            where possible. Bound Variable Restrictions using '==' operator,
            provide for very fast execution as we can index using hashing to
            improve performance.</para>

            <example>
              <title>Bound Field using '==' operator</title>

              <programlisting>Person( likes : favouriteCheese )
Cheese( type == likes )</programlisting>

              <para>'likes' is our variable, our Declaration, that is bound to
              the favouriteCheese field for any matching Person instance and
              is used to constrain the type of Cheese in the following
              pattern. Any valid Java variable name can be used, and it may
    be prefixed with a '$', which you will often see used to help differentiate
              declarations from fields. The example below shows a declaration
              bound to the pattern's Object Type instance itself and used with
              a 'contains' operator. Note the optional use of '$'.</para>
            </example>

            <example>
              <title>Bound Fact using 'contains' operator</title>

              <programlisting>$stilton : Cheese( type == "stilton" )
Cheesery( cheeses contains $stilton )</programlisting>
            </example>
          </section>

          <section>
            <title>Return Value Restriction</title>

            <figure>
              <title>returnValueRestriction</title>

              <mediaobject>
                <imageobject>
                  <imagedata align="center"
           fileref="images/Chapter-Rule_Language/returnValueRestriction.png" format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <para>A <indexterm>
                <primary>Return Value</primary>
              </indexterm>Return Value restriction can use any valid Java
            primitive or object. Avoid using any Drools keywords as
            Declaration identifiers. Functions used in a Return Value
            Restriction must return time constant results. Previously bound
            declarations can be used in the expression.</para>

            <example>
              <title>Return Value Restriction</title>

              <programlisting>Person( girlAge : age, sex == "F" )
Person( age == ( girlAge + 2) ), sex == 'M' )
</programlisting>
            </example>
          </section>
        </section>

        <section>
          <title>Compound Value Restriction</title>

          <para>The compound value restriction is used where there is more
          than one possible value, currently only the 'in' and 'not in'
          evaluators support this. The operator takes a parenthesis enclosed
          comma separated list of values, which can be a variable, literal,
          return value or qualified identifier. The 'in' and 'not in'
          evaluators are actually sugar and are rewritten as a multi
          restriction list of != and == restrictions.</para>

          <figure>
            <title>compoundValueRestriction</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center"
         fileref="images/Chapter-Rule_Language/compoundValueRestriction.png" format="PNG"
                           role="" />
              </imageobject>
            </mediaobject>
          </figure>

          <para></para>

          <example>
            <title>Compound Restriction using 'in'</title>

            <programlisting>Person( $cheese : favouriteCheese )
Cheese( type in ( "stilton", "cheddar", $cheese )
</programlisting>
          </example>
        </section>

        <section>
          <title>Multi Restriction</title>

          <para>Multi restriction allows you to place more than one
          restriction on a field using the '&amp;&amp;' or '||' restriction
          connectives. Grouping via parenthesis is also allowed; which adds a
          recursive nature to this restriction.</para>

          <figure>
            <title>multiRestriction</title>

            <mediaobject>
              <imageobject>
          <imagedata align="center" fileref="images/Chapter-Rule_Language/multiRestriction.png"
                           format="PNG" role="" />
              </imageobject>
            </mediaobject>
          </figure>

          <figure>
            <title>restrictionGroup</title>

            <mediaobject>
              <imageobject>
          <imagedata align="center" fileref="images/Chapter-Rule_Language/restrictionGroup.png"
                           format="PNG" role="" />
              </imageobject>
            </mediaobject>
          </figure>

          <para></para>

          <example>
            <title>Multi Restriction</title>

            <programlisting>Person( age &gt; 30 &amp;&amp; &lt; 40 ) // simple multi restriction using a single &amp;&amp;
Person( age ( (&gt; 30 &amp;&amp; &lt; 40) || (&gt; 20 &amp;&amp; &lt; 25) ) ) // more complex multi restriction using groupings of multi restrictions
Person( age &gt; 30 &amp;&amp; &lt; 40 || location == "london" ) // mixing muti restrictions with constraint connectives</programlisting>
          </example>
        </section>
      </section>

      <section>
        <title>Inline Eval Constraints</title>

        <figure>
          <title>Inline Eval Expression</title>

          <mediaobject>
            <imageobject>
        <imagedata align="center" fileref="images/Chapter-Rule_Language/inlineEvalConstraint.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>An <indexterm>
            <primary>Predicate</primary>
          </indexterm>inline-eval constraint can use any valid dialect
        expression as long as it is evaluated to a primitive boolean - avoid
        using any Drools keywords as Declaration identifiers. The expression
        must be time constant. Any previously bound variable, from the current
        or previous pattern, can be used; autovivification is also used to
        auto-create field binding variables. When an identifier is found that
        is not a current variable the builder looks to see if the identifier
        is a field on the current object type, if it is, the field binding
  is auto-created as a variable of the same name. This is called
  autovivification of field variables inside of inline evals.</para>

        <para>This example will find all male-female pairs where the
        male is 2 years older than the female; the boyAge variable is
  auto-created by the autovivification process.</para>

        <example>
          <title>Return Value operator</title>

          <programlisting>Person( girlAge : age, sex = "F" )
Person( eval( age == girlAge + 2 ), sex = 'M' )
</programlisting>
        </example>
      </section>

      <section>
        <title>Nested Accessors</title>

        <para>Drools does allow for nested accessors in in the field
        constraints using the MVEL accessor graph notation. Field constraints
        involving nested accessors are actually re-written as an MVEL dialect
        inline-eval. Care should be taken when using nested accessors as the
        Working Memory is not aware of any of the nested values, and do not
        know when they change; they should be considered immutable while any
        of their parent references are inserted into the Working Memory. If
        you wish to modify a nested value you should remove the parent objects
        first and re-assert afterwards. If you only have a single parent at
        the root of the graph, when in the MVEL dialect, you can use the
        'modify' keyword and its block setters to write the nested accessor
        assignments while retracting and inserting the the root parent object
        as required. Nested accessors can be used either side of the operator
        symbol.</para>

        <example>
          <title>Nested Accessors</title>

          <programlisting>$p : Person( ) 
Pet( owner == $p, age &gt; $p.children[0].age ) // Find a pet who is older than their owners first born child</programlisting>

          <para>is internally rewriten as an MVEL inline eval:</para>

          <programlisting>$p : Person( ) 
Pet( owner == $p, eval( age &gt; $p.children[0].age ) ) // Find a pet who is older than their owners first born child</programlisting>
        </example>

        <remark>NOTE: nested accessors have a much greater performance cost
        than direct field access, so use them carefully.</remark>
      </section>
    </section>

    <section>
      <title>'and'</title>

      <para>The 'and' Conditional Element is used to group together other
      Conditional Elements. The root element of the LHS is an implicit prefix
      And and doesn't need to be specified. Drools supports both prefix and
      infix; although prefix is the preferred option as grouping is implicit
      which avoids confusion.</para>

      <figure>
        <title>prefixAnd</title>

        <mediaobject>
          <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/prefixAnd.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <example>
        <title>prefixAnd</title>

        <programlisting>(and Cheese( cheeseType : type )
     Person( favouriteCheese == cheeseType ) )
</programlisting>
      </example>

      <example>
        <title>implicit root prefixAnd</title>

        <programlisting>when
     Cheese( cheeseType : type )
     Person( favouriteCheese == cheeseType )</programlisting>
      </example>

      <para>Infix 'and' is supported along with explicit grouping with
      parenthesis, should it be needed. The '&amp;&amp;' symbol, as an
      alternative to 'and', is deprecated although it is still supported in
      the syntax for legacy support reasons.</para>

      <figure>
        <title>infixAnd</title>

        <mediaobject>
          <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/infixAnd.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <example>
        <title>infixAnd</title>

        <programlisting>Cheese( cheeseType : type ) and Person( favouriteCheese == cheeseType ) //infixAnd
(Cheese( cheeseType : type ) and (Person( favouriteCheese == cheeseType ) or Person( favouriteCheese == cheeseType  ) ) //infixAnd with grouping</programlisting>
      </example>
    </section>

    <section>
      <title>'or'</title>

      <para>The 'or' Conditional Element is used to group together other
      Conditional Elements. Drools supports both prefix and infix; although
      prefix is the preferred option as grouping is implicit which avoids
      confusion. The behavior of the 'or' Conditional Element is different
      than the '||' connective for constraints and restrictions in field
      constraints. The engine actually has no understanding of 'or'
      Conditional Elements, instead via a number of different logic
      transformations the rule is re-written as a number of subrules; the rule
      now has a single 'or' as the root node and a subrule per logical
      outcome. Each subrule can activate and fire like any normal rule, there
      is no special behavior or interactions between the subrules - this can
      be most confusing to new rule authors.</para>

      <figure>
        <title>prefixOr</title>

        <mediaobject>
          <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/prefixOr.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <example>
        <title>prefixOr</title>

        <programlisting>(or Person( sex == "f", age &gt; 60 )
    Person( sex == "m", age &gt; 65 )
</programlisting>
      </example>

      <para>Infix 'or' is supported along with explicit grouping with
      parenthesis, should it be needed. The '||' symbol, as an alternative to
      'or', is deprecated although it is still supported in the syntax for
      legacy support reasons.</para>

      <figure>
        <title>infixOr</title>

        <mediaobject>
          <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/infixOr.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <example>
        <title>infixOr</title>

        <programlisting>Cheese( cheeseType : type ) or Person( favouriteCheese == cheeseType ) //infixOr
(Cheese( cheeseType : type ) or (Person( favouriteCheese == cheeseType ) and Person( favouriteCheese == cheeseType  ) ) //infixOr with grouping</programlisting>
      </example>

      <para>The 'or' Conditional Element also allows for optional pattern
      binding; which means each resulting subrule will bind its pattern to
      the pattern binding. Each pattern must be bound separately,
      using eponymous variables:</para>

      <example>
        <title>or with binding</title>

        <programlisting>(or pensioner : Person( sex == "f", age &gt; 60 ) 
    pensioner : Person( sex == "m", age &gt; 65 ) )</programlisting>
      </example>

      <para>The 'or' conditional element results in multiple rule generation,
      called sub rules, for each possible logically outcome. The example above
      would result in the internal generation of two rules. These two rules
      work independently within the Working Memory, which means both can
      match, activate and fire - there is no shortcutting.</para>

      <para>The best way to think of the OR conditional element is as a
      shortcut for generating two or more similar rules. When you think
      of it that
      way, it's clear that for a single rule there could be multiple
      activations if both sides of the OR conditional element are true.</para>
    </section>

    <section>
      <title>'eval'</title>

      <figure>
        <title>eval</title>

        <mediaobject>
          <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/eval.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Eval is essentially a catch all which allows any semantic code
      (that returns a primitive boolean) to be executed. This can refer to
      variables that were bound in the LHS of the rule, and functions in the
      rule package. Overuse of eval reduces the declarative-ness of your rules
      and can result in a poor performing engine. While 'evals' can be used
      anywhere in the Pattern the best practice is to add it as the last
      conditional element in the LHS of a rule.</para>

      <para>Evals cannot be indexed and thus are not as optimal as using Field
      Constraints. However this makes them ideal for being used when functions
      return values that change over time, which is not allowed within Field
      Constraints.</para>

      <para>For folks who are familiar with Drools 2.x lineage, the old Drools
      parameter and condition tags are equivalent to binding a variable to an
      appropriate type, and then using it in an eval node.</para>

      <example>
        <title>eval</title>

        <programlisting>p1 : Parameter() 
p2 : Parameter()
eval( p1.getList().containsKey(p2.getItem()) )
eval( isValid(p1, p2) ) //this is how you call a function in the LHS - a function called "isValid"</programlisting>
      </example>
    </section>

    <section>
      <title>'not'</title>

      <figure>
        <title>not</title>

        <mediaobject>

          <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/not.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>'not' is first order logic's Non-Existential Quantifier and checks
      for the non existence of something in the Working Memory. Think of 'not'
      as meaning "there must be none of...".</para>

      <para>A 'not' statement must be followed by parentheses around the CEs
      that it applies to. In the simplest case of a single pattern (like
      below) you may optionally omit the parentheses.</para>

      <example>
        <title>No Busses</title>

        <programlisting>not Bus()</programlisting>
      </example>

      <example>
        <title>No red Busses</title>

        <programlisting>not Bus(color == "red") //brackets are optional for this simple pattern
not ( Bus(color == "red", number == 42) ) //brackets are optional for this simple case
not ( Bus(color == "red") and Bus(color == "blue")) // not with nested 'and' infix used here as only two patterns 
                                                      (but brackets are required).</programlisting>
      </example>
    </section>

    <section>
      <title>'exists'</title>

      <figure>
        <title>exists</title>

        <mediaobject>

          <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/exists.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>'exists' is first order logic's Existential Quantifier and checks
      for the existence of something in the Working Memory. Think of exist as
      meaning "at least one..". It is different from just having the Pattern
      on its own; which is more like saying "for each one of...". If you use
      exist with a Pattern, then the rule will only activate at most once,
      regardless
      of how much data there is in working memory that matches that
      condition. Since only the existence matters, no bindings will be
      established.</para>

      <para>An 'exists' statement must be followed by parentheses around the
      CEs that it applies to. In the simplest case of a single pattern (like
      below) you may omit the parentheses.</para>

      <example>
        <title>At least one Bus</title>

        <programlisting>exists Bus()</programlisting>
      </example>

      <example>
        <title>At least one red Bus</title>

        <programlisting>exists Bus(color == "red")
exists ( Bus(color == "red", number == 42) ) // brackets are optional
exists ( Bus(color == "red") and Bus(color == "blue")) // exists with nested 'and' infix used here as only two patterns</programlisting>
      </example>
    </section>

    <section>
      <title>'forall'</title>

      <figure>
        <title>forall</title>

        <mediaobject>

          <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/forall.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <emphasis role="bold">forall</emphasis> Conditional Element
      completes the First Order Logic support in Drools. The <emphasis
      role="bold">forall</emphasis> Conditional Element will evaluate to true
      when all facts that match the first pattern match all the remaining
      patterns. Example:</para>

      <programlisting>rule "All english buses are red"
when
    forall( $bus : Bus( type == 'english') 
                   Bus( this == $bus, color = 'red' ) )
then
    # all english buses are red
end
</programlisting>

      <para>In the above rule, we "select" all Bus objects whose type is
      "english". Then, for each fact that matches this pattern we evaluate the
      following patterns and if they match, the forall CE will evaluate to
      true.</para>

      <para>To state that all facts of a given type in the working memory must
      match a set of constraints, forall can be written with a single pattern
      for simplicity. Example:</para>

      <example>
          <title>Single Pattern Forall</title>

          <programlisting>rule "All Buses are Red"
when
    forall( Bus( color == 'red' ) )
then
    # all asserted Bus facts are red
end
</programlisting>
        </example>

      <para>Her is another example of a multi-pattern forall:</para>
      <example>
          <title>Multi-Pattern Forall</title>

          <programlisting>rule "all employees have health and dental care programs"
when
    forall( $emp : Employee()
            HealthCare( employee == $emp )
            DentalCare( employee == $emp )
          )
then
    # all employees have health and dental care
end
</programlisting>
        </example>

      <para>Forall can be nested inside other CEs.
      For instance, <emphasis role="bold">forall</emphasis> can be used inside
      a <emphasis role="bold">not</emphasis> CE, but note that only single
      patterns have optional parentheses; therefore, with a nested forall parentheses
      must be used:</para>
      <example>
          <title>Combining Forall with Not CE</title>

          <programlisting>rule "not all employees have health and dental care"
when 
    not ( forall( $emp : Employee()
                HealthCare( employee == $emp )
                DentalCare( employee == $emp ) ) 
        )
then
    # not all employees have health and dental care
end
</programlisting>
        </example>

      <para>As a side note, <code>forall( p1 p2 p3...)</code> is
  equivalent to writing:</para>

      <programlisting>not(p1 and not(and p2 p3...))</programlisting>

      <para>Also, it is important to note that <emphasis role="bold">forall is
      a scope delimiter</emphasis>, so it can use any previously bound
      variable, but no variable bound inside it will be available for use
      outside of it.</para>
    </section>

    <section>
      <title>From</title>

      <figure>
        <title>from</title>

        <mediaobject>
          <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/from.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <emphasis role="bold">from</emphasis> Conditional Element
      allows users to specify a source for patterns to reason over. This
      allows the engine to reason over data not in the Working Memory. This
      could be a sub-field on a bound variable or the results of a method
      call. It is a powerful construction that allows out of the box
      integration with other application components and frameworks. One common
      example is the integration with data retrieved on-demand from databases
      using hibernate named queries.</para>

      <para>The expression used to define the object source is any expression
      that follows regular MVEL syntax. I.e., it allows you to easily use
      object property navigation, execute method calls and access maps and
      collections elements.</para>

      <para>Here is a simple example of reasoning and binding on another
      pattern sub-field:</para>

      <programlisting>rule "validate zipcode"
when
    Person( $personAddress : address ) 
    Address( zipcode == "23920W") from $personAddress 
then
    # zip code is ok
end
</programlisting>

      <para>With all the flexibility from the new expressiveness in the Drools
      engine you can slice and dice this problem many ways. This is the same
      but shows how you can use a graph notation with the 'from':</para>

      <programlisting>rule "validate zipcode"
when
    $p : Person( ) 
    $a : Address( zipcode == "23920W") from $p.address 
then
    # zip code is ok
end
</programlisting>

      <para>Previous examples were reasoning over a single pattern. The
      <emphasis role="bold">from</emphasis> CE also support object sources
      that return a collection of objects. In that case, <emphasis
      role="bold">from</emphasis> will iterate over all objects in the
      collection and try to match each of them individually. For instance, if
      we want a rule that applies 10% discount to each item in an order, we
      could do:</para>

      <programlisting>rule "apply 10% discount to all items over US$ 100,00 in an order"
when
    $order : Order()
    $item  : OrderItem( value &gt; 100 ) from $order.items
then
    # apply discount to $item
end
</programlisting>

      <para>The above example will cause the rule to fire once for each item
      whose value is greater than 100 for each given order.</para>

    <para>You must take caution, however, when using <emphasis
      role="bold">from</emphasis>, especially in conjunction with the
      <emphasis role="bold">lock-on-active</emphasis> rule attribute 
      as it may produce unexpected results. Consider the example provided earlier, but
      now slightly modified as follows:</para>
      
      <programlisting>rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person( ) 
    $a : Address( state == "NC") from $p.address 
then
    modify ($p) {} #Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person( ) 
    $a : Address( city == "Raleigh") from $p.address 
then
    modify ($p) {} #Apply discount to person in a modify block
end
</programlisting>

    <para>
    In the above example, persons in Raleigh, NC should be assigned to sales region 1 and
    receive a discount; i.e., you would expect both rules to activate and fire. Instead you
    will find that only the second rule fires.</para>

    <para>If you were to turn on the audit log, you would also see that when the second rule fires,
    it deactivates the first rule. Since the rule attribute <emphasis role="bold">lock-on-active</emphasis>
    prevents a rule from creating new activations when a set of facts change, the first rule fails to
    reactivate. Though the set of facts have not changed, the use of
    <emphasis role="bold">from</emphasis> returns a new fact for all intents and purposes each time
    it is evaluated.
    </para>

    <para>First, it's important to review why you would use the above pattern. You may have
    many rules across different rule-flow groups. When rules modify working memory and other rules
    downstream of your RuleFlow (in different rule-flow groups) need to be reevaluated, the use of <emphasis role="bold">modify</emphasis>
    is critical. You don't, however, want other rules in the same rule-flow group to place
    activations on one another recursively. In this case, the <emphasis role="bold">no-loop</emphasis>
    attribute is ineffective, as it would only prevent a rule from activating itself recursively. Hence,
    you resort to <emphasis role="bold">lock-on-active</emphasis>.
    </para>

    <para>
    There are several ways to address this issue:</para>

      <itemizedlist>
        <listitem>
          <para>Avoid the use of <emphasis role="bold">from</emphasis> when you can assert all facts into working memory 
          or use nested object references in your constraint expressions (shown below)</para>
        </listitem>
        <listitem>
          <para>Place the variable assigned used in the modify block as the last sentence in your condition (LHS)</para>
        </listitem>
        <listitem>
          <para>Avoid the use of <emphasis role="bold">lock-on-active</emphasis> when you can 
          explicitly manage how rules within the same rule-flow group place activations on one another 
          (explained below)</para>
        </listitem>
      </itemizedlist>

    <para>The preferred solution is to minimize use of <emphasis role="bold">from</emphasis>
    when you can assert all your facts into working memory directly. In the example above,
    both the Person and Address instance can be asserted into working memory. In this case, because
    the graph is fairly simple, an even easier solution is to modify your rules as follows:
    </para>

      <programlisting>rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person(address.state == "NC" )  
then
    modify ($p) {} #Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person(address.city == "Raleigh" )  
then
    modify ($p) {} #Apply discount to person in a modify block
end
</programlisting>

    <para>Now, you will find that both rules fire as expected. However, it is not
    always possible to access nested facts as above. Consider an example where a Person
    holds one or more Addresses and you wish to use an existential quantifier to
    match people with at least one address that meets certain conditions.
    In this case, you would have to resort to
    the use of  <emphasis role="bold">from</emphasis> to reason over the collection.</para>

    <para>
    There are several ways to use <emphasis role="bold">from</emphasis>
    to achieve this and not all of them exhibit an issue
    with the use of  <emphasis role="bold">lock-on-active</emphasis>. For example,
    the following use of <emphasis role="bold">from</emphasis> causes both rules to fire as expected:
    </para>

    <programlisting>rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person($addresses : addresses)
    exists (Address(state == "NC") from $addresses)  
then
    modify ($p) {} #Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person($addresses : addresses)
    exists (Address(city == "Raleigh") from $addresses)  
then
    modify ($p) {} #Apply discount to person in a modify block
end
</programlisting>

    <para>However, the following slightly different approach does exhibit the problem:</para>

    <programlisting>rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $assessment : Assessment()
    $p : Person()
    $addresses : List() from $p.addresses
    exists (Address( state == "NC") from $addresses) 
then
    modify ($assessment) {} #Modify assessment in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $assessment : Assessment()
    $p : Person()
    $addresses : List() from $p.addresses 
    exists (Address( city == "Raleigh") from $addresses)
then
    modify ($assessment) {} #Modify assessment in a modify block
end</programlisting>

    <para>In the above example, the $addresses variable is returned from the
    use of <emphasis role="bold">from</emphasis>. The example also introduces
    a new object, assessment, to highlight one possible solution in this case.
    If the $assessment variable assigned in the condition (LHS) is moved to the last condition
    in each rule, both rules fire as expected.
    </para>

    <para>
    Though the above examples demonstrate how to combine the use of <emphasis role="bold">from</emphasis>
    with <emphasis role="bold">lock-on-active</emphasis> where no loss of rule activations occurs,
    they carry the drawback of placing a dependency on the order of conditions on the LHS. In addition,
    the solutions present greater complexity for the rule author in terms of keeping track of
    which conditions may create issues.
    </para>

    <para>A better alternative is to
    assert more facts into working memory. In this case, a person's addresses
    may be asserted into working memory and the use of <emphasis role="bold">from</emphasis>
    would not be necessary.</para>

    <para>There are cases, however, where asserting all data into working memory is not
    practical and we need to find other solutions. Another option is to reevaluate the
    need for <emphasis role="bold">lock-on-active</emphasis>.
    An alternative to <emphasis role="bold">lock-on-active</emphasis> is to
    directly manage how rules within the same rule-flow group activate one another
    by including conditions in each rule that prevent rules from activating each other recursively
    when working memory is modified. For example, in the case above where a
    discount is applied to citizens of Raleigh, a condition may be added to the rule
    that checks whether the discount has already been applied. If so, the rule does not
    activate.</para>

    </section>

    <section>
      <title>'collect'</title>

      <figure>
        <title>collect</title>

        <mediaobject>

          <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/collect.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <emphasis role="bold">collect</emphasis> Conditional Element
      allows rules to reason over collection of objects collected from the
      given source or from the working memory. In first oder logic terms this
      is Cardinality Quantifier. A simple example:</para>

      <programlisting>import java.util.ArrayList

rule "Raise priority if system has more than 3 pending alarms"
when
    $system : System()
    $alarms : ArrayList( size &gt;= 3 )
              from collect( Alarm( system == $system, status == 'pending' ) )
then
    # Raise priority, because system $system has
    # 3 or more alarms pending. The pending alarms
    # are $alarms.
end
</programlisting>

      <para>In the above example, the rule will look for all pending alarms in
      the working memory for each given system and group them in ArrayLists.
      If 3 or more alarms are found for a given system, the rule will
      fire.</para>

      <para>The <emphasis role="bold">collect</emphasis> CE result pattern can
      be any concrete class that implements tha java.util.Collection interface
      and provides a default no-arg public constructor. I.e., you can use
      default Java collections like ArrayList, LinkedList, HashSet, etc, or
      your own class, as long as it implements the java.util.Collection
      interface and provide a default no-arg public constructor.</para>

      <para>Both source and result patterns can be constrained as any other
      pattern.</para>

      <para>Variables bound before the <emphasis
      role="bold">collect</emphasis> CE are in the scope of both source and
      result patterns and as so, you can use them to constrain both your
      source and result patterns. Although, the <emphasis>collect( ...
      )</emphasis> is a scope delimiter for bindings, meaning that any binding
      made inside of it, is not available for use outside of it.</para>

      <para>Collect accepts nested <emphasis role="bold">from</emphasis>
      elements, so the following example is a valid use of <emphasis
      role="bold">collect</emphasis>:</para>

      <programlisting>import java.util.LinkedList;

rule "Send a message to all mothers"
when
    $town : Town( name == 'Paris' )
    $mothers : LinkedList() 
               from collect( Person( gender == 'F', children &gt; 0 ) 
                             from $town.getPeople() 
                           )
then
    # send a message to all mothers
end
</programlisting>
    </section>

    <section>
      <title>'accumulate'</title>

      <figure>
        <title>accumulate</title>

        <mediaobject>
          <imageobject>
      <imagedata align="center" fileref="images/Chapter-Rule_Language/accumulate.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <emphasis role="bold">accumulate</emphasis> Conditional
      Element is a more flexible and powerful form of <emphasis
      role="bold">collect</emphasis> Conditional Element, in the sense that it
      can be used to do what <emphasis role="bold">collect</emphasis> CE does
      and also do things that <emphasis role="bold">collect</emphasis> CE is
      not capable to do. Basically what it does is it allows a rule to iterate
      over a collection of objects, executing custom actions for each of the
      elements, and at the end return a result object.</para>

      <para>The general syntax of the <emphasis
      role="bold">accumulate</emphasis> CE is:</para>

      <programlisting><replaceable>&lt;result pattern&gt;</replaceable> from accumulate( <replaceable>&lt;source pattern&gt;</replaceable>,
                                  init( <replaceable>&lt;init code&gt;</replaceable> ),
                                  action( <replaceable>&lt;action code&gt;</replaceable> ),
                                  reverse( <replaceable>&lt;reverse code&gt;</replaceable> ),
                                  result( <replaceable>&lt;result expression&gt;</replaceable> ) )
</programlisting>

      <para>The meaning of each of the elements is the following:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">&lt;source pattern&gt;</emphasis>: the
          source pattern is a regular pattern that the engine will try to
          match against each of the source objects.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">&lt;init code&gt;</emphasis>: this is a
          semantic block of code in the selected dialect that will be executed
          once for each tuple, before iterating over the source
          objects.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">&lt;action code&gt;</emphasis>: this is
          a semantic block of code in the selected dialect that will be
          executed for each of the source objects.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">&lt;reverse code&gt;</emphasis>: this is
          an optional semantic block of code in the selected dialect that if
          present will be executed for each source object that no longer
          matches the source pattern. The objective of this code block is to
          "undo" any calculation done in the &lt;action code&gt; block, so
          that the engine can do decremental calculation when a source object
          is modified or retracted, hugely improving performance of these
          operations.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">&lt;result expression&gt;</emphasis>:
          this is a semantic expression in the selected dialect that is
          executed after all source objects are iterated.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">&lt;result pattern&gt;</emphasis>: this
          is a regular pattern that the engine tries to match against the
          object returned from the &lt;result expression&gt;. If it matches,
          the <emphasis role="bold">accumulate</emphasis> conditional element
          evaluates to <emphasis role="bold">true</emphasis> and the engine
          proceeds with the evaluation of the next CE in the rule. If it does
          not matches, the <emphasis role="bold">accumulate</emphasis> CE
          evaluates to <emphasis role="bold">false</emphasis> and the engine
          stops evaluating CEs for that rule.</para>
        </listitem>
      </itemizedlist>

      <para>It is easier to understand if we look at an example:</para>

      <programlisting>rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              init( double total = 0; ),
                              action( total += $value; ),
                              reverse( total -= $value; ),
                              result( total ) )
then
    # apply discount to $order
end
</programlisting>

      <para>In the above example, for each Order() in the working memory, the
      engine will execute the <emphasis role="bold">init code</emphasis>
      initializing the total variable to zero. Then it will iterate over all
      OrderItem() objects for that order, executing the <emphasis
      role="bold">action</emphasis> for each one (in the example, it will sum
      the value of all items into the total variable). After iterating over
      all OrderItem, it will return the value corresponding to the <emphasis
      role="bold">result expression</emphasis> (in the above example, the
      value of the total variable). Finally, the engine will try to match the
      result with the Number() pattern and if the double value is greater than
      100, the rule will fire.</para>

      <para>The example used Java as the semantic dialect, and as such, note
      that the usage of ';' is mandatory in the init, action and reverse code
      blocks. The result is an expression and as such, it does not admit ';'.
      If the user uses any other dialect, he must comply to that dialect
      specific syntax.</para>

      <para>As mentioned before, the <emphasis role="bold">reverse
      code</emphasis> is optional, but it is strongly recommended that the
      user writes it in order to benefit from the <emphasis>improved
      performance on update and retracts</emphasis>.</para>

      <para>The <emphasis role="bold">accumulate</emphasis> CE can be used to
      execute any action on source objects. The following example instantiates
      and populates a custom object:</para>

      <programlisting>rule "Accumulate using custom objects"
when
    $person   : Person( $likes : likes )
    $cheesery : Cheesery( totalAmount &gt; 100 )
                from accumulate( $cheese : Cheese( type == $likes ),
                                 init( Cheesery cheesery = new Cheesery(); ),
                                 action( cheesery.addCheese( $cheese ); ),
                                 reverse( cheesery.removeCheese( $cheese ); ),
                                 result( cheesery ) );
then
    // do something
end</programlisting>

      <section>
        <title>Accumulate Functions</title>

        <para>The accumulate CE is a very powerful CE, but it gets real
        declarative and easy to use when using predefined functions that are
        known as Accumulate Functions. They work exactly like accumulate, but
        instead of explicitly writing custom code in every accumulate CE, the
        user can use predefined code for common operations.</para>

        <para>For instance, the rule to apply discount on orders written in
        the previous section, could be written in the following way, using
        Accumulate Functions:</para>

        <programlisting>rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              sum( $value ) )
then
    # apply discount to $order
end
</programlisting>

        <para>In the above example, sum is an Accumulate Function and will sum
        the $value of all OrderItems and return the result.</para>

        <para>Drools 4.0 ships with the following built in accumulate
        functions:</para>

        <itemizedlist>
          <listitem>
            <para>average</para>
          </listitem>

          <listitem>
            <para>min</para>
          </listitem>

          <listitem>
            <para>max</para>
          </listitem>

          <listitem>
            <para>count</para>
          </listitem>

          <listitem>
            <para>sum</para>
          </listitem>
        </itemizedlist>

        <para>These common functions accept any expression as input. For
        instance, if someone wants to calculate the average profit on all
        items of an order, a rule could be written using the average
        function:</para>

        <programlisting>rule "Average profit"
when
    $order : Order()
    $profit : Number() 
              from accumulate( OrderItem( order == $order, $cost : cost, $price : price )
                               average( 1 - $cost / $price ) )
then
    # average profit for $order is $profit
end
</programlisting>

        <para>Accumulate Functions are all pluggable. That means that if
        needed, custom, domain specific functions can easily be added to the
        engine and rules can start to use them without any restrictions. To
        implement a new Accumulate Functions all one needs to do is to create
        a Java class that implements the
        org.drools.base.acumulators.AccumulateFunction interface and add a
        line to the configuration file or set a system property to let the
        engine know about the new function. As an example of an Accumulate
        Function implementation, the following is the implementation of the
        "average" function:</para>

        <programlisting>/*
 * Copyright 2007 JBoss Inc
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created on Jun 21, 2007
 */
package org.drools.base.accumulators;


/**
 * An implementation of an accumulator capable of calculating average values
 */
public class AverageAccumulateFunction implements AccumulateFunction {

    protected static class AverageData {
        public int    count = 0;
        public double total = 0;
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#createContext()
     */
    public Object createContext() {
        return new AverageData();
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#init(java.lang.Object)
     */
    public void init(Object context) throws Exception {
        AverageData data = (AverageData) context;
        data.count = 0;
        data.total = 0;
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#accumulate(java.lang.Object, java.lang.Object)
     */
    public void accumulate(Object context,
                           Object value) {
        AverageData data = (AverageData) context;
        data.count++;
        data.total += ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#reverse(java.lang.Object, java.lang.Object)
     */
    public void reverse(Object context,
                        Object value) throws Exception {
        AverageData data = (AverageData) context;
        data.count--;
        data.total -= ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#getResult(java.lang.Object)
     */
    public Object getResult(Object context) throws Exception {
        AverageData data = (AverageData) context;
        return new Double( data.count == 0 ? 0 : data.total / data.count );
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#supportsReverse()
     */
    public boolean supportsReverse() {
        return true;
    }

}
</programlisting>

        <para>The code for the function is very simple, as we could expect, as
        all the "dirty" integration work is done by the engine. Finally, to
        plug the function into the engine, we added it to the configuration
        file:</para>

        <programlisting>drools.accumulate.function.average = org.drools.base.accumulators.AverageAccumulateFunction
</programlisting>

        <para>Where "drools.accumulate.function." is a prefix that must always
        be used, "average" is how the function will be used in the rule file,
        and "org.drools.base.accumulators.AverageAccumulateFunction" is the
        fully qualified name of the class that implements the function
        behavior.</para>
      </section>
    </section>
  </section>

  <section>
    <title>The Right Hand Side (then)</title>

    <para>The Right Hand Side (RHS) is a common name for the consequence or
    action part of the rule; this part should contain a list of actions to be
    executed. It is bad practice to use imperative or conditional code in the
    RHS of a rule; as a rule should be atomic in nature - "when this, then do
    this", not "when this, maybe do this". The RHS part of a rule should also
    be kept small, thus keeping it declarative and readable. If you find you
    need imperative and/or conditional code in the RHS, then maybe you should
    be breaking that rule down into multiple rules. The main purpose of the
    RHS is to insert, retractor modify working memory data. To assist with
    that there are a few convenience methods you can use to modify working
    memory; without having to first reference a working memory
    instance.</para>

    <para>"update(object, handle);" will tell the engine that an object has
    changed (one that has been bound to something on the LHS) and rules may
    need to be reconsidered.</para>
    
    <para>"update(object);"  can also be used, here the KnowledgeHelper will
    lookup the facthandle for you, via an identity check, for the passed object.</para>      

    <para>"insert(new Something());" will place a new object of your creation
    in working memory.</para>

    <para>"insertLogical(new Something());" is similar to insert, but the
    object will be automatically retracted when there are no more facts to
    support the truth of the currently firing rule.</para>

    <para>"retract(handle);" removes an object from working memory.</para>

    <para>These convenience methods are basically macros that provide short
    cuts to the KnowledgeHelper instance (refer to the KnowledgeHelper
    interface for more advanced operations). The KnowledgeHelper interface is
    made available to the RHS code block as a variable called "drools". If you
    provide "Property Change Listeners" to your Java beans that you are
    inserting into the engine, you can avoid the need to call "update" when
    the object changes.</para>
  </section>

  <section>
    <title>A note on auto boxing/unboxing and primitive types</title>

    <para>Drools attempts to preserve numbers in their primitive or object
    wrapper form, so a variable bound to an int primitive when used in a code
    block or expression will no longer need manual unboxing; unlike Drools 3.0
    where all primitives was autoboxed, requiring manual unboxing. A variable
    bound to an object wrapper will remain as an object; the existing jdk1.5
    and jdk5 rules to handling auto boxing/unboxing apply in this case. When
    evaluating field constraints the system attempts to coerce one of the
    values into a comparable format; so a primitive is comparable to an object
    wrapper.</para>
  </section>
</section>
