<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="../" xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Running</title>

  <para></para>

  <section>
    <title>KnowledgeBase</title>

    <para>The <code>KnowlegeBase</code> is a repository of all the
    application's knowledge definitions. It will contain rules, processes,
    functions, and type models. The Knowledge Base itself does not contain
    data; instead, sessions are created from the <code>KnowledgeBase</code>
    into which data can be inserted and from which process instances may be
    started. Creating the <code>KnowlegeBase</code> can be heavy, whereas
    session creation is very light, so it is recommended that Knowle Bases be
    cached where possible to allow for repeated session creation.</para>

    <example>
      <title>Creating a new KnowledgeBase</title>

      <programlisting language="java">KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();</programlisting>
    </example>
  </section>

  <section>
    <title>StatefulKnowledgeSession</title>

    <para>The <code>StatefulKnowledgeSession</code> stores and executes on the
    runtime data. It is created from the <code>KnowledgeBase</code>.</para>

    <figure>
      <title>StatefulKnowledgeSession</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-User_Guide/StatefulKnowledgeSession.png"
                     format="" width="100%"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <example>
      <title>Create a StatefulKnowledgeSession from a KnowledgeBase</title>

      <programlisting language="java">StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();
</programlisting>
    </example>
  </section>

  <section>
    <title>KnowledgeRuntime</title>

    <section>
      <title>WorkingMemoryEntryPoint</title>

      <para>The <code>WorkingMemoryEntryPoint</code> provides the methods
      around inserting, updating and retrieving facts. The term "entry point"
      is related to the fact that we have multiple partitions in a Working
      Memory and you can choose which one you are inserting into, although
      this use case is aimed at event processing and covered in more detail in
      the Fusion manual. Most rule based applications will work with the
      default entry point alone.</para>

      <para>The <code>KnowledgeRuntime</code> interface provides the main
      interaction with the engine. It is available in rule consequences and
      process actions. In this manual the focus is on the methods and
      interfaces related to rules, and the methods pertaining to processes
      will be ignored for now. But you'll notice that the
      <code>KnowledgeRuntime</code> inherits methods from both the
      <code>WorkingMemory</code> and the <code>ProcessRuntime</code>, thereby
      providing a unified API to work with processes and rules. When working
      with rules, three interfaces form the <code>KnowledgeRuntime</code>:
      <code>WorkingMemoryEntryPoint</code>, <code>WorkingMemory</code> and the
      <code>KnowledgeRuntime</code> itself.</para>

      <figure>
        <title>WorkingMemoryEntryPoint</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter-User_Guide/WorkingMemoryEntryPoint.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <section>
        <title>Insertion</title>

        <para>Insertion is the act of telling the <code>WorkingMemory</code>
        about a fact, which you do by
        <code>ksession.insert(yourObject)</code>, for example. When you insert
        a fact, it is examined for matches against the rules. This means
        <emphasis>all</emphasis> of the work for deciding about firing or not
        firing a rule is done during insertion; no rule, however, is executed
        until you call <code>fireAllRules()</code>, which you call after you
        have finished inserting your facts. It is a common misunderstanding
        for people to think the condition evaluation happens when you call
        <code>fireAllRules()</code>. Expert systems typically use the term
        <emphasis>assert</emphasis> or <emphasis>assertion</emphasis> to refer
        to facts made available to the system. However, due to "assert" being
        a keyword in most languages, we have decided to use the
        <literal>insert</literal> keyword; so expect to hear the two used
        interchangeably.</para>

        <!-- FIXME - I think we might want to add this sentence to the previous paragraph.
        However, when the rules are executed, they can assert new objects 
        thus causing new work to be needed. laune: No, it should be elsewhere.
      -->

        <para>When an Object is inserted it returns a <code>FactHandle</code>.
        This <code>FactHandle</code> is the token used to represent your
        inserted object within the <code>WorkingMemory</code>. It is also used
        for interactions with the <code>WorkingMemory</code> when you wish to
        retract or modify an object.</para>

        <programlisting language="java">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = ksession.insert( stilton );      </programlisting>

        <para>As mentioned in the Knowledge Base section, a Working Memory may
        operate in two assertion modes, i.e., equality or identity, with
        identity being the default.</para>

        <para><emphasis>Identity</emphasis> means that the Working Memory uses
        an <code>IdentityHashMap</code> to store all asserted objects. New
        instance assertions always result in the return of a new
        <code>FactHandle</code>, but if an instance is asserted again then it
        returns the original fact handle, i.e., it ignores repeated insertions
        for the same fact.</para>

        <para><emphasis>Equality</emphasis> means that the Working Memory uses
        a <code>HashMap</code> to store all asserted Objects. New instance
        assertions will only return a new <code>FactHandle</code> if no equal
        objects have been asserted.</para>
      </section>

      <section>
        <title>Retraction</title>

        <para>Retraction is the removal of a fact from Working Memory, which
        means that it will no longer track and match that fact, and any rules
        that are activated and dependent on that fact will be cancelled. Note
        that it is possible to have rules that depend on the nonexistence of a
        fact, in which case retracting a fact may cause a rule to activate.
        (See the <code>not</code> and <code>exist</code> keywords.) Retraction
        is done using the <code>FactHandle</code> that was returned by the
        insert call.</para>

        <programlisting language="java">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = ksession.insert( stilton );
....
ksession.retract( stiltonHandle );            </programlisting>
      </section>

      <section>
        <title>Update</title>

        <para>The Rule Engine must be notified of modified facts, so that they
        can be reprocessed. Internally, modification is actually a retract
        followed by an insert; the Rule Engine removes the fact from the
        <code>WorkingMemory</code> and inserts it again. You must use the
        <code>update()</code> method to notify the <code>WorkingMemory</code>
        of changed objects for those objects that are not able to notify the
        <code>WorkingMemory</code> themselves. Notice that
        <code>update()</code> always takes the modified object as a second
        parameter, which allows you to specify new instances for immutable
        objects. The <code>update()</code> method can only be used with
        objects that have shadow proxies turned on. The update method is only
        available within Java code. On the right hand side of a rule, also the
        <literal>modify</literal> statement is supported, providing simplified
        calls to the object's setters.</para>

        <programlisting language="java">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = workingMemory.insert( stilton );
...
stilton.setPrice( 100 );
workingMemory.update( stiltonHandle, stilton );              </programlisting>
      </section>
    </section>

    <section>
      <title>WorkingMemory</title>

      <para>The WorkingMemory provides access to the Agenda, permits query
      executions, and lets you access named Enty Points.</para>

      <figure>
        <title>WorkingMemory</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter-User_Guide/WorkingMemory.png"
                       format="" width="100%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <section>
        <title>Query</title>

        <para>Queries are used to retrieve fact sets based on patterns, as
        they are used in rules. Patterns may make use of optional parameters.
        Queries can be defined in the Knowlege Base, from where they are
        called up to return the matching results. While iterating over the
        result collection, any bound identifier in the query can be accessed
        using the get(String identifier) method and any FactHandle for that
        identifier can be retrieved using getFactHandle(String
        identifier).</para>

        <figure>
          <title>QueryResults</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/Chapter-User_Guide/QueryResults.png"
                         format=""></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <figure>
          <title>QueryResultsRow</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/Chapter-User_Guide/QueryResultsRow.png"
                         format=""></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <example>
          <title>Simple Query Example</title>

          <programlisting language="java">QueryResults results =
    ksession.getQueryResults( "my query", new Object[] { "string" } );
for ( QueryResultsRow row : results ) {
    System.out.println( row.get( "varName" ) );
}</programlisting>
        </example>
      </section>

      <section>
        <title>Live Querries</title>

        <para>Drools has always had query support, but the result was returned
        as an iterable set; this makes it hard to monitor changes over
        time.</para>

        <para>We have now complimented this with Live Querries, which has a
        listener attached instead of returning an iterable result set. These
        live querries stay open creating a view and publish change events for
        the contents of this view. So now you can execute your query, with
        parameters and listen to changes in the resulting view.</para>

        <example>
          <title>Implementing ViewChangedEventListener</title>

          <programlisting language="java">final List updated = new ArrayList();
final List removed = new ArrayList();
final List added = new ArrayList();
 
ViewChangedEventListener listener = new ViewChangedEventListener() {           
 public void rowUpdated(Row row) {
  updated.add( row.get( "$price" ) );
 }
  
 public void rowRemoved(Row row) {
  removed.add( row.get( "$price" ) );
 }
  
 public void rowAdded(Row row) {
  added.add( row.get( "$price" ) );
 }
};       
 
// Open the LiveQuery
LiveQuery query = ksession.openLiveQuery( "cheeses",
                                          new Object[] { "cheddar", "stilton" },
                                          listener );
...
...
query.dispose() // make sure you call dispose when you want the query to close</programlisting>
        </example>

        <para>A Drools blog article contains an example of Glazed Lists
        integration for live queries,</para>

        <para><link
        xlink:href="http://blog.athico.com/2010/07/glazed-lists-examples-for-drools-live.html">http://blog.athico.com/2010/07/glazed-lists-examples-for-drools-live.html</link></para>
      </section>
    </section>

    <section>
      <title>KnowledgeRuntime</title>

      <para>The <code>KnowledgeRuntime</code> provides further methods that
      are applicable to both rules and processes, such as setting globals and
      registering <code>Channels</code> (previously exit points, some
      references may remain in docs for a while).</para>

      <figure>
        <title>KnowledgeRuntime</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter-User_Guide/KnowledgeRuntime.png"
                       format=""></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <section>
        <title>Globals</title>

        <para>Globals are named objects that can be passed to the rule engine,
        without needing to insert them. Most often these are used for static
        information, or for services that are used in the RHS of a rule, or
        perhaps as a means to return objects from the rule engine. If you use
        a global on the LHS of a rule, make sure it is immutable. A global
        must first be declared in a rules file before it can be set on the
        session.</para>

        <programlisting>global java.util.List list</programlisting>

        <para>With the Knowledge Base now aware of the global identifier and
        its type, it is now possible to call <code>ksession.setGlobal()</code>
        for any session. Failure to declare the global type and identifier
        first will result in an exception being thrown. To set the global on
        the session use <code>ksession.setGlobal(identifier,
        value)</code>:</para>

        <programlisting language="java">List list = new ArrayList();
ksession.setGlobal("list", list);           </programlisting>

        <para>If a rule evaluates on a global before you set it you will get a
        <code>NullPointerException</code>.</para>
      </section>
    </section>

    <section>
      <title>StatefulRuleSession</title>

      <para>The <code>StatefulRuleSession</code> is inherited by the
      <code>StatefulKnowledgeSession</code> and provides the rule related
      methods that are relevant from outside of the engine.</para>

      <figure>
        <title>StatefulRuleSession</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter-User_Guide/StatefulRuleSession.png"
                       format=""></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <section>
        <title>Agenda Filters</title>

        <figure>
          <title>AgendaFilters</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="images/Chapter-User_Guide/AgendaFilter.png"
                         format="PNG"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para><code>AgendaFilter</code> objects are optional implementations
        of the filter interface which are used to allow or deny the firing of
        an activation. What you filter on is entirely up to the
        implementation. Drools 4.0 used to supply some out of the box filters,
        which have not be exposed in drools 5.0 knowledge-api, but they are
        simple to implement and the Drools 4.0 code base can be referred
        to.</para>

        <para>To use a filter specify it while calling
        <code>fireAllRules()</code>. The following example permits only rules
        ending in the string <code>"Test"</code>. All others will be filtered
        out.</para>

        <programlisting language="java">ksession.fireAllRules( new RuleNameEndsWithAgendaFilter( "Test" ) );</programlisting>
      </section>
    </section>
  </section>

  <section>
    <title>Agenda</title>

    <para>The Agenda is a <emphasis>Rete</emphasis> feature. During actions on
    the <code>WorkingMemory</code>, rules may become fully matched and
    eligible for execution; a single Working Memory Action can result in
    multiple eligible rules. When a rule is fully matched an Activation is
    created, referencing the rule and the matched facts, and placed onto the
    Agenda. The Agenda controls the execution order of these Activations using
    a Conflict Resolution strategy.</para>

    <para>The engine cycles repeatedly through two phases:</para>

    <orderedlist>
      <listitem>
        <para>Working Memory Actions. This is where most of the work takes
        place, either in the Consequence (the RHS itself) or the main Java
        application process. Once the Consequence has finished or the main
        Java application process calls <code>fireAllRules()</code> the engine
        switches to the Agenda Evaluation phase.</para>
      </listitem>

      <listitem>
        <para>Agenda Evaluation. This attempts to select a rule to fire. If no
        rule is found it exits, otherwise it fires the found rule, switching
        the phase back to Working Memory Actions.</para>
      </listitem>
    </orderedlist>

    <figure>
      <title>Two Phase Execution</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center"
                     fileref="images/Chapter-Rule_Engine/Two_Phase.png"
                     format="PNG" width="100%"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>The process repeats until the agenda is clear, in which case control
    returns to the calling application. When Working Memory Actions are taking
    place, no rules are being fired.</para>

    <figure>
      <title>Agenda</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-User_Guide/Agenda.png" format=""></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>Conflict Resolution</title>

      <para>Conflict resolution is required when there are multiple rules on
      the agenda. (The basics to this are covered in chapter "Quick Start".)
      As firing a rule may have side effects on the working memory, the rule
      engine needs to know in what order the rules should fire (for instance,
      firing ruleA may cause ruleB to be removed from the agenda).</para>

      <para>The default conflict resolution strategies employed by Drools are:
      Salience and LIFO (last in, first out).</para>

      <para>The most visible one is <emphasis>salience</emphasis> (or
      priority), in which case a user can specify that a certain rule has a
      higher priority (by giving it a higher number) than other rules. In that
      case, the rule with higher salience will be preferred. LIFO priorities
      are based on the assigned Working Memory Action counter value, with all
      rules created during the same action receiving the same value. The
      execution order of a set of firings with the same priority value is
      arbitrary.</para>

      <para>As a general rule, it is a good idea not to count on rules firing
      in any particular order, and to author the rules without worrying about
      a "flow". However when a flow is needed a number of possibilities exist,
      including but not limited to: agenda groups, rule flow groups,
      activation groups, control/semaphore facts. These are discussed in later
      sections.</para>

      <para>Drools 4.0 supported custom conflict resolution strategies; while
      this capability still exists in Drools it has not yet been exposed to
      the end user via knowledge-api in Drools 5.0.</para>
    </section>

    <section>
      <title>AgendaGroup</title>

      <figure>
        <title>AgendaGroup</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter-User_Guide/AgendaGroup.png"
                       format=""></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Agenda groups are a way to partition rules (activations, actually)
      on the agenda. At any one time, only one group has "focus" which means
      that activations for rules in that group only will take effect. You can
      also have rules with "auto focus" which means that the focus is taken
      for its agenda group when that rule's conditions are true.</para>

      <para>Agenda groups are known as "modules" in CLIPS terminology. While
      it best to design rules that do not need control flow, this is not
      always possible. Agenda groups provide a handy way to create a "flow"
      between grouped rules. You can switch the group which has focus either
      from within the rule engine, or via the API. If your rules have a clear
      need for multiple "phases" or "sequences" of processing, consider using
      agenda-groups for this purpose.</para>

      <para>Each time <code>setFocus()</code> is called it pushes that Agenda
      Group onto a stack. When the focus group is empty it is popped from the
      stack and the focus group that is now on top evaluates. An Agenda Group
      can appear in multiple locations on the stack. The default Agenda Group
      is "MAIN", with all rules which do not specify an Agenda Group being in
      this group. It is also always the first group on the stack, given focus
      initially, by default.</para>

      <programlisting language="java">ksession.getAgenda().getAgendaGroup( "Group A" ).setFocus();</programlisting>
    </section>

    <section>
      <title>ActivationGroup</title>

      <figure>
        <title>ActivationGroup</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter-User_Guide/ActivationGroup.png"
                       format=""></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>An activation group is a set of rules bound together by the same
      "activation-group" rule attribute. In this group only one rule can fire,
      and after that rule has fired all the other rules are cancelled from the
      agenda. The <code>clear()</code> method can be called at any time, which
      cancels all of the activations before one has had a chance to
      fire.</para>

      <programlisting language="java">ksession.getAgenda().getActivationGroup( "Group B" ).clear();</programlisting>
    </section>

    <section>
      <title>RuleFlowGroup</title>

      <figure>
        <title>RuleFlowGroup</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter-User_Guide/RuleFlowGroup.png"
                       format=""></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>A rule flow group is a group of rules associated by the
      "ruleflow-group" rule attribute. These rules can only fire when the
      group is activate. The group itself can only become active when the
      elaboration of the ruleflow diagram reaches the node representing the
      group. Here too, the <code>clear()</code> method can be called at any
      time to cancels all activations still remaining on the Agenda.</para>

      <programlisting language="java">ksession.getAgenda().getRuleFlowGroup( "Group C" ).clear();</programlisting>
    </section>
  </section>

  <section>
    <title>Event Model</title>

    <para>The event package provides means to be notified of rule engine
    events, including rules firing, objects being asserted, etc. This allows
    you, for instance, to separate logging and auditing activities from the
    main part of your application (and the rules).</para>

    <para>The <code>KnowlegeRuntimeEventManager</code> interface is
    implemented by the <code>KnowledgeRuntime</code> which provides two
    interfaces, <code>WorkingMemoryEventManager</code> and
    <code>ProcessEventManager</code>. We will only cover the
    <code>WorkingMemoryEventManager</code> here.</para>

    <figure>
      <title>KnowledgeRuntimeEventManager</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-User_Guide/KnowledgeRuntimeEventManager.png"
                     format=""></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>The <code>WorkingMemoryEventManager</code> allows for listeners to
    be added and removed, so that events for the working memory and the agenda
    can be listened to.</para>

    <figure>
      <title>WorkingMemoryEventManager</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-User_Guide/WorkingMemoryEventManager.png"
                     format="" width="100%"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>The following code snippet shows how a simple agenda listener is
    declared and attached to a session. It will print activations after they
    have fired.</para>

    <example>
      <title>Adding an AgendaEventListener</title>

      <programlisting language="java">ksession.addEventListener( new DefaultAgendaEventListener() {
   public void afterActivationFired(AfterActivationFiredEvent event) {
       super.afterActivationFired( event );
       System.out.println( event );
   }
});     </programlisting>
    </example>

    <para>Drools also provides <code>DebugWorkingMemoryEventListener</code>
    and <code>DebugAgendaEventListener</code> which implement each method with
    a debug print statement. To print all Working Memory events, you add a
    listener like this:</para>

    <example>
      <title>Creating a new KnowledgeBuilder</title>

      <programlisting language="java">ksession.addEventListener( new DebugWorkingMemoryEventListener() );     </programlisting>
    </example>

    <para>All emitted events implement the <code>KnowlegeRuntimeEvent</code>
    interface which can be used to retrieve the actual
    <code>KnowlegeRuntime</code> the event originated from.</para>

    <figure>
      <title>KnowlegeRuntimeEvent</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-User_Guide/KnowledgeRuntimeEvent.png"
                     format=""></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>The events currently supported are:</para>

    <itemizedlist>
      <listitem>
        <para>ActivationCreatedEvent</para>
      </listitem>

      <listitem>
        <para>ActivationCancelledEvent</para>
      </listitem>

      <listitem>
        <para>BeforeActivationFiredEvent</para>
      </listitem>

      <listitem>
        <para>AfterActivationFiredEvent</para>
      </listitem>

      <listitem>
        <para>AgendaGroupPushedEvent</para>
      </listitem>

      <listitem>
        <para>AgendaGroupPoppedEvent</para>
      </listitem>

      <listitem>
        <para>ObjectInsertEvent</para>
      </listitem>

      <listitem>
        <para>ObjectRetractedEvent</para>
      </listitem>

      <listitem>
        <para>ObjectUpdatedEvent</para>
      </listitem>

      <listitem>
        <para>ProcessCompletedEvent</para>
      </listitem>

      <listitem>
        <para>ProcessNodeLeftEvent</para>
      </listitem>

      <listitem>
        <para>ProcessNodeTriggeredEvent</para>
      </listitem>

      <listitem>
        <para>ProcessStartEvent</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>KnowledgeRuntimeLogger</title>

    <para>The KnowledgeRuntimeLogger uses the comprehensive event system in
    Drools to create an audit log that can be used to log the execution of an
    application for later inspection, using tools such as the Eclipse audit
    viewer.</para>

    <figure>
      <title>KnowledgeRuntimeLoggerFactory</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-User_Guide/KnowledgeRuntimeLoggerFactory.png"
                     format="" width="100%"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <example>
      <title>FileLogger</title>

      <programlisting language="java">KnowledgeRuntimeLogger logger =
  KnowledgeRuntimeLoggerFactory.newFileLogger(ksession, "logdir/mylogfile");
...
logger.close();</programlisting>
    </example>
  </section>

  <section>
    <title>StatelessKnowledgeSession</title>

    <para>The <code>StatelessKnowledgeSession</code> wraps the
    <code>StatefulKnowledgeSession</code>, instead of extending it. Its main
    focus is on decision service type scenarios. It avoids the need to call
    <code>dispose()</code>. Stateless sessions do not support iterative
    insertions and the method call <code>fireAllRules()</code> from Java code;
    the act of calling <code>execute()</code> is a single-shot method that
    will internally instantiate a <code>StatefulKnowledgeSession</code>, add
    all the user data and execute user commands, call
    <code>fireAllRules()</code>, and then call <code>dispose()</code>. While
    the main way to work with this class is via the
    <code>BatchExecution</code> (a subinterface of <code>Command</code>) as
    supported by the <code>CommandExecutor</code> interface, two convenience
    methods are provided for when simple object insertion is all that's
    required. The <code>CommandExecutor</code> and <code>BatchExecution</code>
    are talked about in detail in their own section.</para>

    <figure>
      <title>StatelessKnowledgeSession</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-User_Guide/StatelessKnowledgeSession.png"
                     format="" width="100%"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Our simple example shows a stateless session executing a given
    collection of Java objects using the convenience API. It will iterate the
    collection, inserting each element in turn.</para>

    <example>
      <title>Simple StatelessKnowledgeSession execution with a
      Collection</title>

      <programlisting language="java">KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add( ResourceFactory.newFileSystemResource( fileName ), ResourceType.DRL );
if (kbuilder.hasErrors() ) {
    System.out.println( kbuilder.getErrors() );
} else {
    KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
    kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );
    StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();
    ksession.execute( collection );
}</programlisting>
    </example>

    <para>If this was done as a single Command it would be as follows:</para>

    <example>
      <title>Simple StatelessKnowledgeSession execution with InsertElements
      Command</title>

      <programlisting language="java">ksession.execute( CommandFactory.newInsertElements( collection ) );  </programlisting>
    </example>

    <para>If you wanted to insert the collection itself, and the collection's
    individual elements, then
    <code>CommandFactory.newInsert(collection)</code> would do the job.</para>

    <para>Methods of the <code>CommandFactory</code> create the supported
    commands, all of which can be marshalled using XStream and the
    <code>BatchExecutionHelper</code>. <code>BatchExecutionHelper</code>
    provides details on the XML format as well as how to use Drools Pipeline
    to automate the marshalling of <code>BatchExecution</code> and
    <code>ExecutionResults</code>.</para>

    <para><code>StatelessKnowledgeSession</code> supports globals, scoped in a
    number of ways. I'll cover the non-command way first, as commands are
    scoped to a specific execution call. Globals can be resolved in three
    ways.</para>

    <itemizedlist>
      <listitem>
        <para>The Stateless Knowledge Session method <code>getGlobals()</code>
        returns a Globals instance which provides access to the session's
        globals. These are shared for <emphasis>all</emphasis> execution
        calls. Exercise caution regarding mutable globals because execution
        calls can be executing simultaneously in different threads.</para>

        <example>
          <title>Session scoped global</title>

          <programlisting language="java">StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();
// Set a global hbnSession, that can be used for DB interactions in the rules.
ksession.setGlobal( "hbnSession", hibernateSession );
// Execute while being able to resolve the "hbnSession" identifier.  
ksession.execute( collection ); </programlisting>
        </example>
      </listitem>

      <listitem>
        <para>Using a delegate is another way of global resolution. Assigning
        a value to a global (with <code>setGlobal(String, Object)</code>)
        results in the value being stored in an internal collection mapping
        identifiers to values. Identifiers in this internal collection will
        have priority over any supplied delegate. Only if an identifier cannot
        be found in this internal collection, the delegate global (if any)
        will be used.</para>
      </listitem>

      <listitem>
        <para>The third way of resolving globals is to have execution scoped
        globals. Here, a <code>Command</code> to set a global is passed to the
        <code>CommandExecutor</code>.</para>
      </listitem>
    </itemizedlist>

    <para>The <code>CommandExecutor</code> interface also offers the ability
    to export data via "out" parameters. Inserted facts, globals and query
    results can all be returned.</para>

    <example>
      <title>Out identifiers</title>

      <programlisting language="java">// Set up a list of commands
List cmds = new ArrayList();
cmds.add( CommandFactory.newSetGlobal( "list1", new ArrayList(), true ) );
cmds.add( CommandFactory.newInsert( new Person( "jon", 102 ), "person" ) );
cmds.add( CommandFactory.newQuery( "Get People" "getPeople" );

// Execute the list
ExecutionResults results =
  ksession.execute( CommandFactory.newBatchExecution( cmds ) );

// Retrieve the ArrayList
results.getValue( "list1" );
// Retrieve the inserted Person fact
results.getValue( "person" );
// Retrieve the query as a QueryResults instance.
results.getValue( "Get People" );</programlisting>
    </example>

    <section>
      <title>Sequential Mode</title>

      <para>With Rete you have a stateful session where objects can be
      asserted and modified over time, and where rules can also be added and
      removed. Now what happens if we assume a stateless session, where after
      the initial data set no more data can be asserted or modified and rules
      cannot be added or removed? Certainly it won't be necessary to
      re-evaluate rules, and the engine will be able to operate in a
      simplified way.</para>

      <orderedlist>
        <listitem>
          <para>Order the Rules by salience and position in the ruleset (by
          setting a sequence attribute on the rule terminal node).</para>
        </listitem>

        <listitem>
          <para>Create an array, one element for each possible rule
          activation; element position indicates firing order.</para>
        </listitem>

        <listitem>
          <para>Turn off all node memories, except the right-input Object
          memory.</para>
        </listitem>

        <listitem>
          <para>Disconnect the Left Input Adapter Node propagation, and let
          the Object plus the Node be referenced in a Command object, which is
          added to a list on the Working Memory for later execution.</para>
        </listitem>

        <listitem>
          <para>Assert all objects, and, when all assertions are finished and
          thus right-input node memories are populated, check the Command list
          and execute each in turn.</para>
        </listitem>

        <listitem>
          <para>All resulting Activations should be placed in the array, based
          upon the determined sequence number of the Rule. Record the first
          and last populated elements, to reduce the iteration range.</para>
        </listitem>

        <listitem>
          <para>Iterate the array of Activations, executing populated element
          in turn.</para>
        </listitem>

        <listitem>
          <para>If we have a maximum number of allowed rule executions, we can
          exit our network evaluations early to fire all the rules in the
          array.</para>
        </listitem>
      </orderedlist>

      <para>The <code>LeftInputAdapterNode</code> no longer creates a Tuple,
      adding the Object, and then propagate the Tuple â€“ instead a Command
      object is created and added to a list in the Working Memory. This
      Command object holds a reference to the
      <code>LeftInputAdapterNode</code> and the propagated object. This stops
      any left-input propagations at insertion time, so that we know that a
      right-input propagation will never need to attempt a join with the
      left-inputs (removing the need for left-input memory). All nodes have
      their memory turned off, including the left-input Tuple memory but
      excluding the right-input object memory, which means that the only node
      remembering an insertion propagation is the right-input object memory.
      Once all the assertions are finished and all right-input memories
      populated, we can then iterate the list of
      <code>LeftInputAdatperNode</code> Command objects calling each in turn.
      They will propagate down the network attempting to join with the
      right-input objects, but they won't be remembered in the left input as
      we know there will be no further object assertions and thus propagations
      into the right-input memory.</para>

      <para>There is no longer an Agenda, with a priority queue to schedule
      the Tuples; instead, there is simply an array for the number of rules.
      The sequence number of the <code>RuleTerminalNode</code> indicates the
      element within the array where to place the Activation. Once all Command
      objects have finished we can iterate our array, checking each element in
      turn, and firing the Activations if they exist. To improve performance,
      we remember the first and the last populated cell in the array. The
      network is constructed, with each <code>RuleTerminalNode</code> being
      given a sequence number based on a salience number and its order of
      being added to the network.</para>

      <para>Typically the right-input node memories are Hash Maps, for fast
      object retraction; here, as we know there will be no object retractions,
      we can use a list when the values of the object are not indexed. For
      larger numbers of objects indexed Hash Maps provide a performance
      increase; if we know an object type has only a few instances, indexing
      is probably not advantageous, and a list can be used.</para>

      <para>Sequential mode can only be used with a Stateless Session and is
      off by default. To turn it on, either call
      <code>RuleBaseConfiguration.setSequential(true)</code>, or set the
      rulebase configuration property <code>drools.sequential</code> to true.
      Sequential mode can fall back to a dynamic agenda by calling
      <code>setSequentialAgenda</code> with
      <code>SequentialAgenda.DYNAMIC</code>. You may also set the
      "drools.sequential.agenda" property to "sequential" or "dynamic".</para>
    </section>
  </section>

  <section>
    <title>Commands and the CommandExecutor</title>

    <para>Drools has the concept of stateful or stateless sessions. We've
    already covered stateful sessions, which use the standard working memory
    that can be worked with iteratively over time. Stateless is a one-off
    execution of a working memory with a provided data set. It may return some
    results, with the session being disposed at the end, prohibiting further
    iterative interactions. You can think of stateless as treating a rule
    engine like a function call with optional return results.</para>

    <para>In Drools 4 we supported these two paradigms but the way the user
    interacted with them was different. StatelessSession used an execute(...)
    method which would insert a collection of objects as facts.
    StatefulSession didn't have this method, and insert used the more
    traditional <code>insert(...)</code> method. The other issue was that the
    StatelessSession did not return any results, so that users themselves had
    to map globals to get results, and it wasn't possible to do anything
    besides inserting objects; users could not start processes or execute
    queries.</para>

    <para>Drools 5.0 addresses all of these issues and more. The foundation
    for this is the <code>CommandExecutor</code> interface, which both the
    stateful and stateless interfaces extend, creating consistency and
    <code>ExecutionResults</code>:</para>

    <figure>
      <title>CommandExecutor</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-User_Guide/CommandExecutor.png"
                     format=""></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <figure>
      <title>ExecutionResults</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-User_Guide/ExecutionResults.png"
                     format=""></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>The <code>CommandFactory</code> allows for commands to be executed
    on those sessions, the only difference being that the Stateless Knowledge
    Session executes <code>fireAllRules()</code> at the end before disposing
    the session. The currently supported commands are:</para>

    <itemizedlist>
      <listitem>
        <para>FireAllRules</para>
      </listitem>

      <listitem>
        <para>GetGlobal</para>
      </listitem>

      <listitem>
        <para>SetGlobal</para>
      </listitem>

      <listitem>
        <para>InsertObject</para>
      </listitem>

      <listitem>
        <para>InsertElements</para>
      </listitem>

      <listitem>
        <para>Query</para>
      </listitem>

      <listitem>
        <para>StartProcess</para>
      </listitem>

      <listitem>
        <para>BatchExecution</para>
      </listitem>
    </itemizedlist>

    <para><code>InsertObject</code> will insert a single object, with an
    optional "out" identifier. <code>InsertElements</code> will iterate an
    Iterable, inserting each of the elements. What this means is that a
    Stateless Knowledge Session is no longer limited to just inserting
    objects, it can now start processes or execute queries, and do this in any
    order.</para>

    <example>
      <title>Insert Command</title>

      <programlisting language="java">StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();
ExecutionResults bresults =
  ksession.execute( CommandFactory.newInsert( new Cheese( "stilton" ), "stilton_id" ) );
Stilton stilton = bresults.getValue( "stilton_id" );
</programlisting>
    </example>

    <para>The execute method always returns an <code>ExecutionResults</code>
    instance, which allows access to any command results if they specify an
    out identifier such as the "stilton_id" above.</para>

    <example>
      <title>InsertElements Command</title>

      <programlisting language="java">StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();
Command cmd = CommandFactory.newInsertElements( Arrays.asList( Object[] { 
                  new Cheese( "stilton" ),
                  new Cheese( "brie" ),
                  new Cheese( "cheddar" ),
              });
ExecutionResults bresults = ksession.execute( cmd );
</programlisting>
    </example>

    <para>The execute method only allows for a single command. That's where
    <code>BatchExecution</code> comes in, which represents a composite
    command, created from a list of commands. Now, execute will iterate over
    the list and execute each command in turn. This means you can insert some
    objects, start a process, call fireAllRules and execute a query, all in a
    single <code>execute(...)</code> call, which is quite powerful.</para>

    <para>As mentioned previosly, the Stateless Knowledge Session will execute
    <code>fireAllRules()</code> automatically at the end. However the
    keen-eyed reader probably has already noticed the
    <code>FireAllRules</code> command and wondered how that works with a
    StatelessKnowledgeSession. The <code>FireAllRules</code> command is
    allowed, and using it will disable the automatic execution at the end;
    think of using it as a sort of manual override function.</para>

    <para>Commands support out identifiers. Any command that has an out
    identifier set on it will add its results to the returned ExecutionResults
    instance. Let's look at a simple example to see how this works.</para>

    <example>
      <title>BatchExecution Command</title>

      <programlisting language="java">StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();

List cmds = new ArrayList();        
cmds.add( CommandFactory.newInsertObject( new Cheese( "stilton", 1), "stilton") );
cmds.add( CommandFactory.newStartProcess( "process cheeses" ) );
cmds.add( CommandFactory.newQuery( "cheeses" ) );
ExecutionResults bresults = ksession.execute( CommandFactory.newBatchExecution( cmds ) );
Cheese stilton = ( Cheese ) bresults.getValue( "stilton" );
QueryResults qresults = ( QueryResults ) bresults.getValue( "cheeses" );
</programlisting>
    </example>

    <para>In the above example multiple commands are executed, two of which
    populate the <code>ExecutionResults</code>. The query command defaults to
    use the same identifier as the query name, but it can also be mapped to a
    different identifier.</para>

    <para>A custom XStream marshaller can be used with the Drools Pipeline to
    achieve XML scripting, which is perfect for services. Here are two simple
    XML samples, one for the BatchExecution and one for the
    <code>ExecutionResults</code>.</para>

    <example>
      <title>Simple BatchExecution XML</title>

      <programlisting language="xml">&lt;batch-execution&gt;
   &lt;insert out-identifier='outStilton'&gt;
      &lt;org.drools.Cheese&gt;
         &lt;type&gt;stilton&lt;/type&gt;
         &lt;price&gt;25&lt;/price&gt;
         &lt;oldPrice&gt;0&lt;/oldPrice&gt;
      &lt;/org.drools.Cheese&gt;
   &lt;/insert&gt;
&lt;/batch-execution&gt;
</programlisting>
    </example>

    <example>
      <title>Simple ExecutionResults XML</title>

      <programlisting language="xml">&lt;execution-results&gt;
   &lt;result identifier='outStilton'&gt;
      &lt;org.drools.Cheese&gt;
         &lt;type&gt;stilton&lt;/type&gt;
         &lt;oldPrice&gt;25&lt;/oldPrice&gt;        
         &lt;price&gt;30&lt;/price&gt;
      &lt;/org.drools.Cheese&gt;
   &lt;/result&gt;
&lt;/execution-results&gt;
</programlisting>
    </example>

    <para>Spring and Camel, covered in the integrations book, facilitate
    declarative services.</para>

    <example>
      <title>BatchExecution Marshalled to XML</title>

      <programlisting language="xml">&lt;batch-execution&gt;
  &lt;insert out-identifier="stilton"&gt;
    &lt;org.drools.Cheese&gt;
      &lt;type&gt;stilton&lt;/type&gt;
      &lt;price&gt;1&lt;/price&gt;
      &lt;oldPrice&gt;0&lt;/oldPrice&gt;
    &lt;/org.drools.Cheese&gt;
  &lt;/insert&gt;
  &lt;query out-identifier='cheeses2' name='cheesesWithParams'&gt;
    &lt;string&gt;stilton&lt;/string&gt;
    &lt;string&gt;cheddar&lt;/string&gt;
  &lt;/query&gt;
&lt;/batch-execution&gt;
</programlisting>
    </example>

    <para>The <code>CommandExecutor</code> returns an
    <code>ExecutionResults</code>, and this is handled by the pipeline code
    snippet as well. A similar output for the &lt;batch-execution&gt; XML
    sample above would be:</para>

    <example>
      <title>ExecutionResults Marshalled to XML</title>

      <programlisting language="xml">&lt;execution-results&gt;
  &lt;result identifier="stilton"&gt;
    &lt;org.drools.Cheese&gt;
      &lt;type&gt;stilton&lt;/type&gt;
      &lt;price&gt;2&lt;/price&gt;
    &lt;/org.drools.Cheese&gt;
  &lt;/result&gt;        
  &lt;result identifier='cheeses2'&gt;
    &lt;query-results&gt;
      &lt;identifiers&gt;
        &lt;identifier&gt;cheese&lt;/identifier&gt;
      &lt;/identifiers&gt;
      &lt;row&gt;
        &lt;org.drools.Cheese&gt;
          &lt;type&gt;cheddar&lt;/type&gt;
          &lt;price&gt;2&lt;/price&gt;
          &lt;oldPrice&gt;0&lt;/oldPrice&gt;
        &lt;/org.drools.Cheese&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;org.drools.Cheese&gt;
          &lt;type&gt;cheddar&lt;/type&gt;
          &lt;price&gt;1&lt;/price&gt;
          &lt;oldPrice&gt;0&lt;/oldPrice&gt;
        &lt;/org.drools.Cheese&gt;
      &lt;/row&gt;
    &lt;/query-results&gt;
  &lt;/result&gt;
&lt;/execution-results&gt;
</programlisting>
    </example>

    <para>The <code>BatchExecutionHelper</code> provides a configured XStream
    instance to support the marshalling of Batch Executions, where the
    resulting XML can be used as a message format, as shown above. Configured
    converters only exist for the commands supported via the Command Factory.
    The user may add other converters for their user objects. This is very
    useful for scripting stateless or stateful knowledge sessions, especially
    when services are involved.</para>

    <para>There is currently no XML schema to support schema validation. The
    basic format is outlined here, and the drools-pipeline module has an
    illustrative unit test in the <code>XStreamBatchExecutionTest</code> unit
    test. The root element is &lt;batch-execution&gt; and it can contain zero
    or more commands elements.</para>

    <example>
      <title>Root XML element</title>

      <programlisting language="xml">&lt;batch-execution&gt;
...
&lt;/batch-execution&gt;
</programlisting>
    </example>

    <para>This contains a list of elements that represent commands, the
    supported commands is limited to those Commands provided by the Command
    Factory. The most basic of these is the &lt;insert&gt; element, which
    inserts objects. The contents of the insert element is the user object, as
    dictated by XStream.</para>

    <example>
      <title>Insert</title>

      <programlisting language="xml">&lt;batch-execution&gt;
   &lt;insert&gt;
      ...&lt;!-- any user object --&gt;
   &lt;/insert&gt;
&lt;/batch-execution&gt;
</programlisting>
    </example>

    <para>The insert element features an "out-identifier" attribute, demanding
    that the inserted object will also be returned as part of the result
    payload.</para>

    <example>
      <title>Insert with Out Identifier Command</title>

      <programlisting language="xml">&lt;batch-execution&gt;
   &lt;insert out-identifier='userVar'&gt;
      ...
   &lt;/insert&gt;
&lt;/batch-execution&gt;
</programlisting>
    </example>

    <para>It's also possible to insert a collection of objects using the
    &lt;insert-elements&gt; element. This command does not support an
    out-identifier. The <code>org.domain.UserClass</code> is just an
    illustrative user object that XStream would serialize.</para>

    <example>
      <title>Insert Elements command</title>

      <programlisting language="xml">&lt;batch-execution&gt;
   &lt;insert-elements&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
   &lt;/insert-elements&gt;
&lt;/batch-execution&gt;
</programlisting>
    </example>

    <para>Next, there is the <code>&lt;set-global&gt;</code> element, which
    sets a global for the session.</para>

    <example>
      <title>Insert Elements command</title>

      <programlisting language="xml">&lt;batch-execution&gt;
   &lt;set-global identifier='userVar'&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
   &lt;/set-global&gt;
&lt;/batch-execution&gt;
</programlisting>
    </example>

    <para><code>&lt;set-global&gt;</code> also supports two other optional
    attributes, <literal>out</literal> and <literal>out-identifier</literal>.
    A true value for the boolean <literal>out</literal> will add the global to
    the <code>&lt;batch-execution-results&gt;</code> payload, using the name
    from the <literal>identifier</literal> attribute.
    <literal>out-identifier</literal> works like <literal>out</literal> but
    additionally allows you to override the identifier used in the
    <code>&lt;batch-execution-results&gt;</code> payload.</para>

    <example>
      <title>Set Global Command</title>

      <programlisting language="xml">&lt;batch-execution&gt;
   &lt;set-global identifier='userVar1' out='true'&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
   &lt;/set-global&gt;
   &lt;set-global identifier='userVar2' out-identifier='alternativeUserVar2'&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
   &lt;/set-global&gt;
&lt;/batch-execution&gt;
</programlisting>
    </example>

    <para>There is also a <code>&lt;get-global&gt;</code> element, without
    contents, with just an <literal>out-identifier</literal> attribute. (There
    is no need for an <literal>out</literal> attribute because retrieving the
    value is the sole purpose of a <code>&lt;get-global&gt;</code>
    element.</para>

    <example>
      <title>Get Global Command</title>

      <programlisting language="xml">&lt;batch-execution&gt;
   &lt;get-global identifier='userVar1' /&gt;
   &lt;get-global identifier='userVar2' out-identifier='alternativeUserVar2'/&gt;
&lt;/batch-execution&gt;
</programlisting>
    </example>

    <para>While the <literal>out</literal> attribute is useful in returning
    specific instances as a result payload, we often wish to run actual
    queries. Both parameter and parameterless queries are supported. The
    <literal>name</literal> attribute is the name of the query to be called,
    and the <literal>out-identifier</literal> is the identifier to be used for
    the query results in the <code>&lt;execution-results&gt;</code>
    payload.</para>

    <example>
      <title>Query Command</title>

      <programlisting language="xml">&lt;batch-execution&gt;
   &lt;query out-identifier='cheeses' name='cheeses'/&gt;
   &lt;query out-identifier='cheeses2' name='cheesesWithParams'&gt;
      &lt;string&gt;stilton&lt;/string&gt;
      &lt;string&gt;cheddar&lt;/string&gt;
   &lt;/query&gt;
&lt;/batch-execution&gt;
</programlisting>
    </example>

    <para>The <code>&lt;start-process&gt;</code> command accepts optional
    parameters. Other process related methods will be added later, like
    interacting with work items.</para>

    <example>
      <title>Start Process Command</title>

      <programlisting language="xml">&lt;batch-execution&gt;
   &lt;startProcess processId='org.drools.actions'&gt;
      &lt;parameter identifier='person'&gt;
         &lt;org.drools.TestVariable&gt;
            &lt;name&gt;John Doe&lt;/name&gt;
         &lt;/org.drools.TestVariable&gt;
      &lt;/parameter&gt;
   &lt;/startProcess&gt;
&lt;/batch-execution
</programlisting>
    </example>

    <example>
      <title>Signal Event Command</title>

      <programlisting language="xml">&lt;signal-event process-instance-id='1' event-type='MyEvent'&gt;
   &lt;string&gt;MyValue&lt;/string&gt;
&lt;/signal-event&gt;
</programlisting>
    </example>

    <example>
      <title>Complete Work Item Command</title>

      <programlisting language="xml">&lt;complete-work-item id='" + workItem.getId() + "' &gt;
   &lt;result identifier='Result'&gt;
      &lt;string&gt;SomeOtherString&lt;/string&gt;
   &lt;/result&gt;
&lt;/complete-work-item&gt;
</programlisting>
    </example>

    <example>
      <title>Abort Work Item Command</title>

      <programlisting language="xml">&lt;abort-work-item id='21' /&gt;
</programlisting>
    </example>

    <para>Support for more commands will be added over time.</para>
  </section>

  <section>
    <title>Marshalling</title>

    <para>The <code>MarshallerFactory</code> is used to marshal and unmarshal
    Stateful Knowledge Sessions.</para>

    <figure>
      <title>MarshallerFactory</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-User_Guide/MarshallerFactory.png"
                     format="" width="100%"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>At the simplest the <code>MarshallerFactory</code> can be used as
    follows:</para>

    <example>
      <title>Simple Marshaller Example</title>

      <programlisting language="java">// ksession is the StatefulKnowledgeSession
// kbase is the KnowledgeBase
ByteArrayOutputStream baos = new ByteArrayOutputStream();
Marshaller marshaller = MarshallerFactory.newMarshaller( kbase );
marshaller.marshall( baos, ksession );
baos.close();
</programlisting>
    </example>

    <para>However, with marshalling you need more flexibility when dealing
    with referenced user data. To achieve this we have the
    <code>ObjectMarshallingStrategy</code> interface. Two implementations are
    provided, but users can implement their own. The two supplied strategies
    are <code>IdentityMarshallingStrategy</code> and
    <code>SerializeMarshallingStrategy</code>.
    <code>SerializeMarshallingStrategy</code> is the default, as used in the
    example above, and it just calls the <code>Serializable</code> or
    <code>Externalizable</code> methods on a user instance.
    <code>IdentityMarshallingStrategy</code> instead creates an integer id for
    each user object and stores them in a Map, while the id is written to the
    stream. When unmarshalling it accesses the
    <code>IdentityMarshallingStrategy</code> map to retrieve the instance.
    This means that if you use the <code>IdentityMarshallingStrategy</code>,
    it is stateful for the life of the Marshaller instance and will create ids
    and keep references to all objects that it attempts to marshal. Below is
    he code to use an Identity Marshalling Strategy.</para>

    <example>
      <title>IdentityMarshallingStrategy</title>

      <programlisting language="java">ByteArrayOutputStream baos = new ByteArrayOutputStream();
ObjectMarshallingStrategy oms = MarshallerFactory.newIdentityMarshallingStrategy()
Marshaller marshaller =
  MarshallerFactory.newMarshaller( kbase, new ObjectMarshallingStrategy[]{ oms } );
marshaller.marshall( baos, ksession );
baos.close();
</programlisting>
    </example>

    <para>For added flexability we can't assume that a single strategy is
    suitable. Therefore we have added the
    <code>ObjectMarshallingStrategyAcceptor</code> interface that each Object
    Marshalling Strategy contains. The Marshaller has a chain of strategies,
    and when it attempts to read or write a user object it iterates the
    strategies asking if they accept responsability for marshalling the user
    object. One of the provided implementations is
    <code>ClassFilterAcceptor</code>. This allows strings and wild cards to be
    used to match class names. The default is "*.*", so in the above example
    the Identity Marshalling Strategy is used which has a default "*.*"
    acceptor.</para>

    <para>Assuming that we want to serialize all classes except for one given
    package, where we will use identity lookup, we could do the
    following:</para>

    <example>
      <title>IdentityMarshallingStrategy with Acceptor</title>

      <programlisting language="java">ByteArrayOutputStream baos = new ByteArrayOutputStream();
ObjectMarshallingStrategyAcceptor identityAcceptor =
  MarshallerFactory.newClassFilterAcceptor( new String[] { "org.domain.pkg1.*" } );
ObjectMarshallingStrategy identityStrategy =
  MarshallerFactory.newIdentityMarshallingStrategy( identityAcceptor );
ObjectMarshallingStrategy sms = MarshallerFactory.newSerializeMarshallingStrategy();
Marshaller marshaller =
  MarshallerFactory.newMarshaller( kbase,
                                   new ObjectMarshallingStrategy[]{ identityStrategy, sms } );
marshaller.marshall( baos, ksession );
baos.close();
</programlisting>
    </example>

    <para>Note that the acceptance checking order is in the natural order of
    the supplied array.</para>
  </section>

  <section>
    <title>Persistence and Transactions</title>

    <para>Longterm out of the box persistence with Java Persistence API (JPA)
    is possible with Drools. You will need to have some implementation of the
    Java Transaction API (JTA) installed. For development purposes we
    recommend the Bitronix Transaction Manager, as it's simple to set up and
    works embedded, but for production use JBoss Transactions is
    recommended.</para>

    <example>
      <title>Simple example using transactions</title>

      <programlisting language="java">Environment env = KnowledgeBaseFactory.newEnvironment();
env.set( EnvironmentName.ENTITY_MANAGER_FACTORY,
         Persistence.createEntityManagerFactory( "emf-name" ) );
env.set( EnvironmentName.TRANSACTION_MANAGER,
         TransactionManagerServices.getTransactionManager() );
          
// KnowledgeSessionConfiguration may be null, and a default will be used
StatefulKnowledgeSession ksession =
  JPAKnowledgeService.newStatefulKnowledgeSession( kbase, null, env );
int sessionId = ksession.getId();
 
UserTransaction ut =
  (UserTransaction) new InitialContext().lookup( "java:comp/UserTransaction" );
ut.begin();
ksession.insert( data1 );
ksession.insert( data2 );
ksession.startProcess( "process1" );
ut.commit();
</programlisting>
    </example>

    <para>To use a JPA, the Environment must be set with both the
    <code>EntityManagerFactory</code> and the <code>TransactionManager</code>.
    If rollback occurs the ksession state is also rolled back, so you can
    continue to use it after a rollback. To load a previously persisted
    Stateful Knowledge Session you'll need the id, as shown below:</para>

    <example>
      <title>Loading a StatefulKnowledgeSession</title>

      <programlisting language="java">StatefulKnowledgeSession ksession =
  JPAKnowledgeService.loadStatefulKnowledgeSession( sessionId, kbase, null, env );
</programlisting>
    </example>

    <para>To enable persistence several classes must be added to your
    persistence.xml, as in the example below:</para>

    <example>
      <title>Configuring JPA</title>

      <programlisting language="xml">&lt;persistence-unit name="org.drools.persistence.jpa" transaction-type="JTA"&gt;
   &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
   &lt;jta-data-source&gt;jdbc/BitronixJTADataSource&lt;/jta-data-source&gt;       
   &lt;class&gt;org.drools.persistence.session.SessionInfo&lt;/class&gt;
   &lt;class&gt;org.drools.persistence.processinstance.ProcessInstanceInfo&lt;/class&gt;
   &lt;class&gt;org.drools.persistence.processinstance.ProcessInstanceEventInfo&lt;/class&gt;
   &lt;class&gt;org.drools.persistence.processinstance.WorkItemInfo&lt;/class&gt;
   &lt;properties&gt;
         &lt;property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/&gt;            
         &lt;property name="hibernate.max_fetch_depth" value="3"/&gt;
         &lt;property name="hibernate.hbm2ddl.auto" value="update" /&gt;
         &lt;property name="hibernate.show_sql" value="true" /&gt;
         &lt;property name="hibernate.transaction.manager_lookup_class"
                      value="org.hibernate.transaction.BTMTransactionManagerLookup" /&gt;
   &lt;/properties&gt;
&lt;/persistence-unit&gt;
</programlisting>
    </example>

    <para>The jdbc JTA data source would have to be configured first. Bitronix
    provides a number of ways of doing this, and its documentation should be
    contsulted for details. For a quick start, here is the programmatic
    approach:</para>

    <example>
      <title>Configuring JTA DataSource</title>

      <programlisting language="java">PoolingDataSource ds = new PoolingDataSource();
ds.setUniqueName( "jdbc/BitronixJTADataSource" );
ds.setClassName( "org.h2.jdbcx.JdbcDataSource" );
ds.setMaxPoolSize( 3 );
ds.setAllowLocalTransactions( true );
ds.getDriverProperties().put( "user", "sa" );
ds.getDriverProperties().put( "password", "sasa" );
ds.getDriverProperties().put( "URL", "jdbc:h2:mem:mydb" );
ds.init();
</programlisting>
    </example>

    <para>Bitronix also provides a simple embedded JNDI service, ideal for
    testing. To use it add a jndi.properties file to your META-INF and add the
    following line to it:</para>

    <example>
      <title>JNDI properties</title>

      <programlisting>java.naming.factory.initial=bitronix.tm.jndi.BitronixInitialContextFactory
</programlisting>
    </example>
  </section>

  <section>
    <title>Drools Clips</title>

    <para>Drools Clips is an alpha level research project to provide a Clips
    like front end ot Drools.</para>

    <para>Deftemplates are working, the knowledge base handles multiple name
    spaces and you can attach the knoweldge base to the session for interative
    building, to provide a more "shell" like environment suitable for
    Clips.</para>

    <itemizedlist>
      <listitem>
        <para>deftemplate</para>
      </listitem>

      <listitem>
        <para>defrule</para>
      </listitem>

      <listitem>
        <para>deffunction</para>
      </listitem>

      <listitem>
        <para>and/or/not/exists/test conditional elements</para>
      </listitem>

      <listitem>
        <para>Literal, Variable, Return Value and Predicate field
        constarints</para>
      </listitem>
    </itemizedlist>

    <mediaobject>
      <imageobject>
        <imagedata fileref="images/Chapter-User_Guide/clips-shell.png"></imagedata>
      </imageobject>
    </mediaobject>

    <para>This project is very early stages and in need of love. If you want
    to help, open up eclipse import api, core, compiler and clips and you
    should be good to go. The unit tests should be self explanatory.</para>
  </section>
</section>
