<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="../" xmlns="http://docbook.org/ns/docbook" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:ns="http://docbook.org/ns/docbook">
    <title>State Example</title>

    <para>This example is implemented in three different versions to
    demonstrate different ways of implementing the same basic behavior:
    forward chaining, i.e., the ability the engine has to  evaluate,
    activate and fire rules in sequence, based on changes on the facts
    in the Working Memory.</para>
    
    <section>
      <title>Understanding the State Example</title>

      <screen><emphasis role="bold">Name:</emphasis> State Example
<emphasis role="bold">Main class:</emphasis> org.drools.examples.state.StateExampleUsingSalience
<emphasis role="bold">Module:</emphasis> drools-examples
<emphasis role="bold">Type:</emphasis> Java application
<emphasis role="bold">Rules file:</emphasis> StateExampleUsingSalience.drl
<emphasis role="bold">Objective:</emphasis> Demonstrates basic rule use
  and Conflict Resolution for rule firing priority.</screen>

      <para>Each <code>State</code> class has fields for its name and its
      current state (see the class <code>org.drools.examples.state.State</code>).
      The two possible states for each objects are:</para>

      <itemizedlist>
        <listitem>
          <para><code>NOTRUN</code></para>
        </listitem>

        <listitem>
          <para><code>FINISHED</code></para>
        </listitem>
      </itemizedlist>

      <example>
        <title>State Class</title>

        <programlisting language="java">public class State {
    public static final int NOTRUN   = 0;
    public static final int FINISHED = 1;

    private final PropertyChangeSupport changes =
        new PropertyChangeSupport( this );

    private String name;
    private int    state;

    ... setters and getters go here...
}</programlisting>
      </example>

      <para>Ignoring the <code>PropertyChangeSupport</code>, which will
      be explained later, we see the creation of four <code>State</code>
      objects named A, B, C and D. Initially their states are set to
      <code>NOTRUN</code>, which is default for the used constructor.
      Each instance is asserted in turn into the Session and then
      <code>fireAllRules()</code> is called.</para>

      <example>
        <title>Salience State: Execution</title>

        <programlisting language="java">State a = new State( "A" );
State b = new State( "B" );
State c = new State( "C" );
final State d = new State( "D" );

// By setting dynamic to TRUE, Drools will use JavaBean
// PropertyChangeListeners so you don't have to call modify or update().
boolean dynamic = true;

session.insert( a, dynamic );
session.insert( b, dynamic );
session.insert( c, dynamic );
session.insert( d, dynamic );

session.fireAllRules();
session.dispose(); // Stateful rule session must always be disposed when finished</programlisting>
      </example>

      <para>To execute the application:</para>

      <orderedlist>
        <listitem>
          <para>Open the class <code>org.drools.examples.state.StateExampleUsingSalience</code> in your Eclipse IDE.</para>
        </listitem>

        <listitem>
          <para>Right-click the class and select "Run as..." and then
          "Java application"</para>
        </listitem>
      </orderedlist>

      <para>You will see the following output in the Eclipse console
      window:</para>

      <example>
        <title>Salience State: Console Output</title>

        <programlisting>A finished
B finished
C finished
D finished
</programlisting>
      </example>

      <para>There are four rules in total. First, the <code>Bootstrap</code>
      rule fires, setting A to state <code>FINISHED</code>, which then
      causes B to change its state to <code>FINISHED</code>. C and D are
      both dependent on B, causing a conflict which is resolved by the
      salience values. Let's look at the way this was executed.</para>

      <para>The best way to understand what is happening is to use the
      Audit Logging feature to graphically see the results of each
      operation. To view the Audit log generated by a run of this
      example:</para>

      <orderedlist>
        <listitem>
          <para>If the Audit View is not visible, click on "Window" and
          then select "Show View", then "Other..." and "Drools" and
          finally "Audit View".</para>
        </listitem>

        <listitem>
          <para>In the "Audit View" click the "Open Log" button and select
          the file "&lt;drools-examples-dir&gt;/log/state.log".</para>
        </listitem>
      </orderedlist>

      <para>After that, the "Audit view" will look like the following
      screenshot:</para>

      <figure>
        <title>Salience State Example Audit View</title>

        <mediaobject>
          <imageobject>
            <imagedata width="100%"
                       fileref="images/Chapter-Examples/StateExample/state_example_audit1.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Reading the log in the "Audit View", top to bottom, we see every
      action and the corresponding changes in the Working Memory. This way
      we observe that the assertion of the State object A in the state
      <code>NOTRUN</code> activates the <code>Bootstrap</code> rule, while
      the assertions of the other <code>State</code> objects have no
      immediate effect.</para>

      <example>
        <title>Salience State: Rule "Bootstrap"</title>

        <programlisting>rule Bootstrap
    when
        a : State(name == "A", state == State.NOTRUN )
    then
        System.out.println(a.getName() + " finished" );
        a.setState( State.FINISHED );
end</programlisting>
      </example>

      <para>The execution of rule Bootstrap changes the state of A to
      <code>FINISHED</code>, which, in turn, activates rule "A to B".</para>

      <example>
        <title>Salience State: Rule "A to B"</title>

        <programlisting>rule "A to B"
    when
        State(name == "A", state == State.FINISHED )
        b : State(name == "B", state == State.NOTRUN )
    then
        System.out.println(b.getName() + " finished" );
        b.setState( State.FINISHED );
end
</programlisting>
      </example>

      <para>The execution of rule "A to B" changes the state of B to
      <code>FINISHED</code>, which activates both, rules "B to C" and
      "B to D", placing their Activations onto the Agenda. From this moment
      on, both rules may fire and, therefore, they are said to be
      "in conflict". The conflict resolution strategy allows the engine's
      Agenda to decide which rule to fire. As rule "B to C"  has the
      <emphasis role="bold">higher salience value</emphasis> (10 versus
      the default salience value of 0), it fires first, modifying object C
      to state <code>FINISHED</code>. The Audit view shown above reflects
      the  modification of the <code>State</code> object in the rule "A to B",
      which results in two activations being in conflict. The Agenda view
      can also be used to investigate the state of the Agenda, with debug
      points being placed in the rules themselves and the Agenda view opened.
      The screen shot below shows the breakpoint in the rule "A to B" and
      the state of the Agenda with the two conflicting rules.</para>

      <figure>
        <title>State Example Agenda View</title>
  
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter-Examples/StateExample/state_example_agenda1.png" />
          </imageobject>
        </mediaobject>
      </figure>
  
      <example>
        <title>Salience State: Rule "B to C"</title>
  
        <programlisting>rule "B to C"
        salience 10
    when
        State(name == "B", state == State.FINISHED )
        c : State(name == "C", state == State.NOTRUN )
    then
        System.out.println(c.getName() + " finished" );
        c.setState( State.FINISHED );
end
</programlisting>
      </example>

      <para>Rule "B to D"  fires last, modifying object D to state
      <code>FINISHED</code>.</para>
  
      <example>
        <title>Salience State: Rule "B to D"</title>
  
        <programlisting>rule "B to D"
    when
        State(name == "B", state == State.FINISHED )
        d : State(name == "D", state == State.NOTRUN )
    then
        System.out.println(d.getName() + " finished" );
        d.setState( State.FINISHED );
end</programlisting>
      </example>
  
      <para>There are no more rules to execute and so the engine stops.</para>
  
      <para>Another notable concept in this example is the use of
      <emphasis>dynamic facts</emphasis>, based on
      <code>PropertyChangeListener</code> objects. As described in the
      documentation, in order for the engine to see and react to changes of
      fact properties, the application must tell the engine that changes
      occurred. This can be done explicitly in the rules by using the
      <literal>modify</literal> statement, or implicitly by letting the engine know
      that the facts implement <code>PropertyChangeSupport</code> as defined
      by the <emphasis>JavaBeans specification</emphasis>. This example
      demonstrates how to use <code>PropertyChangeSupport</code> to avoid
      the need for explicit <literal>modify</literal> statements in the rules. To
      make use of this feature, ensure that your facts implement
      <code>PropertyChangeSupport</code>, the same way the class
      <code>org.drools.example.State</code> does, and use the following
      code to insert the facts into the Working Memory:</para>
  
      <example>
        <title>Inserting a Dynamic Fact</title>
  
        <programlisting language="java">// By setting dynamic to TRUE, Drools will use JavaBean
// PropertyChangeListeners so you don't have to call modify or update().
final boolean dynamic = true;

session.insert( fact, dynamic );
</programlisting>
      </example>
  
      <para>When using <code>PropertyChangeListener</code> objects, each
      setter must implement a little extra code for the notification. Here
      is the setter for <code>state</code> in the class
      <code>org.drools.examples</code>:</para>:
  
      <example>
        <title>Setter Example with PropertyChangeSupport</title>
  
        <programlisting language="java">public void setState(final int newState) {
    int oldState = this.state;
    this.state = newState;
    this.changes.firePropertyChange( "state",
                                     oldState,
                                     newState );
}</programlisting>
      </example>

      <para>There are two other classes in this example:
      <code>StateExampleUsingAgendaGroup</code> and
      <code>StateExampleWithDynamicRules</code>. Both execute from A to B
      to C to D, as just shown. The <code>StateExampleUsingAgendaGroup</code>
      uses agenda-groups to control the rule conflict and which one fires
      first. <code>StateExampleWithDynamicRules</code> shows how an
      additional rule can be added to an already running Working Memory
      with all the existing data applying to it at runtime.</para>
  
      <para>Agenda groups are a way to partition the Agenda into groups
      and to control which groups can execute. By default, all rules are
      in the agenda group "MAIN". The "agenda-group" attribute lets
      you specify a different agenda group for the rule. Initially,
      a Working Memory has its focus on the Agenda group "MAIN". A group's
      rules will only fire when the group receives the focus. This can be
      achieved either ny using the method by <code>setFocus()</code> or the
      rule attribute <literal>auto-focus</literal>. "auto-focus" means that the rule
      automatically sets the focus to its agenda group when the rule is
      matched and activated. It is this "auto-focus" that enables rule
      "B to C" to fire before "B to D".</para>
  
      <example>
        <title>Agenda Group State Example: Rule "B to C"</title>
  
        <programlisting>rule "B to C"
      agenda-group "B to C"
      auto-focus true       
  when
      State(name == "B", state == State.FINISHED )      
      c : State(name == "C", state == State.NOTRUN )
  then
      System.out.println(c.getName() + " finished" );
      c.setState( State.FINISHED );
      kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "B to D" ).setFocus();
end</programlisting>
      </example>

      <para>The rule "B to C" calls <code>setFocus()</code> on the
      agenda group "B to D", allowing its active rules
      to fire, which allows the rule "B to D" to fire.</para>

      <example>
        <title>Agenda Group State Example: Rule "B to D"</title>

        <programlisting>rule "B to D"
      agenda-group "B to D"
  when
      State(name == "B", state == State.FINISHED )      
      d : State(name == "D", state == State.NOTRUN )
  then
      System.out.println(d.getName() + " finished" );
      d.setState( State.FINISHED );
end</programlisting>
      </example>

      <para>The example <code>StateExampleWithDynamicRules</code> adds
      another rule to the Rule Base after <code>fireAllRules()</code>.
      The added rule is just another state transition.</para>

      <example>
        <title>Dynamic State Example: Rule "D to E"</title>

        <programlisting>rule "D to E"
  when
      State(name == "D", state == State.FINISHED )      
      e : State(name == "E", state == State.NOTRUN )
  then
      System.out.println(e.getName() + " finished" );
      e.setState( State.FINISHED );
end</programlisting>
      </example>

      <para>This produces the following expected output:</para>

      <example>
        <title>Dynamic Sate Example Output</title>
  
        <programlisting>A finished
B finished
C finished
D finished
E finished
</programlisting>
      </example>
      
    </section>
    
  </section>
