<?xml version="1.0" encoding="UTF-8"?>
	<section version="5.0" xmlns="http://docbook.org/ns/docbook"
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xmlns:xi="http://www.w3.org/2001/XInclude"
                    xmlns:svg="http://www.w3.org/2000/svg"
                    xmlns:m="http://www.w3.org/1998/Math/MathML"
                    xmlns:html="http://www.w3.org/1999/xhtml"
                    xmlns:db="http://docbook.org/ns/docbook" xml:base="../../">
  <title>Rule</title>

  <figure>
    <title>rule</title>

    <mediaobject>
     <imageobject>
	     <imagedata align="center" fileref="images/Chapter-Rule_Language/rule.png" format="PNG" role="" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>A rule specifies that <emphasis>when</emphasis> a particular set
  of conditions occur, specified in the Left Hand Side (LHS), 
  <emphasis>then</emphasis> do what is specified as a list of actions in
  the Right Hand Side (RHS). A common question from users
  is "Why use when instead of if?" "When" was chosen over "if" because "if" is
  normally part of a procedural execution flow, where, at a specific point in
  time, a condition is to be checked. In contrast, "when" indicates that
  the condition evaluation is not tied to a specific evaluation sequence
  or point in time, but that it happens continually, at any time during
  the life time of the engine; whenever the condition is met, the
  actions are executed.</para>

  <para>A rule must have a name, unique within its rule package. If
  you define a rule twice in the same DRL it produces an error while loading.
  If you add a DRL that includes a rule name already in the package, it
  replaces the previous rule. If a rule name is to have spaces, then it
  will need to be enclosd in double quotes (it is best to always use double
  quotes).</para>

  <para>Attributes - described below - are optional. They are best written
  one per line.</para>

  <para>The LHS of the rule follows the "when" keyword (ideally on a new
  line), similarly the RHS follows the "then" keyword (again, ideally on
  a newline). The rule is terminated by the keyword "end". Rules cannot
  be nested.</para>

  <example>
    <title>Rule Syntax Overview</title>

    <programlisting>rule "&lt;name&gt;"
    &lt;attribute&gt;*
when
    &lt;conditional element&gt;*
then
    &lt;action&gt;*
end</programlisting>
  </example>

  <example>
    <title>A simple rule</title>

    <programlisting>rule "Approve if not rejected"
  salience -100 
  agenda-group "approval"
    when
        not Rejection() 
        p : Policy(approved == false, policyState:status)
        exists Driver(age &gt; 25)
        Process(status == policyState)
    then
        log("APPROVED: due to no objections."); 
        p.setApproved(true);
end</programlisting>
  </example>

  <section>
    <title>Rule Attributes</title>

    <para>Rule attributes provide a declarative way to influence the behavior
    of the rule. Some are quite simple, while others are part of complex
    subsystems such as ruleflow. To get the most from Drools you should make
    sure you have a proper understanding of each attribute.</para>

    <figure>
      <title>rule attributes</title>

      <mediaobject>
        <imageobject>
	  <imagedata align="center" fileref="images/Chapter-Rule_Language/rule_attributes.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <variablelist>
      <varlistentry>
	<term>no-loop</term>
	
	<listitem>
	  <para>default value: false</para>
	
	  <para>type: Boolean</para>
	
	  <para>When the rule's consequence modifies a fact it may cause
	    the Rule to activate again, causing recursion. Setting no-loop
	    to true means the attempt to create the Activation for the
	    current set of data will be ignored.</para>
	</listitem>
				
      </varlistentry>

      <varlistentry>
	<term>ruleflow-group</term>
	
	<listitem>
	  <para>default value: N/A</para>
	  
	  <para>type: String</para>
		
	  <para>Ruleflow is a Drools feature that lets you exercise
          control over the firing of rules. Rules that are assembled
          by the same ruleflow-group identifier fire only when 
          their group is active.</para>
	</listitem>
      </varlistentry>
	
      <varlistentry>
	<term>lock-on-active</term>
	
	<listitem>
	  <para>default value: false</para>
	  
	  <para>type: Boolean</para>
	  <para>Whenever a ruleflow-group becomes active or an
	    agenda-group receives the focus, any rule within that
	    group that has lock-on-active set to true will not be
	    activated any more; irrespective of the origin of the
	    update, the activation of a matching rule is discarded.
	    This is a stronger version of no-loop, because the change
	    could now be caused not only by the rule itself. It's
	    ideal for calculation rules where you have a number of
	    rules that modify a fact and you don't want any rule
	    re-matching and firing again. Only when the ruleflow-group
	    is no longer active or the agenda-group loses the focus
	    those rules with lock-on-active set to true become
	    eligible again for their activations to be placed onto
	    the agenda.</para>
	</listitem>
      </varlistentry>
	
      <varlistentry>
	<term>salience</term>
	
	<listitem>
	  <para>default value : 0</para>
	
	  <para>type : integer</para>
	
	  <para>Each rule has a salience attribute that can be assigned
	    an integer number, which defaults to zero and can be
	    negative or positive. Salience is a form of priority where
	    rules with higher salience values are given higher priority
	    when ordered in the Activation queue.</para>
	</listitem>
      </varlistentry>
	
	
      <varlistentry>
	<term>agenda-group</term>
	
	<listitem>
	  <para>default value: MAIN</para>
	  
	  <para>type: String</para>
		
	  <para>Agenda groups allow the user to partition the Agenda
          providing more execution control. Only rules in the agenda
          group that has acquired the focus are allowed to fire.</para>
	</listitem>
      </varlistentry>
		
      <varlistentry>
	<term>auto-focus</term>
	
	<listitem>
	  <para>default value: false</para>
	  
	  <para>type: Boolean</para>
				
	  <para>When a rule is activated where the <code>auto-focus</code>
          value is true and the rule's agenda group does
          not have focus yet, then it is given focus, allowing the rule to
          potentially fire.</para>
	</listitem>
      </varlistentry>
	
      <varlistentry>
	<term>activation-group</term>
	
	<listitem>
	  <para>default value: N/A</para>
				
	  <para>type: String</para>
				
	  <para>Rules that belong to the same activation-group, identified
          by this attribute's string value, will only fire exclusively. In
          other words, the first rule in an activation-group to fire will
          cancel the other rules' activations, i.e., stop them from firing.</para>
				
	  <para>Note: This used to be called Xor group, but technically it's
          not quite an Xor. You may still hear people mention Xor group;
          just swap that term in your mind with activation-group.</para>
	</listitem>
      </varlistentry>
	
      <varlistentry>
	<term>dialect</term>
	
	<listitem>
	  <para>default value: as specified by the package</para>
				
	  <para>type: String</para>
				
	  <para>possible values: "java" or "mvel"</para>
				
	  <para>The dialect species the language to be used for any code
	  expressions in the LHS or the RHS code block. Currently two 
          dialects are available, Java and MVEL. While the dialect can
          be specified at the package level, this attribute allows the 
          package definition to be overridden for a rule.</para>
	</listitem>
      </varlistentry>
	
	
      <varlistentry>
	<term>date-effective</term>
	
	<listitem>
	  <para>default value: N/A</para>	
				
	  <para>type: String, containing a date and time definition</para>
				
	  <para>A rule can only activate if the current date and time is
          after date-effective attribute.</para>
	</listitem>
      </varlistentry>
	
      <varlistentry>	
	<term>date-expires</term>
	
	<listitem>
	  <para>default value: N/A</para>
				
	  <para>type: String, containing a date and time definition</para>
				
	  <para>A rule cannot activate if the current date and time is 
          after the date-expires attribute.</para>
	</listitem>
      </varlistentry>
	
      <varlistentry>
	<term>duration</term>
	
	<listitem>
	  <para>default value: no default value</para>
	
	  <para>type: long</para>
	
	  <para>The duration dictates that the rule will fire after a
          specified duration, if it is still true.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <example>
      <title>Some attribute examples</title>

      <programlisting>rule "my rule"
  salience 42
  agenda-group "number 1"
    when ...
</programlisting>
    </example>
  </section>

  <section id="RuleLanguage-ConditionalElements">
    <title>Left Hand Side (when) Conditional Elements</title>

    <para>The Left Hand Side (LHS) is a common name for the conditional part
    of the rule. It consists of zero or more Conditional Elements. If the LHS
    is left empty, it is re-written as <code>eval(true)</code>, which means 
    that the rule's condition is always true. It will be activated, once,
    when a new Working Memory session is created.</para>

    <figure>
      <title>Left Hand Side</title>

      <mediaobject>
        <imageobject>
		<imagedata align="center" fileref="images/Chapter-Rule_Language/lhs.png" format="PNG" role="" />
        </imageobject>
      </mediaobject>
    </figure>

    <example>
      <title>Rule without a Conditional Element</title>

      <programlisting>rule "no CEs"
when
then
    &lt;action&gt;*
end

# The above rule is internally rewritten as:

rule "eval(true)"
when
    eval( true )
then
    &lt;action&gt;*
end</programlisting>
    </example>

    <para>Conditional elements work on one or more <emphasis>patterns</emphasis> (which are
    described below). The most common one is "and", which is implicit when you
    have multiple patterns in the LHS of a rule that are not connected in
    any way. Note that an "and" cannot have a leading declaration binding like
    "or". This is obvious, since a declaration can only
    reference a single fact, and when the "and" is satisfied it matches more
    than one fact - so which fact would the declaration bind to?</para>

    <section>
      <title>Pattern</title>

      <para>The pattern element is the most important Conditional Element. The
      entity relationship diagram below provides an overview of the various
      parts that make up the pattern's constraints and how they work together;
      each is then covered in more detail with railroad diagrams and
      examples.</para>

      <figure>
        <title>Pattern Entity Relationship Diagram</title>

        <mediaobject>
          <imageobject>
		  <imagedata align="center" fileref="images/Chapter-Rule_Language/patternER.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>At the top of the ER diagram you can see that the pattern consists
      of zero or more constraints and has an optional pattern binding. The
      railroad diagram below shows the syntax for this.</para>

      <figure>
        <title>Pattern</title>

        <mediaobject>
          <imageobject>
		  <imagedata align="center" fileref="images/Chapter-Rule_Language/pattern.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>In its simplest form, with no constraints, a pattern matches
      against a fact of the given type. In the following case the type
      is <code>Cheese</code>, which means that the pattern will match
      against all <code>Cheese</code> objects in the Working Memory.</para>

      <para>Notice that the type need not be the actual class of some
      fact object. Patterns may refer to superclasses or even interfaces,
      thereby potentially matching facts from many different
      classes.</para>

      <example>
        <title>Simple Pattern</title>

        <programlisting>Cheese()</programlisting>
      </example>

      <para>For referring to the matched object, use a pattern binding
      variable such as '$c'. The prefixed '$' symbol is optional; it can
      be useful in complex rules where it helps to more easily
      differentiate between variables and fields.</para>

      <example>
        <title>Pattern with a binding variable</title>

        <programlisting>$c : Cheese()</programlisting>
      </example>

      <para>Inside of the pattern parenthesis is where all the action happens.
      A constraint can be either a Field Constraint, Inline Eval,
      or a Constraint Group. Constraints can be separated by
      the following symbols: ',', '&amp;&amp;' or '||'.</para>

      <figure>
        <title>Constraints</title>

        <mediaobject>
          <imageobject>
		  <imagedata align="center" fileref="images/Chapter-Rule_Language/constraints.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>Constraint</title>

        <mediaobject>
          <imageobject>
		  <imagedata align="center" fileref="images/Chapter-Rule_Language/constraint.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>constraintGroup</title>

        <mediaobject>

          <imageobject>
		  <imagedata align="center" fileref="images/Chapter-Rule_Language/constraintGroup.png"
                       format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The ',' (comma) character is used to separate constraint groups.
      It has implicit "and" connective semantics.<example>
          <title>Constraint Group connective ','</title>

          <programlisting># Cheese type is stilton and price &lt; 10 and age is mature.
Cheese( type == "stilton", price &lt; 10, age == "mature" )</programlisting>
        </example>The above example has three constraint groups, each with a
      single constraint:</para>

      <itemizedlist>
        <listitem>
          <para>Group 1 - <code>type == "stilton"</code> requires that the
          type is stilton.</para>
        </listitem>

        <listitem>
          <para>Group 2 - <code>price &lt; 10</code> demands a price less
          than 10.</para>
        </listitem>

        <listitem>
          <para>Group 3 - <code>age == "mature"</code> accepts only mature
          cheese.</para>
        </listitem>
      </itemizedlist>

      <para>The '&amp;&amp;' (and) and '||' (or) constraint connectives allow
      constraint groups to have multiple constraints. Example:</para>

      <example>
        <title>&amp;&amp; and || Constraint Connectives</title>

        <programlisting>// Cheese type is "stilton" and price &lt; 10, and age is mature
Cheese( type == "stilton" &amp;&amp; price &lt; 10, age == "mature" )
// Cheese type is "stilton" or price &lt; 10, and age is mature
Cheese( type == "stilton" || price &lt; 10, age == "mature" )</programlisting>
      </example>

      <para>The above example has two constraint groups. The first has two
      constraints and the second has one constraint.</para>

      <para>The connectives are evaluated in the following order, from first
      to last:</para>

      <orderedlist>
        <listitem>
          <para>&amp;&amp;</para>
        </listitem>

        <listitem>
          <para>||</para>
        </listitem>

        <listitem>
          <para>,</para>
        </listitem>
      </orderedlist>

      <para>It is possible to change the evaluation priority by using
      parentheses, as in any logic or mathematical expression. Example:</para>

      <para><example>
          <title>Using parentheses to change evaluation priority</title>

          <programlisting># Cheese type is stilton and ( price is less than 20 or age is mature ).
Cheese( type == "stilton" &amp;&amp; ( price &lt; 20 || age == "mature" ) ) </programlisting>
        </example>In the above example, the use of parentheses evaluates the
      connective '||' before the connective '&amp;&amp;'.</para>

      <para>Also, it is important to note that besides having the same
      semantics, the connectives '&amp;&amp;' and ',' are resolved with
      different priorities, and ',' cannot be embedded in a composite
      constraint expression.</para>

      <example>
        <title>Not Equivalent connectives</title>

        <programlisting>// invalid as ',' cannot be embedded in an expression:
Cheese( ( type == "stilton", price &lt; 10 ) || age == "mature" )
// valid as '&amp;&amp;' can be embedded in an expression:
Cheese( ( type == "stilton" &amp;&amp; price &lt; 10 ) || age == "mature")</programlisting>
      </example>

      <section>
        <title>Field Constraints</title>

        <para>A Field constraint specifies a restriction to be used on a
        named field; the field name can have an optional variable
        binding.</para>

        <figure>
          <title>fieldConstraint</title>

          <mediaobject>

            <imageobject>
		    <imagedata align="center" fileref="images/Chapter-Rule_Language/fieldConstraint.png"
                         format="PNG" role="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>There are three types of restrictions: Single Value Restriction,
        Compound Value Restriction, and Multi Restriction.</para>

        <figure>
          <title>restriction</title>

          <mediaobject>

            <imageobject>
		    <imagedata align="center" fileref="images/Chapter-Rule_Language/restriction.png" format="PNG"
                         role="" />
            </imageobject>
          </mediaobject>
        </figure>

        <section>
          <title>JavaBeans as facts</title>

          <para>A field is derived from an accessible method of the object.
          If your model
          objects follow the Java Bean pattern, then fields are exposed using
          "getXXX" or "isXXX" methods, where these methods take no
          arguments, and return something. Within patterns, fields can be
          accessed using the bean naming convention, so that "getType" would
          be accessed as "type". Drools uses the standard JDK Introspector
          class to do this mapping.</para>

          <para>For example, referring to our Cheese class, the pattern
          <code>Cheese(type == "brie")</code> applies the getType() method
          to a Cheese instance. If a field name cannot be found, the
          compiler will resort to using the name as a method without
          arguments. Thus, the method "toString()" is called due to a
          constraint <code>Cheese(toString == "cheddar")</code>. In this
          case, you use the full name of the method with correct
          capitalization, but still without parentheses. Do
          please make sure that you are accessing methods that take no
          parameters, and that are in fact "accessors" which don't change
          the state of the object in a way that may effect the rules.
          Remember that the rule engine effectively caches the results of its
          matching in between invocations to make it faster.</para>
        </section>

        <section>
          <title>Values</title>

          <para>The field constraints can take a number of values; including
          literal, qualifiedIdentifier (enum), variable and
          returnValue.</para>

          <figure>
            <title>literal</title>

            <mediaobject>
              <imageobject>
		      <imagedata align="center" fileref="images/Chapter-Rule_Language/literal.png" format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <figure>
            <title>qualifiedIdentifier</title>

            <mediaobject>
              <imageobject>
		      <imagedata align="center" fileref="images/Chapter-Rule_Language/qualifiedIdentifier.png"
                           format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <figure>
            <title>variable</title>

            <mediaobject>

              <imageobject>
		      <imagedata align="center" fileref="images/Chapter-Rule_Language/identifier.png"
                           format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <figure>
            <title>returnValue</title>

            <mediaobject>
              <imageobject>
		      <imagedata align="center" fileref="images/Chapter-Rule_Language/returnValue.png"
                           format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>You can do checks against fields that are or may be null, using
          '==' and '!=' as you would expect, and the literal "null" keyword, as
          in <code>Cheese(type != null)</code>, where the evaluator will not
          throw an exception and return true if the value is null.
          Type coercion is always attempted if the field and the value are
          of different types; exceptions will be thrown if a bad coercion is
          attempted. For instance, if "ten" is provided as a string in a numeric
          evaluator, an exception is thrown, whereas "10" would coerce to a
	  numeric 10. Coercion is
          always in favor of the field type and not the value type.</para>
        </section>

        <section>
          <title>Single Value Restriction</title>

          <figure>
            <title>singleValueRestriction</title>

            <mediaobject>
              <imageobject>
		      <imagedata align="center" fileref="images/Chapter-Rule_Language/singleValueRestriction.png"
                           format="PNG" role="" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>A Single Value Restriction is a binary relation, applying a binary
          operator to the field value and another value, which may be a literal,
          a variable, a parenthesized expression ("return value"), or a qualified
          identifier, i.e., an enum constant.</para>


          <section>
            <title>Operators</title>

            <figure>
              <title>Operators</title>

              <mediaobject>
                <imageobject>
			<imagedata align="center" fileref="images/Chapter-Rule_Language/operator.png"
                             format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <para>The operators '==' and '!=' are valid for all types. Other
            relational operatory may be used whenever the type values are
            ordered; for date fields, "&lt;" means "before". The pair "matches" and
            "not matches" is only applicable to string fields, "contains" and
            "not contains" require the field to be of some  Collection type.
            Coercion to the correct value for the evaluator and the field will be 
            attempted, as mentioned in the "Values" section.</para>

            <simplesect>
              <title>Matches Operator</title>

              <para>Matches a field against any valid Java <indexterm>
                  <primary>regular expression</primary>
                </indexterm>Regular Expression. Typically that regexp is a
              string literal, but variables that resolve to a valid regexp are also
              allowed. It is important to note that, <emphasis>different from
              Java</emphasis>, within regular expressions written as string literals
              <emphasis>you don't need to escape '\'</emphasis>. Example:</para>

              <example>
                <title>Regular Expression Constraint</title>

                <programlisting>Cheese( type matches "(Buffalo)?\S*Mozarella" )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>Not Matches Operator</title>

              <para>The operator returns true if the string does not match the
              regular expression. The same rules apply as for the "matches" operator.
              Example:</para>

              <example>
                <title>Regular Expression Constraint</title>

                <programlisting>Cheese( type not matches "(Buffulo)?\S*Mozarella" )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>Contains Operator</title>

              <para>The operator <code>contains</code> is used to check whether a
              field that is a <indexterm>
                  <primary>Collection</primary>
                </indexterm>Collection or array contains the specified
              value.</para>

              <example>
                <title>Contains with Collections</title>

                <programlisting>CheeseCounter( cheeses contains "stilton" ) // contains with a String literal
CheeseCounter( cheeses contains $var ) // contains with a variable</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>not contains</title>

              <para>The operator <code>not contains</code> is used to check whether a
              field that is a <indexterm>
                  <primary>Collection</primary>
                </indexterm>Collection or array does <emphasis>not</emphasis> contain the
              specified value.</para>

              <example>
                <title>Literal Constraint with Collections</title>

                <programlisting>CheeseCounter( cheeses not contains "cheddar" ) // not contains with a String literal
CheeseCounter( cheeses not contains $var ) // not contains with a variable</programlisting>
              </example>

              <blockquote>
                <para><emphasis role="bold">Note: </emphasis>for backward
                  compatibility, the <emphasis role="bold">excludes</emphasis>
                  operator is supported as a synonym for <emphasis role="bold">not
                  contains</emphasis>.</para>
              </blockquote>
            </simplesect>

            <simplesect>
              <title>memberOf</title>

              <para>The operator <code>memberOf</code> is used to check whether a field is a
              member of a collection or array; that collection must be a variable.</para>

              <example>
                <title>Literal Constraint with Collections</title>

                <programlisting>CheeseCounter( cheese memberOf $matureCheeses )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>not memberOf</title>

              <para>The operator <code>not memberOf</code> is used to check whether a
              field is not a
              member of a collection or array; that collection must be a variable.</para>

              <example>
                <title>Literal Constraint with Collections</title>

                <programlisting>CheeseCounter( cheese not memberOf $matureCheeses )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>soundslike</title>

              <para>This operator is similar to <code>matches</code>, but it checks
              whether a word has almost the same sound (using English pronounciation)
              as the given value. This is based on the Soundex algorithm
              (see <code>http://en.wikipedia.org/wiki/Soundex</code>).</para>

              <example>
                <title>Test with soundslike</title>

                <programlisting>// match cheese "fubar" or "foobar"
Cheese( name soundslike 'foobar' )</programlisting>
              </example>
            </simplesect>
          </section>

          <section>
            <title>Literal Restrictions</title>

            <para>Literal restrictions are the simplest form of restrictions
            and evaluate a field against a specified literal, which may be
            numeric or a date, a string or a boolean.</para>

            <figure>
              <title>literalRestriction</title>

              <mediaobject>
                <imageobject>
			<imagedata align="center" fileref="images/Chapter-Rule_Language/literalRestriction.png"
                             format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <para>Literal Restrictions using the operator '==' provide for
            faster execution as we can index using hashing to improve performance.</para>

            <simplesect>
              <title>Numeric</title>

              <para>All standard Java numeric primitives are supported.</para>

              <example>
                <title>Numeric Literal Restriction</title>

                <programlisting>Cheese( quantity == 5 )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>Date</title>

              <para>The date format "dd-mmm-yyyy" is supported by default. You
              can customize this by providing an alternative date format mask
              as the System property named "drools.dateformat". If more control
              is required, use the inline-eval constraint.</para>

              <example>
                <title>Date Literal Restriction</title>

                <programlisting>Cheese( bestBefore &lt; "27-Oct-2009" )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>String</title>

              <para>Any valid Java String is allowed.</para>

              <example>
                <title>String Literal Restriction</title>

                <programlisting>Cheese( type == "stilton" )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>Boolean</title>

              <para>Only <code>true</code> or <code>false</code> can be used; 0 and 1 are not
              acceptable. A boolean field alone (as in <code>Cheese( smelly )</code> is
              not permitted; you must compare this to a boolean literal.</para>

              <example>
                <title>Boolean Literal Restriction</title>

                <programlisting>Cheese( smelly == true )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>Qualified Identifier</title>

              <para>Enums can be used as well, both JDK 1.4 and 5 style
              enums are supported. For the latter you must be executing on a
              JDK 5 environment.</para>

              <example>
                <title>Boolean Literal Restriction</title>

                <programlisting>Cheese( smelly == SomeClass.TRUE )</programlisting>
              </example>
            </simplesect>
          </section>

          <section>
            <title>Bound Variable Restriction</title>

            <figure>
              <title>variableRestriction</title>

              <mediaobject>

                <imageobject>
			<imagedata align="center" fileref="images/Chapter-Rule_Language/variableRestriction.png"
                             format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <para>Variables can be bound to facts and their fields and then
            used in subsequent Field Constraints. A bound variable is called a
            <indexterm>
                <primary>declaration</primary>
              </indexterm>Declaration. Valid operators are determined by the
            type of the field being constrained; coercion will be attempted
            where possible. Bound Variable Restrictions using the operator '=='
            provide for very fast execution as we can use hashing to
            improve performance.</para>

            <example>
              <title>Bound Field using the operator '=='</title>

              <programlisting>Person( likes : favouriteCheese )
Cheese( type == likes )</programlisting>
            </example>

              <para>Here, <code>likes</code> is the variable that is bound in
              its declaration to the field <code>favouriteCheese</code> of any
              matching Person instance. It is then used to constrain the type of 
              Cheese in the following pattern. Any valid Java variable name can 
              be used, and it may be prefixed with a '$', which you will often
              see used to help differentiate declarations from fields. The example
              below shows a declaration for <code>$stilton</code>, bound to the
              object matching the first pattern and used with a <code>contains</code>
              operator. - Note the optional use of '$'.</para>

            <example>
              <title>Bound Fact using 'contains' operator</title>

              <programlisting>$stilton : Cheese( type == "stilton" )
Cheesery( cheeses contains $stilton )</programlisting>
            </example>
          </section>

          <section>
            <title>Return Value Restriction</title>

            <figure>
              <title>returnValueRestriction</title>

              <mediaobject>
                <imageobject>
                  <imagedata align="center"
			     fileref="images/Chapter-Rule_Language/returnValueRestriction.png" format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <para>A <indexterm>
                <primary>Return Value</primary>
              </indexterm>Return Value restriction is a parenthesized expression
            composed from literals, any valid Java primitive or object, previously
            bound variables, function calls, and operators. Functions used in a
            Return Value must return results that do not depend on time.</para>

            <example>
              <title>Return Value Restriction</title>

              <programlisting>Person( girlAge : age, sex == "F" )
Person( age == ( girlAge + 2) ), sex == 'M' )
</programlisting>
            </example>
          </section>
        </section>

        <section>
          <title>Compound Value Restriction</title>

          <para>The compound value restriction is used where there is more
          than one possible value to match. Currently only the "in" and "not in"
          evaluators support this. The second operand of this operator must be
          a comma-separated list of values, enclosed in parentheses. Values may
          be given as variables, literals, return values or qualified identifiers.
          Both evaluators are actually "syntactic sugar", internally rewritten as
          a list of multiple restrictions using the operators '!=' and '=='.</para>

          <figure>
            <title>compoundValueRestriction</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center"
			   fileref="images/Chapter-Rule_Language/compoundValueRestriction.png" format="PNG"
                           role="" />
              </imageobject>
            </mediaobject>
          </figure>

          <para></para>

          <example>
            <title>Compound Restriction using "in"</title>

            <programlisting>Person( $cheese : favouriteCheese )
Cheese( type in ( "stilton", "cheddar", $cheese )
</programlisting>
          </example>
        </section>

        <section>
          <title>Multi Restriction</title>

          <para>Multi restriction allows you to place more than one
          restriction on a field using the restriction connectives
          '&amp;&amp;' or '||'. Grouping via parentheses is permitted,
          resulting in a recursive syntax pattern.</para>

          <figure>
            <title>multiRestriction</title>

            <mediaobject>
              <imageobject>
		      <imagedata align="center" fileref="images/Chapter-Rule_Language/multiRestriction.png"
                           format="PNG" role="" />
              </imageobject>
            </mediaobject>
          </figure>

          <figure>
            <title>restrictionGroup</title>

            <mediaobject>
              <imageobject>
		      <imagedata align="center" fileref="images/Chapter-Rule_Language/restrictionGroup.png"
                           format="PNG" role="" />
              </imageobject>
            </mediaobject>
          </figure>

          <para></para>

          <example>
            <title>Multi Restriction</title>

            <programlisting>// Simple multi restriction using a single &amp;&amp;
Person( age &gt; 30 &amp;&amp; &lt; 40 )
// Complex multi restriction using groupings of multi restrictions
Person( age ( (&gt; 30 &amp;&amp; &lt; 40) ||
              (&gt; 20 &amp;&amp; &lt; 25) ) )
// Mixing muti restrictions with constraint connectives
Person( age &gt; 30 &amp;&amp; &lt; 40 || location == "london" )</programlisting>
          </example>
        </section>
      </section>

      <section>
        <title>Inline Eval Constraints</title>

        <figure>
          <title>Inline Eval Expression</title>

          <mediaobject>
            <imageobject>
		    <imagedata align="center" fileref="images/Chapter-Rule_Language/inlineEvalConstraint.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>An <indexterm>
            <primary>Predicate</primary>
          </indexterm>inline eval constraint can use any valid dialect
        expression as long as it results to a primitive boolean. The expression
        must be constant over time. Any previously bound variable, from the current
        or previous pattern, can be used; autovivification is also used to
        auto-create field binding variables. When an identifier is found that
        is not a current variable, the builder looks to see if the identifier
        is a field on the current object type, if it is, the field binding
	is auto-created as a variable of the same name. This is called
	autovivification of field variables inside of inline evals.</para>

        <para>This example will find all male-female pairs where the
        male is 2 years older than the female; the variable <code>age</code>
        is auto-created in the second pattern by the autovivification process.</para>

        <example>
          <title>Return Value operator</title>

          <programlisting>Person( girlAge : age, sex = "F" )
Person( eval( age == girlAge + 2 ), sex = 'M' )
</programlisting>
        </example>
      </section>

      <section>
        <title>Nested Accessors</title>

        <para>Drools permits <emphasis>nested accessors</emphasis> in in the field
        constraints using the MVEL accessor graph notation. Field constraints
        involving nested accessors are actually re-written as an MVEL dialect
        inline-eval. Care should be taken when using nested accessors as the
        Working Memory is not aware of any of the nested values, and does not
        know when they change; they should be considered immutable while any
        of their parent references are inserted into the Working Memory. If
        you wish to modify a nested value you should remove the parent objects
        first and re-assert afterwards. If you only have a single parent at
        the root of the graph, when in the MVEL dialect, you can use the
        "modify" construct and its block setters to write the nested accessor
        assignments while retracting and inserting the the root parent object
        as required. Nested accessors can be used on either side of the operator
        symbol.</para>

        <example>
          <title>Nested Accessors</title>

          <programlisting>// Find a pet older than its owners first-born child
$p : Person( ) 
Pet( owner == $p, age &gt; $p.children[0].age )</programlisting>

          <para>This is internally rewriten as an MVEL inline eval:</para>

          <programlisting>// Find a pet older than its owners first-born child
$p : Person( ) 
Pet( owner == $p, eval( age &gt; $p.children[0].age ) ) </programlisting>
        </example>

        <remark><emphasis role="bold">Note: </emphasis>Nested accessors have a much
        greater performance cost than direct field accesses, so use them carefully.</remark>
      </section>
    </section>

    <section>
      <title>Conditional Element "and"</title>

      <para>The Conditional Element "and" is used to group other Conditional
      Elements into a logical conjunction. The root element of the LHS is an
      implicit prefix "and" and doesn't need to be specified. Drools supports
      both prefix "and" and infix "and", but prefix is the preferred option
      as its implicit grouping avoids confusion.</para>

      <figure>
        <title>prefixAnd</title>

        <mediaobject>
          <imageobject>
		  <imagedata align="center" fileref="images/Chapter-Rule_Language/prefixAnd.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <example>
        <title>prefixAnd</title>

        <programlisting>(and Cheese( cheeseType : type )
     Person( favouriteCheese == cheeseType ) )
</programlisting>
      </example>

      <example>
        <title>implicit root prefixAnd</title>

        <programlisting>when
     Cheese( cheeseType : type )
     Person( favouriteCheese == cheeseType )</programlisting>
      </example>

      <para>Infix "and" is supported along with explicit grouping with
      parentheses, should it be needed. The symbol '&amp;&amp;', as an
      alternative to "and", is deprecated although it is still supported in
      the syntax for legacy support reasons.</para>

      <figure>
        <title>infixAnd</title>

        <mediaobject>
          <imageobject>
		  <imagedata align="center" fileref="images/Chapter-Rule_Language/infixAnd.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <example>
        <title>infixAnd</title>

        <programlisting>//infixAnd
Cheese( cheeseType : type ) and Person( favouriteCheese == cheeseType )
//infixAnd with grouping
( Cheese( cheeseType : type ) and
  ( Person( favouriteCheese == cheeseType ) or 
    Person( favouriteCheese == cheeseType ) )</programlisting>
      </example>
    </section>

    <section>
      <title>Conditional Element "or"</title>

      <para>The Conditional Element "or" is used to group other Conditional
      Elements into a logical disjunction. Drools supports both prefix "or" and
      infix "or", but prefix is the preferred option as its implicit grouping
      avoids confusion. The behavior of the Conditional Element "or" is different
      from the connective '||' for constraints and restrictions in field
      constraints. The engine actually has no understanding of the Conditional
      Element "or"; instead, via a number of different logic transformations,
      a rule with "or" is rewritten as a number of subrules. This process ultimately
      results in a rule that has a single "or" as the root node and one subrule
      for each of its CEs. Each subrule can activate and fire like any normal rule;
      there is no special behavior or interaction between these subrules. - This can
      be most confusing to new rule authors.</para>

      <figure>
        <title>prefixOr</title>

        <mediaobject>
          <imageobject>
		  <imagedata align="center" fileref="images/Chapter-Rule_Language/prefixOr.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <example>
        <title>prefixOr</title>

        <programlisting>(or Person( sex == "f", age &gt; 60 )
    Person( sex == "m", age &gt; 65 )
</programlisting>
      </example>

      <para>Infix "or" is supported along with explicit grouping with
      parentheses, should it be needed. The symbol '||', as an alternative to
      "or", is deprecated although it is still supported in the syntax for
      legacy support reasons.</para>

      <figure>
        <title>infixOr</title>

        <mediaobject>
          <imageobject>
		  <imagedata align="center" fileref="images/Chapter-Rule_Language/infixOr.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <example>
        <title>infixOr</title>

        <programlisting>//infixOr
Cheese( cheeseType : type ) or Person( favouriteCheese == cheeseType )
//infixOr with grouping
( Cheese( cheeseType : type ) or
  ( Person( favouriteCheese == cheeseType ) and
    Person( favouriteCheese == cheeseType ) )</programlisting>
      </example>

      <para>The Conditional Element "or" also allows for optional pattern
      binding. This means that each resulting subrule will bind its pattern to
      the pattern binding. Each pattern must be bound separately,
      using eponymous variables:</para>

      <example>
        <title>or with binding</title>

        <programlisting>(or pensioner : Person( sex == "f", age &gt; 60 ) 
    pensioner : Person( sex == "m", age &gt; 65 ) )</programlisting>
      </example>

      <para>Since the conditional element "or" results in multiple subrule
      generation, one for each possible logically outcome, the example above
      would result in the internal generation of two rules. These two rules
      work independently within the Working Memory, which means both can
      match, activate and fire - there is no shortcutting.</para>

      <para>The best way to think of the conditional element "or" is as a
      shortcut for generating two or more similar rules. When you think
      of it that
      way, it's clear that for a single rule there could be multiple
      activations if two or more terms of the disjunction are true.</para>
    </section>

    <section>
      <title>Conditional Element "eval"</title>

      <figure>
        <title>eval</title>

        <mediaobject>
          <imageobject>
		  <imagedata align="center" fileref="images/Chapter-Rule_Language/eval.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The CE "eval" is essentially a catch-all which allows any semantic code
      (that returns a primitive boolean) to be executed. This code can refer to
      variables that were bound in the LHS of the rule, and functions in the
      rule package. Overuse of eval reduces the declarativeness of your rules
      and can result in a poorly performing engine. While "eval" can be used
      anywhere in the patterns, the best practice is to add it as the last
      conditional element in the LHS of a rule.</para>

      <para>Evals cannot be indexed and thus are not as efficient as  Field
      Constraints. However this makes them ideal for being used when functions
      return values that change over time, which is not allowed within Field
      Constraints.</para>

      <para>For folks who are familiar with Drools 2.x lineage, the old Drools
      parameter and condition tags are equivalent to binding a variable to an
      appropriate type, and then using it in an eval node.</para>

      <example>
        <title>eval</title>

        <programlisting>p1 : Parameter() 
p2 : Parameter()
eval( p1.getList().containsKey(p2.getItem()) )
// call function isValid in the LHS
eval( isValid(p1, p2) )</programlisting>
      </example>
    </section>

    <section>
      <title>Conditional Element "not"</title>

      <figure>
        <title>not</title>

        <mediaobject>

          <imageobject>
		  <imagedata align="center" fileref="images/Chapter-Rule_Language/not.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The CS "not" is first order logic's non-existential quantifier and checks
      for the non-existence of something in the Working Memory. Think of "not"
      as meaning "there must be none of...".</para>

      <para>The keyword "not" be followed by parentheses around the CEs
      that it applies to. In the simplest case of a single pattern (like
      below) you may optionally omit the parentheses.</para>

      <example>
        <title>No Busses</title>

        <programlisting>not Bus()</programlisting>
      </example>

      <example>
        <title>No red Busses</title>

        <programlisting>// Brackets are optional:
not Bus(color == "red")
// Brackets are optional:
not ( Bus(color == "red", number == 42) )
// "not" with nested infix "and" - two patterns,
// brackets are requires:
not ( Bus(color == "red") and
      Bus(color == "blue") )</programlisting>
      </example>
    </section>

    <section>
      <title>Conditional Element "exists"</title>

      <figure>
        <title>exists</title>

        <mediaobject>

          <imageobject>
		  <imagedata align="center" fileref="images/Chapter-Rule_Language/exists.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The CE "exists" is first order logic's existential quantifier and checks
      for the existence of something in the Working Memory. Think of "exists" as
      meaning "there is at least one..". It is different from just having the pattern
      on its own, which is more like saying "for each one of...". If you use
      "exists" with a pattern, the rule will only activate at most once, regardless
      of how much data there is in working memory that matches the
      condition inside of the "exists". Since only the existence matters, no bindings
      will be established.</para>

      <para>The keyword "exists" must be followed by parentheses around the
      CEs that it applies to. In the simplest case of a single pattern (like
      below) you may optionally omit the parentheses.</para>

      <example>
        <title>At least one Bus</title>

        <programlisting>exists Bus()</programlisting>
      </example>

      <example>
        <title>At least one red Bus</title>

        <programlisting>exists Bus(color == "red")
// brackets are optional:
exists ( Bus(color == "red", number == 42) )
// "exists" with nested infix "and",
// brackets are required:
exists ( Bus(color == "red") and
         Bus(color == "blue") )</programlisting>
      </example>
    </section>

    <section>
      <title>Conditional Element "forall"</title>

      <figure>
        <title>forall</title>

        <mediaobject>

          <imageobject>
		  <imagedata align="center" fileref="images/Chapter-Rule_Language/forall.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The Conditional Element "forall" completes the First Order Logic
      support in Drools. The Conditional Element "forall" evaluates to true
      when all facts that match the first pattern match all the remaining
      patterns. Example:</para>

      <programlisting>rule "All English buses are red"
when
    forall( $bus : Bus( type == 'english') 
                   Bus( this == $bus, color = 'red' ) )
then
    # all english buses are red
end
</programlisting>

      <para>In the above rule, we "select" all Bus objects whose type is
      "english". Then, for each fact that matches this pattern we evaluate the
      following patterns and if they match, the forall CE will evaluate to
      true.</para>

      <para>To state that all facts of a given type in the working memory must
      match a set of constraints, "forall" can be written with a single pattern
      for simplicity. Example:</para>

      <para><example>
          <title>Single Pattern Forall</title>

          <programlisting>rule "All Buses are Red"
when
    forall( Bus( color == 'red' ) )
then
    # all asserted Bus facts are red
end
</programlisting>
        </example></para>

      <para>Another example shows multiple patterns inside the "forall":<example>
          <title>Multi-Pattern Forall</title>

          <programlisting>rule "all employees have health and dental care programs"
when
    forall( $emp : Employee()
            HealthCare( employee == $emp )
            DentalCare( employee == $emp )
          )
then
    # all employees have health and dental care
end
</programlisting>
        </example></para>

      <para>Forall can be nested inside other CEs for complete expressiveness.
      For instance, "forall" can be used inside a "not" CE. Note that only single
      patterns have optional parentheses, so that with a nested forall parentheses
      must be used :<example>
          <title>Combining Forall with Not CE</title>

          <programlisting>rule "not all employees have health and dental care"
when 
    not ( forall( $emp : Employee()
                  HealthCare( employee == $emp )
                  DentalCare( employee == $emp ) ) 
        )
then
    # not all employees have health and dental care
end
</programlisting>
        </example></para>

      <para>As a side note, <code>not( forall( p1 p2 p3...))</code> is
	equivalent to writing:</para>

      <programlisting>not(p1 and not(and p2 p3...))</programlisting>

      <para>Also, it is important to note that "forall" is a <emphasis>scope
      delimiter</emphasis>. Therefore, it can use any previously bound
      variable, but no variable bound inside it will be available for use
      outside of it.</para>
    </section>

    <section>
      <title>Conditional Element "from"</title>

      <figure>
        <title>from</title>

        <mediaobject>
          <imageobject>
		  <imagedata align="center" fileref="images/Chapter-Rule_Language/from.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The Conditional Element "from" enables users to specify an arbitrary
      source for data to be matched by LHS patterns. This
      allows the engine to reason over data not in the Working Memory. The data
      source could be a sub-field on a bound variable or the results of a method
      call. It is a powerful construction that allows out of the box
      integration with other application components and frameworks. One common
      example is the integration with data retrieved on-demand from databases
      using hibernate named queries.</para>

      <para>The expression used to define the object source is any expression
      that follows regular MVEL syntax. Therefore, it allows you to easily use
      object property navigation, execute method calls and access maps and
      collections elements.</para>

      <para>Here is a simple example of reasoning and binding on another
      pattern sub-field:</para>

      <para><programlisting>rule "validate zipcode"
when
    Person( $personAddress : address ) 
    Address( zipcode == "23920W") from $personAddress 
then
    # zip code is ok
end
</programlisting></para>

      <para>With all the flexibility from the new expressiveness in the Drools
      engine you can slice and dice this problem many ways. This is the same
      but shows how you can use a graph notation with the 'from':</para>

      <para><programlisting>rule "validate zipcode"
when
    $p : Person( ) 
    $a : Address( zipcode == "23920W") from $p.address 
then
    # zip code is ok
end
</programlisting></para>

      <para>Previous examples were evaluations using a single pattern. The
      CE "from" also support object sources that return a collection of objects.
      In that case, "from" will iterate  over all objects in the
      collection and try to match each of them individually. For instance, if
      we want a rule that applies 10% discount to each item in an order, we
      could do:</para>

      <programlisting>rule "apply 10% discount to all items over US$ 100,00 in an order"
when
    $order : Order()
    $item  : OrderItem( value &gt; 100 ) from $order.items
then
    # apply discount to $item
end
</programlisting>

      <para>The above example will cause the rule to fire once for each item
      whose value is greater than 100 for each given order.</para>

      <para>You must take caution, however, when using "from", 
      especially in conjunction with the
      <emphasis role="bold">lock-on-active</emphasis> rule attribute 
      as it may produce unexpected results. Consider the example provided earlier, but
      now slightly modified as follows:</para>
      
      <para><programlisting>rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person( ) 
    $a : Address( state == "NC") from $p.address 
then
    modify ($p) {} #Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person( ) 
    $a : Address( city == "Raleigh") from $p.address 
then
    modify ($p) {} #Apply discount to person in a modify block
end
</programlisting></para>

	  <para>
	  In the above example, persons in Raleigh, NC should be assigned to sales region 1 and 
	  receive a discount; i.e., you would expect both rules to activate and fire. Instead you
	  will find that only the second rule fires.</para>
	  
	  <para>If you were to turn on the audit log, you would also see that when the second rule fires,
	  it deactivates the first rule. Since the rule attribute <emphasis role="bold">lock-on-active</emphasis>
	  prevents a rule from creating new activations when a set of facts change, the first rule fails to
	  reactivate. Though the set of facts have not changed, the use of
	  "from" returns a new fact for all intents and purposes each time
	  it is evaluated. 
	  </para>
	  
	  <para>First, it's important to review why you would use the above pattern. You may have
	  many rules across different rule-flow groups. When rules modify working memory and other rules
	  downstream of your RuleFlow (in different rule-flow groups) need to be reevaluated, the use of <emphasis role="bold">modify</emphasis>
	  is critical. You don't, however, want other rules in the same rule-flow group to place
	  activations on one another recursively. In this case, the <emphasis role="bold">no-loop</emphasis>
	  attribute is ineffective, as it would only prevent a rule from activating itself recursively. Hence,
	  you resort to <emphasis role="bold">lock-on-active</emphasis>.
	  </para>
	  
	  <para>
	  There are several ways to address this issue:</para>

      <itemizedlist>
        <listitem>
          <para>Avoid the use of "from" when you can assert all facts into working memory 
          or use nested object references in your constraint expressions (shown below).</para>
        </listitem>
        <listitem>
          <para>Place the variable assigned used in the modify block as the last sentence
          in your condition (LHS).</para>
        </listitem>
        <listitem>
          <para>Avoid the use of <emphasis role="bold">lock-on-active</emphasis> when you
          can explicitly manage how rules within the same rule-flow group place
          activations on one another (explained below).</para>
        </listitem>
      </itemizedlist>

	<para>The preferred solution is to minimize use of "from" when you can assert
        all your facts into working memory directly. In the example above, both the 
        Person and Address instance can be asserted into working memory. In this case,
        because the graph is fairly simple, an even easier solution is to modify your
        rules as follows:</para>

      <para><programlisting>rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person(address.state == "NC" )  
then
    modify ($p) {} #Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person(address.city == "Raleigh" )  
then
    modify ($p) {} #Apply discount to person in a modify block
end
</programlisting></para>

	  <para>Now, you will find that both rules fire as expected. However, it is not 
	  always possible to access nested facts as above. Consider an example where a Person
	  holds one or more Addresses and you wish to use an existential quantifier to
	  match people with at least one address that meets certain conditions. 
	  In this case, you would have to resort to 
	  the use of "from" to reason over the collection.</para>
	  
	  <para>
	  There are several ways to use "from" to achieve this and not all of them
          exhibit an issue with the use of <emphasis role="bold">lock-on-active</emphasis>.
          For example, the following use of "from" causes both rules to fire as
          expected:</para>
	  
	  <para><programlisting>rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person($addresses : addresses)
    exists (Address(state == "NC") from $addresses)  
then
    modify ($p) {} #Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person($addresses : addresses)
    exists (Address(city == "Raleigh") from $addresses)  
then
    modify ($p) {} #Apply discount to person in a modify block
end
</programlisting></para>
	
	  <para>However, the following slightly different approach does exhibit the problem:</para>
	  
	  <para><programlisting>rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $assessment : Assessment()
    $p : Person()
    $addresses : List() from $p.addresses
    exists (Address( state == "NC") from $addresses) 
then
    modify ($assessment) {} #Modify assessment in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $assessment : Assessment()
    $p : Person()
    $addresses : List() from $p.addresses 
    exists (Address( city == "Raleigh") from $addresses)
then
    modify ($assessment) {} #Modify assessment in a modify block
end</programlisting></para>
	  
	  <para>In the above example, the $addresses variable is returned from the
	  use of <emphasis role="bold">from</emphasis>. The example also introduces
	  a new object, assessment, to highlight one possible solution in this case.
	  If the $assessment variable assigned in the condition (LHS) is moved to the last condition
	  in each rule, both rules fire as expected.
	  </para>
	  
	  <para>
	  Though the above examples demonstrate how to combine the use of "from"
	  with <emphasis role="bold">lock-on-active</emphasis> where no loss of 
          rule activations occurs, they carry the drawback of placing a dependency
          on the order of conditions on the LHS. In addition, the solutions present
          greater complexity for the rule author in terms of keeping track of
	  which conditions may create issues.</para>
	  
	  <para>A better alternative is to 
	  assert more facts into working memory. In this case, a person's addresses
	  may be asserted into working memory and the use of "from"
	  would not be necessary.</para>
	  
	  <para>There are cases, however, where asserting all data into working memory is not
	  practical and we need to find other solutions. Another option is to reevaluate the
	  need for <emphasis role="bold">lock-on-active</emphasis>. 
	  An alternative to <emphasis role="bold">lock-on-active</emphasis> is to 
	  directly manage how rules within the same rule-flow group activate one another
	  by including conditions in each rule that prevent rules from activating
          each other recursively when working memory is modified. For example, in the 
          case above where a discount is applied to citizens of Raleigh, a condition may
          be added to the rule that checks whether the discount has already been applied.
          If so, the rule does not activate.</para>
	  	    
    </section>

    <section>
      <title>Conditional Element "collect"</title>

      <figure>
        <title>collect</title>

        <mediaobject>

          <imageobject>
		  <imagedata align="center" fileref="images/Chapter-Rule_Language/collect.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The Conditional Element "collect" allows rules to reason over a collection
      of objects obtained from the given source or from the working memory. In First 
      Oder Logic terms this is the cardinality quantifier. A simple example:</para>

      <programlisting>import java.util.ArrayList

rule "Raise priority if system has more than 3 pending alarms"
when
    $system : System()
    $alarms : ArrayList( size &gt;= 3 )
              from collect( Alarm( system == $system, status == 'pending' ) )
then
    # Raise priority, because system $system has
    # 3 or more alarms pending. The pending alarms
    # are $alarms.
end
</programlisting>

      <para>In the above example, the rule will look for all pending alarms in
      the working memory for each given system and group them in ArrayLists.
      If 3 or more alarms are found for a given system, the rule will
      fire.</para>

      <para>The result pattern of "collect" can
      be any concrete class that implements the <code>java.util.Collection</code>
      interface
      and provides a default no-arg public constructor. This means that you can use
      Java collections like ArrayList, LinkedList, HashSet, etc., or
      your own class, as long as it implements the <code>java.util.Collection</code>
      interface and provide a default no-arg public constructor.</para>

      <para>Both source and result patterns can be constrained as any other
      pattern.</para>

      <para>Variables bound before the "collect" CE are in the scope of both source and
      result patterns and therefore you can use them to constrain both your
      source and result patterns. But note that "collect" is a scope delimiter for
      bindings, so that any binding made inside of it is not available for use
      outside of it.</para>

      <para>Collect accepts nested "from" CEs. The following example is a valid
      use of "collect":</para>

      <programlisting>import java.util.LinkedList;

rule "Send a message to all mothers"
when
    $town : Town( name == 'Paris' )
    $mothers : LinkedList() 
               from collect( Person( gender == 'F', children &gt; 0 ) 
                             from $town.getPeople() 
                           )
then
    # send a message to all mothers
end
</programlisting>
    </section>

    <section>
      <title>Conditional Element "accumulate"</title>

      <figure>
        <title>accumulate</title>

        <mediaobject>
          <imageobject>
		  <imagedata align="center" fileref="images/Chapter-Rule_Language/accumulate.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The Conditional Element "accumulate" is a more flexible and powerful
      form of "collect", the sense that it can be used to do what "collect" does
      and also achieve things that the CE "collect" is not capable of doing.
      Basically, what it does is that it allows a rule to iterate
      over a collection of objects, executing custom actions for each of the
      elements, and at the end it returns a result object.</para>

      <para>The general syntax of the <emphasis
      role="bold">accumulate</emphasis> CE is:</para>

      <programlisting><replaceable>&lt;result pattern&gt;</replaceable> from accumulate( <replaceable>&lt;source pattern&gt;</replaceable>,
                                  init( <replaceable>&lt;init code&gt;</replaceable> ),
                                  action( <replaceable>&lt;action code&gt;</replaceable> ),
                                  reverse( <replaceable>&lt;reverse code&gt;</replaceable> ),
                                  result( <replaceable>&lt;result expression&gt;</replaceable> ) )
</programlisting>

      <para>The meaning of each of the elements is the following:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">&lt;source pattern&gt;</emphasis>: the
          source pattern is a regular pattern that the engine will try to
          match against each of the source objects.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">&lt;init code&gt;</emphasis>: this is a
          semantic block of code in the selected dialect that will be executed
          once for each tuple, before iterating over the source
          objects.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">&lt;action code&gt;</emphasis>: this is
          a semantic block of code in the selected dialect that will be
          executed for each of the source objects.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">&lt;reverse code&gt;</emphasis>: this is
          an optional semantic block of code in the selected dialect that if
          present will be executed for each source object that no longer
          matches the source pattern. The objective of this code block is to
          "undo" any calculation done in the &lt;action code&gt; block, so
          that the engine can do decremental calculation when a source object
          is modified or retracted, hugely improving performance of these
          operations.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">&lt;result expression&gt;</emphasis>:
          this is a semantic expression in the selected dialect that is
          executed after all source objects are iterated.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">&lt;result pattern&gt;</emphasis>: this
          is a regular pattern that the engine tries to match against the
          object returned from the &lt;result expression&gt;. If it matches,
          the "accumulate" conditional element
          evaluates to <emphasis>true</emphasis> and the engine
          proceeds with the evaluation of the next CE in the rule. If it does
          not matches, the "accumulate" CE
          evaluates to <emphasis>false</emphasis> and the engine
          stops evaluating CEs for that rule.</para>
        </listitem>
      </itemizedlist>

      <para>It is easier to understand if we look at an example:</para>

      <programlisting>rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              init( double total = 0; ),
                              action( total += $value; ),
                              reverse( total -= $value; ),
                              result( total ) )
then
    # apply discount to $order
end
</programlisting>

      <para>In the above example, for each Order() in the working memory, the
      engine will execute the <emphasis role="bold">init code</emphasis>
      initializing the total variable to zero. Then it will iterate over all
      OrderItem() objects for that order, executing the <emphasis
      role="bold">action</emphasis> for each one (in the example, it will sum
      the value of all items into the total variable). After iterating over
      all OrderItem, it will return the value corresponding to the <emphasis
      role="bold">result expression</emphasis> (in the above example, the
      value of the total variable). Finally, the engine will try to match the
      result with the Number() pattern and if the double value is greater than
      100, the rule will fire.</para>

      <para>The example used Java as the semantic dialect, and as such, note
      that the usage of ';' is mandatory in the init, action and reverse code
      blocks. The result is an expression and as such, it does not admit ';'.
      If the user uses any other dialect, he must comply to that dialect
      specific syntax.</para>

      <para>As mentioned before, the <emphasis role="bold">reverse
      code</emphasis> is optional, but it is strongly recommended that the
      user writes it in order to benefit from the <emphasis>improved
      performance on update and retracts</emphasis>.</para>

      <para>The "accumulate" CE can be used to
      execute any action on source objects. The following example instantiates
      and populates a custom object:</para>

      <programlisting>rule "Accumulate using custom objects"
when
    $person   : Person( $likes : likes )
    $cheesery : Cheesery( totalAmount &gt; 100 )
                from accumulate( $cheese : Cheese( type == $likes ),
                                 init( Cheesery cheesery = new Cheesery(); ),
                                 action( cheesery.addCheese( $cheese ); ),
                                 reverse( cheesery.removeCheese( $cheese ); ),
                                 result( cheesery ) );
then
    // do something
end</programlisting>

      <section>
        <title>Accumulate Functions</title>

        <para>The accumulate CE is a very powerful CE, but it gets real
        declarative and easy to use when using predefined functions that are
        known as Accumulate Functions. They work exactly like accumulate, but
        instead of explicitly writing custom code in every accumulate CE, the
        user can use predefined code for common operations.</para>

        <para>For instance, the rule to apply discount on orders written in
        the previous section, could be written in the following way, using
        Accumulate Functions:</para>

        <programlisting>rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              sum( $value ) )
then
    # apply discount to $order
end
</programlisting>

        <para>In the above example, sum is an Accumulate Function and will sum
        the $value of all OrderItems and return the result.</para>

        <para>Drools ships with the following built-in accumulate
        functions:</para>

        <itemizedlist>
          <listitem>
            <para>average</para>
          </listitem>

          <listitem>
            <para>min</para>
          </listitem>

          <listitem>
            <para>max</para>
          </listitem>

          <listitem>
            <para>count</para>
          </listitem>

          <listitem>
            <para>sum</para>
          </listitem>
        </itemizedlist>

        <para>These common functions accept any expression as input. For
        instance, if someone wants to calculate the average profit on all
        items of an order, a rule could be written using the average
        function:</para>

        <programlisting>rule "Average profit"
when
    $order : Order()
    $profit : Number() 
              from accumulate( OrderItem( order == $order, $cost : cost, $price : price )
                               average( 1 - $cost / $price ) )
then
    # average profit for $order is $profit
end
</programlisting>

        <para>Accumulate Functions are all pluggable. That means that if
        needed, custom, domain specific functions can easily be added to the
        engine and rules can start to use them without any restrictions. To
        implement a new Accumulate Functions all one needs to do is to create
        a Java class that implements the
        <code>org.drools.base.acumulators.AccumulateFunction</code> interface and add a
        line to the configuration file or set a system property to let the
        engine know about the new function. As an example of an Accumulate
        Function implementation, the following is the implementation of the
        "average" function:</para>

        <programlisting>/*
 * Copyright 2007 JBoss Inc
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created on Jun 21, 2007
 */
package org.drools.base.accumulators;


/**
 * An implementation of an accumulator capable of calculating average values
 * 
 * @author etirelli
 *
 */
public class AverageAccumulateFunction implements AccumulateFunction {

    protected static class AverageData {
        public int    count = 0;
        public double total = 0;
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#createContext()
     */
    public Object createContext() {
        return new AverageData();
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#init(java.lang.Object)
     */
    public void init(Object context) throws Exception {
        AverageData data = (AverageData) context;
        data.count = 0;
        data.total = 0;
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#accumulate(java.lang.Object,
     * java.lang.Object)
     */
    public void accumulate(Object context,
                           Object value) {
        AverageData data = (AverageData) context;
        data.count++;
        data.total += ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#reverse(java.lang.Object,
     * java.lang.Object)
     */
    public void reverse(Object context,
                        Object value) throws Exception {
        AverageData data = (AverageData) context;
        data.count--;
        data.total -= ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#getResult(java.lang.Object)
     */
    public Object getResult(Object context) throws Exception {
        AverageData data = (AverageData) context;
        return new Double( data.count == 0 ? 0 : data.total / data.count );
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#supportsReverse()
     */
    public boolean supportsReverse() {
        return true;
    }

}
</programlisting>

        <para>The code for the function is very simple, as we could expect, as
        all the "dirty" integration work is done by the engine. Finally, to
        plug the function into the engine, we added it to the configuration
        file:</para>

        <programlisting>drools.accumulate.function.average =
   org.drools.base.accumulators.AverageAccumulateFunction
</programlisting>

        <para>Here, "drools.accumulate.function." is a prefix that must always
        be used, "average" is how the function will be used in the rule file,
        and "org.drools.base.accumulators.AverageAccumulateFunction" is the
        fully qualified name of the class that implements the function
        behavior.</para>
      </section>
    </section>
  </section>

  <section>
    <title>The Right Hand Side (then)</title>

    <para>The Right Hand Side (RHS) is a common name for the consequence or
    action part of the rule; this part should contain a list of actions to be
    executed. It is bad practice to use imperative or conditional code in the
    RHS of a rule; as a rule should be atomic in nature - "when this, then do
    this", not "when this, maybe do this". The RHS part of a rule should also
    be kept small, thus keeping it declarative and readable. If you find you
    need imperative and/or conditional code in the RHS, then maybe you should
    be breaking that rule down into multiple rules. The main purpose of the
    RHS is to insert, retractor modify working memory data. To assist with
    that there are a few convenience methods you can use to modify working
    memory; without having to first reference a working memory
    instance.</para>

    <para>"update(object, handle);" will tell the engine that an object has
    changed (one that has been bound to something on the LHS) and rules may
    need to be reconsidered.</para>
    
    <para>"update(object);"  can also be used, here the KnowledgeHelper will
    lookup the facthandle for you, via an identity check, for the passed object.</para>      

    <para>"insert(new Something());" will place a new object of your creation
    in working memory.</para>

    <para>"insertLogical(new Something());" is similar to insert, but the
    object will be automatically retracted when there are no more facts to
    support the truth of the currently firing rule.</para>

    <para>"retract(handle);" removes an object from working memory.</para>

    <para>These convenience methods are basically macros that provide short
    cuts to the KnowledgeHelper instance (refer to the KnowledgeHelper
    interface for more advanced operations). The KnowledgeHelper interface is
    made available to the RHS code block as a variable called "drools". If you
    provide "Property Change Listeners" to your Java beans that you are
    inserting into the engine, you can avoid the need to call "update" when
    the object changes.</para>
  </section>

  <section>
    <title>A Note on Auto-boxing and Primitive Types</title>

    <para>Drools attempts to preserve numbers in their primitive or object
    wrapper form, so a variable bound to an int primitive when used in a code
    block or expression will no longer need manual unboxing; unlike Drools 3.0
    where all primitives were autoboxed, requiring manual unboxing. A variable
    bound to an object wrapper will remain as an object; the existing JDK 1.5
    and JDK 5 rules to handle auto-boxing and unboxing apply in this case. When
    evaluating field constraints, the system attempts to coerce one of the
    values into a comparable format; so a primitive is comparable to an object
    wrapper.</para>
  </section>
</section>
