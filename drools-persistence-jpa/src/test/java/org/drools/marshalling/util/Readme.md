
Marshalling Test Framework Readme
=================================

This readme describes how the marshalling test framework.

The idea is that we take the tests that we already have, for testing rules and processes and all of that, and use their outputs to test the marshalling and unmarshalling mechanisms that Drools and jBPM persistence relies on.

*   [Status](#status)
*   [What is the marshalling test framework](#what)
*   [Using the framework](#using)
    *    [Changes that invalidate the framework's information](#changes)
*   [What actually happens and how it works](#how)
    *    [Saving snapshots](#snapshots)
    *    [The "base" database](#base)  
    *    [Comparing to previous marshalled data](#comparing)
*    [Conclusions about marshalling in Drools/jBPM](#comparing)

<h2 id="status>Status of marshalling test framework use</h2>

At present, this framework is not yet being used because of 
- JBRULES-3237 (which duplicates JBPM-3383) 

Once this bug is resolved (and it's confirmed that marshalled SessionInfo objects
can be unmarshalled in all cases), then this framework will be turned on. 

<h2 id="what">What is the marshalling test framework?</h2>

The basic idea for this test framework can best be summarized by the following
quote ("we" is Drools/jBPM): 

 > "we use a binary persistence format (using a byte[]) to transform a 
 >  process instance or the session state into a binary to put it in the 
 >  database. It is possible however that this binary serialization 
 >  algorithm might change over time (when new features are added etc.).
 ...
 > "we are gonna have to make sure that, if a user updates from one jBPM 
 >  version to a newer, that the old binary array can still be read in 
 > (or transformed)."
 > 
 > "The idea is that we should set up some infrastructure to keep track 
 >  of this. And when we do encounter issues, we can then see how we can 
 >  solve these. ... if we want to be able to detect issues, we should at 
 >  least have some binary session and process instance info objects for 
 >  each version (starting jBPM 5.1) so that we can run them against 
 >  future versions."

The easiest way (that I could think of) to implement this -- without affecting the actual implementation code -- turned out to be based on creating proxy classes for the EntityManager(Factory) and UserTransaction. In short, every time that marshalled data is persisted, we save a copy of the marshalled data to later comparison. 


<h2 id="using">Using the marshalling test framework</h2>

In order to use this framework, you need to do the 4 things described below. If you're not familiar with the inner workings of Drools/jBPM persistence, this might not make a lot of sense. Please make sure to see examples of actual code used, posted after the descriptions. 

1.   In order to use the marshalling test framework, it's necessary to convert your test to use JUnit 4 annotations (instead of extending the TestCase class).   
     *    This is primarily because we need to be able to run a method after all methods in the test have run, which is (AFAIK), only posisble using the @AfterClass annotation. If you're using TestNG or (whatever), the same applies -- make sure that you have a method that has an @AfterClass or equivalent method.    
2.   Modify the setup and tearDown (@After and @Before) methods in your jUnit test so that methods from the marshalling test framework are called. 
3.   In the test itself, you need to make sure that you use the objects created by the marshalling test framework in the actual test methods.    
     *   This usually involves declaring a global variable, filling it in your setup/@Before method and using it your test/@Test method. 
4.   Make sure to add an @AfterClass method that will compare the marshalled data generated by the test to the snapshots taken and stored in the base database(s). 

For example, look at the following test: 

 [TimerAndCalendarTest](https://github.com/droolsjbpm/drools/blob/b869611e377e9fc5e036c64c296eeaba75a5cd0e/drools-persistence-jpa/src/test/java/org/drools/timer/integrationtests/TimerAndCalendarTest.java)

The things we'll change in order to make the test work with the framework are the following: 

    public class TimerAndCalendarTest {
        private PoolingDataSource    ds1;
        private EntityManagerFactory emf;

and also [here](https://github.com/droolsjbpm/drools/blob/b869611e377e9fc5e036c64c296eeaba75a5cd0e/drools-persistence-jpa/src/test/java/org/drools/timer/integrationtests/TimerAndCalendarTest.java#L245) 

        @Before
        public void setUp() throws Exception {
            ds1 = new PoolingDataSource();
            ds1.setUniqueName( "jdbc/testDS1" );
            ds1.setClassName( "org.h2.jdbcx.JdbcDataSource" );
            ds1.setMaxPoolSize( 3 );
            ds1.setAllowLocalTransactions( true );
            ds1.getDriverProperties().put( "user",
                                           "sa" );
            ds1.getDriverProperties().put( "password",
                                           "sasa" );
            ds1.getDriverProperties().put( "URL",
                                           "jdbc:h2:mem:mydb" );
            ds1.init();
            emf = Persistence.createEntityManagerFactory( "org.drools.persistence.jpa" );
        }
    
        @After
        public void tearDown() throws Exception {
            try {
                emf.close();
                ds1.close();
            } catch ( Exception e ) {
                e.printStackTrace();
            }
        }
    
    
        private StatefulKnowledgeSession createSession(KnowledgeBase kbase) {
            final KnowledgeSessionConfiguration conf = KnowledgeBaseFactory.newKnowledgeSessionConfiguration();
            conf.setOption( ClockTypeOption.get( ClockType.PSEUDO_CLOCK.getId() ) );
            StatefulKnowledgeSession ksession = JPAKnowledgeService.newStatefulKnowledgeSession( kbase,
                                                                                                 conf,
                                                                                                 createEnvironment() );
    
            return ksession;
        }
    

and lastly, the following method will be removed.

       private Environment createEnvironment() {
           Environment env = KnowledgeBaseFactory.newEnvironment();
           env.set( EnvironmentName.ENTITY_MANAGER_FACTORY,
                    emf );
           // env.set(EnvironmentName.TRANSACTION_MANAGER,
           // TransactionManagerServices.getTransactionManager());
           env.set( EnvironmentName.GLOBALS,
                    new MapGlobalResolver() );
           return env;
       }


