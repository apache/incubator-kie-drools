@declare{'miningModelApplier'}
package @{packageName};

import java.util.Arrays;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.kie.api.KieBase;
import org.kie.api.pmml.*;
import org.kie.pmml.pmml_4_2.model.*;
import org.kie.pmml.pmml_4_2.model.mining.*;
import org.dmg.pmml.pmml_4_2.descr.*;
import org.kie.api.runtime.KieSession;
import org.kie.api.runtime.rule.DataSource;
import org.kie.api.runtime.rule.RuleUnit;
import org.kie.api.runtime.rule.RuleUnitExecutor;
import org.kie.api.event.rule.ObjectInsertedEvent;
import org.kie.api.event.rule.ObjectUpdatedEvent;
import org.kie.api.event.rule.ObjectDeletedEvent;
import org.kie.api.event.rule.RuleRuntimeEventListener;
import org.kie.api.event.rule.AfterMatchFiredEvent;
import org.kie.api.event.rule.AgendaEventListener;
import org.kie.api.event.rule.AgendaGroupPoppedEvent;
import org.kie.api.event.rule.AgendaGroupPushedEvent;
import org.kie.api.event.rule.BeforeMatchFiredEvent;
import org.kie.api.event.rule.MatchCancelledEvent;
import org.kie.api.event.rule.MatchCreatedEvent;
import org.kie.api.event.rule.RuleFlowGroupActivatedEvent;
import org.kie.api.event.rule.RuleFlowGroupDeactivatedEvent;
import org.drools.core.impl.InternalRuleUnitExecutor;
import org.drools.core.common.DefaultFactHandle;
import @{miningPojoClass};

public class @{className} implements MiningModelApplier {
   private static final String MODEL_NAME = "@{modelName}";
   private static final String EXECUTED_SEGMENTS_COUNT = "segmentsExecuted";
   private static final String segmentKeys[] = {
      @foreach{seg: segments}"@{seg.owner.segmentationId}_@{seg.segmentId}"@end{","}
   }; 
   private Map<String,SegmentExecution> segmentExecutions;
   private @{miningPojoClass} miningObject;
   private PMMLRuleUnit ruleUnit;
   private KieBase kbase;
   
   public @{className}() {
      // Empty constructor
   }
   
   public List<PMML4Result> applyModel(PMMLRequestData request, KieBase kbase, PMMLRuleUnit ruleUnit) {
      PMML4Result result = new PMML4Result(request.getCorrelationId());
      List<PMML4Result> results = null;
      this.segmentExecutions = new HashMap<>();
      this.ruleUnit = ruleUnit;
      this.kbase = kbase;
      miningObject = new @{miningPojoClass}(request);
      @foreach{seg: segments}
      this.segmentExecutions.put( "@{seg.owner.segmentationId}_@{seg.segmentId}",
                                  new SegmentExecution( request.getCorrelationId(),
                                  "@{seg.owner.segmentationId}",
                                  "@{seg.segmentId}",
                                  @{seg.segmentIndex},
                                  "@{seg.segmentRuleUnit}") );
                                                        
      @end{}
      
      @if{ modelMethod == "SELECT_FIRST" }
      result = processSelectFirst(result, request);
      @elseif{ modelMethod == "SELECT_ALL" }
      results = processSelectAll(request);
      @elseif{ modelMethod == "MODEL_CHAIN" }
      result = processModelChain(request);
      @end{}



      return results != null ? results : Arrays.asList(result);
   }
   
   @Override
   public Map<String,SegmentExecution> getSegmentExecutions() {
      return segmentExecutions;
   }
   
   
   private PMML4Result processSelectFirst(PMML4Result result, PMMLRequestData requestData) {
      boolean selected = false;
      List<PMML4Result> results = new ArrayList<>();
      @foreach{seg: segments}
      if (!selected && canFireSegment@{seg.segmentId}()) {
         Class<?> ruleUnitClass = @{seg.segmentRuleUnit}.class;
         results.addAll(submitSegment@{seg.segmentId}(ruleUnitClass,requestData));
         selected = true;
      }
      @end{}
      if (!results.isEmpty()) {
         result = results.get(0);
      }
      return result;
   }
   
   private List<PMML4Result> processSelectAll(PMMLRequestData requestData) {
      List<PMML4Result> results = new ArrayList<>();
      @foreach{seg: segments}
      if (canFireSegment@{seg.segmentId}()) {
         Class<?> ruleUnitClass = @{seg.segmentRuleUnit}.class;
         results.addAll(submitSegment@{seg.segmentId}(ruleUnitClass,requestData));
      }
      @end{}
      return results;
   }
   
   private PMML4Result processModelChain(PMMLRequestData requestData) {
      PMML4Result result = new PMML4Result(requestData.getCorrelationId());
      PMML4Result segResult = null;
      int count = 0;
      @foreach{seg: segments}
      if (canFireSegment@{seg.segmentId}()) {
         Class<?> ruleUnitClass = @{seg.segmentRuleUnit}.class;
         if (segResult != null) {
            @foreach{fld: seg.model.miningFields}@if{ !fld.inDictionary }
            requestData.addRequestParam("@{fld.name}",segResult.getResultValue("@{fld.compactUpperCaseName}","value") );
            miningObject.setV@{fld.compactUpperCaseName}( (@{fld.type})segResult.getResultValue("@{fld.compactUpperCaseName}","value") );
            @end{}@end{}
         }
         List<PMML4Result> subModelResults = submitSegment@{seg.segmentId}(ruleUnitClass,requestData);
         if (subModelResults != null) {
            if (subModelResults.size() > 1) {
               segResult = subModelResults.stream().filter( r -> r.getSegmentationId() == null && r.getSegmentId() == null ).findFirst().orElse(null);
            } else {
               segResult = (!subModelResults.isEmpty()) ? subModelResults.get(0) : null;
            }
         } else {
            segResult = null;
         }
         Map<String,Object> resultsMap = segResult != null ? segResult.getResultVariables() : null;
         if (resultsMap != null && !resultsMap.isEmpty()) {
            resultsMap.entrySet().forEach( e -> {
               result.addResultVariable(e.getKey(),e.getValue());
            });
         } else {
            System.out.println("!!! Empty results map !!!");
         }
      }
      @end{}
      result.setResultCode("OK");
      return result;
   }
   
   @foreach{ seg: segments }
   private List<PMML4Result> submitSegment@{seg.segmentId}(Class<?> ruleUnitClass, PMMLRequestData requestData) {
      PMML4Result baseResult = null;
      List<PMML4Result> segmentResults = null;
      try {
         if (PMMLRuleUnit.class.isAssignableFrom(ruleUnitClass)) {
            PMMLRuleUnit ru = (PMMLRuleUnit) ruleUnitClass.newInstance();
            ModelApplier ma = (ru != null) ? ru.getModelApplier() : null;
            if (ma != null) {
               segmentResults = ma.applyModel(requestData, kbase, ru);
            }
         } else if (RuleUnit.class.isAssignableFrom(ruleUnitClass)) {
            PMMLRequestData rdata = new PMMLRequestData(requestData.getCorrelationId(), "@{seg.model.modelId}");
            @foreach{ fld: seg.model.miningFields}
            rdata.addRequestParam("@{fld.name}",miningObject.getV@{fld.compactUpperCaseName}());
            @end{}
            Class<? extends RuleUnit> ruc = (Class<? extends RuleUnit>)ruleUnitClass.newInstance().getClass();
            @{seg.model.miningPojoClassName} modelObject = new @{seg.model.miningPojoClassName}(rdata);
            baseResult = new PMML4Result(requestData.getCorrelationId());
            baseResult.setSegmentationId("@{seg.owner.segmentationId}");
            baseResult.setSegmentId("@{seg.segmentId}");
            RuleUnitExecutor executor = RuleUnitExecutor.create().bind(kbase);
            executor.getKieSession().insert(modelObject);
            turnOnLogging(executor);
            DataSource rqstData = executor.newDataSource("request");
            DataSource results = executor.newDataSource("results");
            DataSource pmmlData = executor.newDataSource("pmmlData");
            rqstData.insert(rdata);
            results.insert(baseResult);
            int count = executor.run(ruc);
            segmentResults = new ArrayList<>();
            
            for ( Iterator<PMML4Result> iter = results.iterator(); iter.hasNext(); ) {
               Object o = iter.next();
               if (PMML4Result.class.isAssignableFrom(o.getClass())) {
                  PMML4Result segRes = (PMML4Result)o;
                  if (segRes.getSegmentationId() != null && segRes.getSegmentId() != null) {
                     String execId = segRes.getSegmentationId() + "_" + segRes.getSegmentId();
                     SegmentExecution segEx = this.segmentExecutions.get(execId);
                     if (segEx != null) {
                        segEx.setResult(segRes);
                     }
                  }
                  segmentResults.add(segRes);
               }
            }
         }
      } catch (InstantiationException e) {
         throw new RuntimeException("InstantiationException while attempting to create PMMLRuleUnit instance - @{modelName}", e);
      } catch (IllegalAccessException e) {
         throw new RuntimeException("IllegalAccessException while attempting to create a PMMLRuleUnit instance - @{modelName}", e);
      }
      return segmentResults;
   } 
   
   
   private boolean canFireSegment@{seg.segmentId}() {
      @if{ seg.alwaysTrue }return true;@elseif{ seg.alwaysFalse }return false;@else{}
      return @{seg.getJavaPredicateText("miningObject")};
      @end{}
   }
   @end{}


   private void turnOnLogging(RuleUnitExecutor executor) {
      executor.getKieSession().addEventListener(new AgendaEventListener() {
    
        @Override
        public void matchCreated(MatchCreatedEvent event) {
            // TODO Auto-generated method stub
        
        }
        
        @Override
        public void matchCancelled(MatchCancelledEvent event) {
            // TODO Auto-generated method stub
        
        }
        
        @Override
        public void beforeRuleFlowGroupDeactivated(RuleFlowGroupDeactivatedEvent event) {
            // TODO Auto-generated method stub
        
        }
        
        @Override
        public void beforeRuleFlowGroupActivated(RuleFlowGroupActivatedEvent event) {
            // TODO Auto-generated method stub
        
        }
        
        @Override
        public void beforeMatchFired(BeforeMatchFiredEvent event) {
            // TODO Auto-generated method stub
            System.out.println("Firing " + event.getMatch().getRule().getName());
        }
        
        @Override
        public void agendaGroupPushed(AgendaGroupPushedEvent event) {
            // TODO Auto-generated method stub
        
        }
        
        @Override
        public void agendaGroupPopped(AgendaGroupPoppedEvent event) {
            // TODO Auto-generated method stub
        
        }
        
        @Override
        public void afterRuleFlowGroupDeactivated(RuleFlowGroupDeactivatedEvent event) {
            // TODO Auto-generated method stub
        
        }
        
        @Override
        public void afterRuleFlowGroupActivated(RuleFlowGroupActivatedEvent event) {
            // TODO Auto-generated method stub
        
        }
        
        @Override
        public void afterMatchFired(AfterMatchFiredEvent event) {
            // TODO Auto-generated method stub
        
        }
      });
      executor.getKieSession().addEventListener(new RuleRuntimeEventListener() {
            
            @Override
            public void objectUpdated(ObjectUpdatedEvent event) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void objectInserted(ObjectInsertedEvent event) {
                // TODO Auto-generated method stub
                DefaultFactHandle handle = (DefaultFactHandle)event.getFactHandle();
                System.out.println("Inserting fact: "+handle.getObjectClassName());
            }
            
            @Override
            public void objectDeleted(ObjectDeletedEvent event) {
                // TODO Auto-generated method stub
                DefaultFactHandle handle = (DefaultFactHandle)event.getFactHandle();
                System.out.println("Deleting fact: "+handle.getObjectClassName());
            }
        });
   }


   
}
@end{}
@includeNamed{'miningModelApplier'}